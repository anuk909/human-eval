{"task_id": "hard/5", "prompt": "def locate_treasured_item(market_map, window_size):\n    \"\"\"\n    In an enchanted marketplace located in the middle of a vast desert, each location in the marketplace is marked with a unique charm value. You are given a 2D map `market_map` of this marketplace where each cell represents the charm value, a non-negative integer.\n\n    Your task is to locate the maximum charm density (calculated as the average charm) in any `window_size`x`window_size` subgrid (or sliding window) of the marketplace.\n\n    For example, if `market_map` is:\n    [\n      [1, 2, 3],\n      [4, 5, 6],\n      [7, 8, 9]\n    ]\n    and `window_size` is 2, the maximum charm density is 7.0 as the maximum average is from the bottom-right 2x2 subgrid ([5, 6, 8, 9]).\n\n    Constraints:\n    - The map will at least be as large in both dimensions as `window_size`.\n    - The values in `market_map` are non-negative integers.\n\n    Note: Use efficient algorithms to handle large maps efficiently, considering that the maximum density may need to be recalculated multiple times for different positions.\n    \"\"\"\n", "entry_point": "locate_treasured_item", "canonical_solution": "def locate_treasured_item(market_map, window_size):\n    def window_average(i, j):\n        return sum(market_map[x][y] for x in range(i, i+window_size) for y in range(j, j+window_size)) / (window_size ** 2)\n\n    max_density= float('-inf')\n    n, m = len(market_map), len(market_map[0])\n    for i in range(n - window_size + 1):\n        for j in range(m - window_size + 1):\n            current_density = window_average(i, j)\n            max_density = max(max_density, current_density)\n    return max_density", "test": "def check(candidate):\n    assert abs(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2) - 7.0) < 1e-9\n    assert abs(candidate([[10, 20, 30], [40, 50, 60], [70, 80, 90]], 3) - 50.0) < 1e-9\n    assert abs(candidate([[0, 12, 4], [25, 1, 44], [96, 75, 9]], 2) - 50.25) < 1e-9\n    assert abs(candidate([[0, 0, 0, 0], [0, 10, 10, 0], [0, 10, 10, 0], [0, 0, 0, 0]], 2) - 10.0) < 1e-9\n    assert abs(candidate([[1, 1], [1, 1]], 1) - 1.0) < 1e-9", "invalid_reason": "Valid with warnings: ['Solution failed correctness check.']"}
{"task_id": "hard/4", "prompt": "def decode_combinations(message, pattern_rules):\n    \"\"\"\n    In a dystopian cyberpunk jungle city, you are a master hacker decoding secret messages from factions.\n    The messages are encoded with a combination of numbers which represent sequences of actions based on complex patterns.\n\n    You are provided with the encoded message as a string of digits 'message' and the decoding rules as a dictionary 'pattern_rules'. Each key in the dictionary is a string of a single digit 'd' which maps to a list of strings. Each string in the list represents a different action that can be evoked by digit 'd'.\n\n    Your task is to calculate the number of different ways the message can be decoded based on the provided pattern_rules.\n\n    Example:\n    - If the input message is '121' and pattern_rules is { '1': ['a'], '2': ['b'], '12': ['l'] }, it means:\n      '1' can be decoded as 'a',\n      '2' can be decoded as 'b',\n      '12' can be decoded as 'l'.\n    - There are two ways to decode '121': 'a' + 'b' + 'a' (by decoding each digit individually) or 'l' + 'a' (by decoding '12' then '1').\n    - Both ways would result in different sequences of action, hence the result should be 2.\n\n    Constraints:\n    - The message consists only of digits from '0' to '9'.\n    - The pattern_rules dictionary will only contain keys which are valid segments of the message and each key points to a list containing at least one string.\n    - The product of the lengths of all list values in the dictionary pattern_rules is guaranteed to be less than or equal to 1000 to keep processing within reasonable limits.\n    \"\"\"\n", "canonical_solution": "    def decode_combinations(message, pattern_rules):\n        def helper(index):\n            if index == len(message):\n                return 1\n            if index in memo:\n                return memo[index]\n            ways = 0\n            for length in range(1, min(len(message) - index + 1, max_len + 1)):\n                part = message[index:index+length]\n                if part in pattern_rules:\n                    for action_sequence in pattern_rules[part]:\n                        ways += helper(index + length)\n            memo[index] = ways\n            return ways\n\n        max_len = max(map(len, pattern_rules))\n        memo = {}\n        return helper(0)", "test": "def check(candidate):\n    assert candidate('121', {'1': ['a'], '2': ['b'], '12': ['l']}) == 2\n    assert candidate('123', {'1': ['a'], '2': ['b'], '3': ['c'], '23': ['x']}) == 3\n    assert candidate('1111', {'1': ['a'], '11': ['b']}) == 5\n    assert candidate('726', {'7': ['g'], '2': ['b'], '6': ['f'], '72': ['z']}) == 2\n    assert candidate('', {'0': ['z']}) == 1\n    assert candidate('909', {'9': ['i'], '0': ['o'], '90': ['y'], '09': ['w']}) == 2", "entry_point": "decode_combinations", "invalid_reason": "Valid with warnings: ['Solution failed correctness check.', \"5, Incomplete Constraints: The problem lacks specifications regarding how to handle leading zeros in the message and whether zero ('0') can have decode rules. It's unclear whether the message could start with '0', and if it does, whether '0' can be represented in pattern_rules. Ambiguities about handling zeros can significantly affect solving the problem correctly.\", \"4, Ambiguous Handling of the Empty Message: The test case suggests that decoding an empty message should return 1, but the problem statement doesn't explicitly mention how to handle an empty message. This omission can lead to divergent interpretations of how to proceed in this edge case.\"]"}
{"task_id": "hard/1", "prompt": "def encode_path(teleporter_symbols, balloon_images):\n    \"\"\"\n    You are tasked to navigate a fantasy world with two modes of transportation: teleporters and hot air balloons. Each teleporter is marked by a unique sequence of symbols and each hot air balloon journey is captured as a series of images.\n\n    To encode your path, combine the given teleporter symbols and the features extracted from the balloon images using a Trie and Ternary Search. The sequence of symbols represents teleporter paths and each image from the hot air balloon rides can be interpreted into shapes that are then converted to similar symbol sequences.\n\n    Each image is represented as a list of shape symbols (extracted features). Your task is to construct a Trie with teleporter symbols and integrate sequences from hot air balloon images after transforming them through a conversion function (simulate extraction and matching symbols from the images).\n\n    - Use a Trie to record journeys through teleporters and hot air balloon rides.\n    - Utilize Ternary Search on the Trie to find and confirm if a desired path sequence exists as you travel.\n\n    Example:\n    If teleporter_symbols are ['abc', 'abd', 'ae', 'bcd'] and balloon_images are [['circle', 'square', 'triangle'], ['square', 'triangle']], assuming 'circle' maps to 'a', 'square' to 'b', and 'triangle' to 'c', your converted balloon paths are ['abc', 'bc'].\n\n    Note: Assume you have implemented a 'shape_to_symbol' function that maps shapes to symbols, a 'Trie' class implementation and a 'find_with_ternary_search' function that searches for a sequence in the Trie using ternary search.\n\n    \"\"\"", "canonical_solution": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\ndef shape_to_symbol(shape):\n    mapping = {'circle': 'a', 'square': 'b', 'triangle': 'c'}\n    return mapping[shape]\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    def insert(self, word):\n        cur_node = self.root\n        for char in word:\n            if char not in cur_node.children:\n                cur_node.children[char] = TrieNode()\n            cur_node = cur_node.children[char]\n        cur_node.is_end_of_word = True\n\n    def search(self, word):\n        cur_node = self.root\n        for char in word:\n            if char not in cur_node.children:\n                return False\n            cur_node = cur_node.children[char]\n        return cur_node.is_end_of_word\n\n    def starts_with(self, prefix):\n        cur_node = self.root\n        for char in prefix:\n            if char not in cur_node.children:\n                return False\n            cur_node = cur_node.children[char]\n        return True\n\ndef find_with_ternary_search(trie, sequence):\n    # Incorporate your ternary search logic here\n    return trie.search(sequence)\n\n    def encode_path(teleporter_symbols, balloon_images):\n        trie = Trie()\n        for symbol in teleporter_symbols:\n            trie.insert(symbol)\n        for images in balloon_images:\n            converted_sequence = ''.join(shape_to_symbol(shape) for shape in images)\n            trie.insert(converted_sequence)\n        # Additional logic and methods would be added here to fully utilize search functionalities\n        return trie", "test": "def check(candidate):\n    trie = candidate(['abc', 'abd', 'ae', 'bcd'], [['circle', 'square', 'triangle'], ['square', 'triangle']])\n    assert trie.search('abc') == True\n    assert trie.search('bc') == True\n    assert trie.search('ae') == True\n    assert trie.starts_with('ab') == True\n    assert trie.search('xyz') == False\n    assert trie.starts_with('bcd') == True", "entry_point": "encode_path", "invalid_reason": "Valid with warnings: ['Solution failed correctness check.', '5, Missing Input Specifications: The problem statement does not specify the arrangement of input types and restrictions clearly. There is ambiguity regarding the data types (strings, integers, etc.), and it lacks constraints (e.g., maximum length of sequences).', \"5, Undefined Conversion Logic Scope: Although there's an assumption that the `shape_to_symbol` function is implemented, it should either be explicitly provided in the prompt constraints or the prompt should handle its implementation as part of the problem.\", '5, Lack of Clear Output Specifications: The prompt does not clearly define what should be the format of the output or the final state returned after the encoding process.', '5, Inconclusive Test Case Rationale: The test cases provided do not clarify the testing of Ternary Search specifically, as the concept is mentioned but not explicitly tested or demonstrated in the canonical solution or test setups.', '4, Misuse of Terminology: The problem casually implies the use of \"Ternary Search\". However, ternary search is generally applied to sorted arrays, and its adaptation to Trie data structure isn\\'t clearly justified or elaborated, leading to confusion.', '4, Ambiguity in `Trie` and `Ternary Search` Integration: There is a conceptual disconnect in how the Trie and ternary search should function together. Generally, Ternary Search Trees are a different data structure than Tries. This could lead to ambiguity regarding whether a Trie or Ternary Search Tree should be implemented.']"}
{"task_id": "hard/2", "prompt": "def explore_bioluminescence(grid, patterns):\n    \"\"\"\n    In the lore of virtual explorers, there's a lost city surrounded by a unique bioluminescent ocean, which forms distinct patterns each night. Your mission as an explorer is to find a matching pattern within the ocean grid using unique observational techniques.\n\n    The ocean's nightly patterns are represented as a list of lists, `grid`, where each element is a binary representation (0 or 1) of bioluminescent presence. The patterns to find are also binary represented in a list called `patterns`, which themselves are lists of lists.\n\n    Your exploration tool employs a technique where it overlays a pattern onto the grid and uses a bitwise AND operation to determine matches. A pattern matches a region in the grid if the following conditions are met when overlaying the top-left corner of the pattern onto each position in the grid:\n    - For all (i, j) within the dimensions of the pattern, the pattern and the overlapping grid segment must be perfectly matched using bitwise AND operation.\n\n    Create a function that will determine if any of the patterns can be found within the grid via this method. Return True if at least one pattern matches any region of the grid and False otherwise.\n\n    Example:\n    grid = [[0,1,0,1], [1,0,1,0], [0,1,0,1], [1,0,1,0]]\n    patterns = [[[1,0], [0,1]], [[0,1], [1,0]]]\n\n    The function should return True as the second pattern matches the top-left 2x2 in the grid.\n\n    Note:\n    - The size of each pattern will always be smaller than or equal to the size of the grid.\n    - Patterns and grids are square or rectangular in shape.\n    \"\"\"\n", "canonical_solution": "    def explore_bioluminescence(grid, patterns):\n        rows, cols = len(grid), len(grid[0])\n\n        def check_match(grid, pattern, start_row, start_col):\n            for i in range(len(pattern)):\n                for j in range(len(pattern[0])):\n                    if (grid[start_row + i][start_col + j] & pattern[i][j]) != pattern[i][j]:\n                        return False\n            return True\n\n        for pattern in patterns:\n            for start_row in range(rows - len(pattern) + 1):\n                for start_col in range(cols - len(pattern[0]) + 1):\n                    if check_match(grid, pattern, start_row, start_col):\n                        return True\n        return False", "test": "def check(candidate):\n    assert candidate([[0,1,0,1], [1,0,1,0], [0,1,0,1], [1,0,1,0]], [[[1,0], [0,1]], [[0,1], [1,0]]]) == True\n    assert candidate([[1,1,1,1]], [[[0]]]) == False\n    assert candidate([[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]], [[[1]]]) == False\n    assert candidate([[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]], [[[1,1],[1,1]], [[0,0],[0,0]]]) == True\n    assert candidate([[1,0,1],[0,1,0],[1,0,1]], [[[0,1,0],[1,0,1],[0,1,0]]]) == True", "entry_point": "explore_bioluminescence", "invalid_reason": "Valid with warnings: ['Solution failed correctness check.', \"5, Logical contradiction in problem description: The problem statement contradicts itself in explaining the matching criteria using bitwise AND operation. It suggests that the pattern should match exactly using a bitwise AND, but the example given ([0,1], [1,0]) actually does not match the grid ([0,1], [1,0]) with bitwise AND. This is because the bitwise AND of corresponding elements gives the same pattern, which contradicts the natural outcome of a bitwise AND, normally expected to yield intersections based on binary '1's.\", \"4, Lack of clarity in pattern-matching conditions: The description of how the patterns should match an area of the grid is vague. It states that a pattern matches if the bitwise AND for all positions is true, which is usually interpreted as both values being '1'. However, the example seems to imply exact equality instead of a classic AND operation. This ambiguity can lead to different interpretations and thus incorrect implementations.\"]"}
{"task_id": "hard/3", "prompt": "def optimal_path_cost(obstacles, costs, start, end):\n    \"\"\"\n    Farmer John recently got a new self-driving car that he wants to use to help in transporting goods from one corner of his large farm to the other. His farm can be conceptualized as a 2D grid where each cell represents a particular area and can either have an obstacle or be free to drive through.\n\n    Some areas of the farm are costlier to drive through due to the terrain, and these costs are provided in a dictionary where keys are coordinates (row, col) and values are the driving cost for that cell. The car can only move right or down at any point in time.\n\n    Furthermore, given that Farmer John competes with his neighbour, the path your function chooses must optimize for both minimal cost and minimal distance to stay competitive.\n\n    Implement a function that determines the minimal cumulative cost from a 'start' coordinate to an 'end' coordinate on the farm grid considering the given obstacles and costs. If it's impossible to reach the 'end' from the 'start', the function should return -1.\n\n    Example:\n    obstacles = {(1, 1), (3, 2)}\n    costs = {(0, 0): 2, (0, 1): 3, (0, 2): 1, (1, 0): 2, (1, 2): 1, (2, 0): 2, (2, 1): 3, (2, 2): 1, (3, 0): 1, (3, 1): 1}\n    start = (0, 0)\n    end = (3, 2)\n    Output should be 10 because the optimal path is (0,0) -> (0,1) -> (0,2) -> (2,0) -> (2,1) -> (2,2) -> (3,2) with total cost of 2 + 3 + 1 + 2 + 3 + 1 + 1.\n\n    Note:\n    - You must consider the grid as having limited movement options (only right or down).\n    - The car should avoid obstacles entirely.\n    - Consider utilizing A* algorithm with heuristics for both cost and shortest distance for optimization. \n    - The grid's maximum dimensions are capped at 100x100.\n    - No constraint on the number of obstacles, but they will always be within the grid bounds.\n    \"\"\"", "canonical_solution": "    import heapq\n\n    def heuristic(a, b):\n        return abs(b[0] - a[0]) + abs(b[1] - a[1])\n\n    def optimal_path_cost(obstacles, costs, start, end):\n        if start in obstacles or end in obstacles:\n            return -1\n        open_set = [(heuristic(start, end) + costs.get(start, 0), 0, start)]\n        heapq.heapify(open_set)\n        g_score = {start: 0}\n        f_score = {start: heuristic(start, end) + costs.get(start, 0)}\n\n        while open_set:\n            _, cost, current = heapq.heappop(open_set)\n            if current == end:\n                return cost\n            for dx, dy in [(1, 0), (0, 1)]:\n                neighbor = (current[0]+dx, current[1]+dy)\n                if 0 <= neighbor[0] < 100 and 0 <= neighbor[1] < 100 and neighbor not in obstacles:\n                    tentative_g_score = g_score[current] + costs.get(neighbor, 0)\n                    if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                        g_score[neighbor] = tentative_g_score\n                        f_cost = tentative_g_score + heuristic(neighbor, end)\n                        heapq.heappush(open_set, (f_cost, cost + costs.get(neighbor, 0), neighbor))\n                        f_score[neighbor] = f_cost\n        return -1", "test": "def check(candidate):\n    assert candidate({(1, 1), (3, 2)}, {(0, 0): 2, (0, 1): 3, (0, 2): 1, (1, 0): 2, (1, 2): 1, (2, 0): 2, (2, 1): 3, (2, 2): 1, (3, 0): 1, (3, 1): 1}, (0, 0), (3, 2)) == 10\n    assert candidate({(0, 0), (1, 1)}, {}, (0, 0), (1, 0)) == -1\n    assert candidate({}, {(0, 0): 2, (0, 1): 3, (1, 0): 1}, (0, 0), (1, 0)) == 3\n    assert candidate({}, {(0, 0): 2}, (0, 0), (0, 0)) == 2\n    assert candidate({(1, 0)}, {(0, 0): 1, (0, 1): 1, (0, 2): 5, (1, 1): 2, (1, 2): 3}, (0, 0), (1, 2)) == 6", "entry_point": "optimal_path_cost", "invalid_reason": "Valid with warnings: ['Solution failed correctness check.', '4, Inconsistent Problem Requirements: The problem statement specifies optimizing both for minimal cost and minimal distance, but in the provided example and explanation, only the minimal cost seems to be taken into account. This discrepancy makes the problem confusing and possibly misleading about its objectives.']"}
