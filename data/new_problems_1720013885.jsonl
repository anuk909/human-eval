{"task_id": "hard/1", "prompt": "def cosmic_carnival_wizard(spell_strengths):\n    \"\"\"\n    At the Cosmic Carnival, a gathering of powerful wizards, each wizard takes turns showcasing their magic. The strength of their spells is represented as a list of positive integers. However, the carnival has a unique rule: the sequence of spell strengths can only be shown at the carnival if it can be split into strictly decreasing sequences according to Lyndon factorization (a process used in combinatorial algorithms where a string is uniquely partitioned into a sequence of the smallest possible non-increasing sequences).\n\n    Write a function that takes a list of integer spell strengths and returns True if the sequence can be split into strictly decreasing sequences based on Lyndon factorization without any reordering, False otherwise.\n\n    For example, if the input sequence is [3, 2, 1], then it will return True because [3, 2, 1] is already a strictly decreasing sequence. However, [2, 1, 3] would return False because the only possible ordering by Lyndon factorization is [2, 1, 3] which can't be split into strictly decreasing subsequences without reordering.\n\n    Note: The input list of spell strengths will be non-empty and will contain positive integers only. The method should evaluate whether the input list constitutes a single valid strictly decreasing Lyndon sequence.\n    \"\"\"\n", "canonical_solution": "    def is_strictly_decreasing(seq):\n        return all(seq[i] > seq[i+1] for i in range(len(seq)-1))\n\n    def is_lyndon_sequence(sequence):\n        n = len(sequence)\n        i = 0\n        while i < n:\n            j = i + 1\n            k = i\n            while j < n and sequence[k] >= sequence[j]:\n                if sequence[k] > sequence[j]:\n                    k = i\n                else:\n                    k += 1\n                j += 1\n            while i <= k:\n                i += j - k\n        return i == 1\n\n    return is_lyndon_sequence(spell_strengths) and is_strictly_decreasing(spell_strengths)", "test": "def check(candidate):\n    assert candidate([3, 2, 1]) == True\n    assert candidate([1, 2, 3]) == False\n    assert candidate([10, 9, 8, 7, 6]) == True\n    assert candidate([3, 2, 1, 0]) == True\n    assert candidate([5, 4, 3, 2, 1, 1]) == False\n    assert candidate([10]) == True\n    assert candidate([2, 1, 3, 2, 1]) == False", "entry_point": "cosmic_carnival_wizard", "extra_info": {"cover_story_words": ["wizards", "cosmic carnival"], "topics": ["Array", "Lyndon Factorization"], "cleaned_prompt": "Write a function that takes a list of integer spell strengths and returns True if the sequence can be split into strictly decreasing sequences based on Lyndon factorization without any reordering, False otherwise.", "warnings": ["Solution failed correctness check.", "4, Unclear Definitions and Contradicting Requirements: The problem states the need for sequences to be split according to \"Lyndon factorization\" but then imposes a check for the entire sequence to be strictly decreasing. Lyndon factorization, by definition, involves breaking a sequence into chunks that are each non-decreasing from their respective subsequences, but then the task seems to only validate sequences that are wholly strictly decreasing, which conflicts with having any meaningful use of Lyndon factorization in the first place. This not only confuses the notion of what Lyndon factorization constitutes but also puts contradictory requirements on the sequence handling.", "5, Logical Error in Problem Requirement: According to the Lyndon factorization process, sequences are broken into the smallest possible non-increasing chunks, not strictly decreasing sequences as the problem statement erroneously states. This fundamental error in understanding the Lyndon factorization makes the problem statement logically flawed and impractical unless it is revised to match either the correct definition of Lyndon sequences or adjusts expectations of sequence decrementing."]}}
{"task_id": "hard/5", "entry_point": "find_ghost_sequences", "prompt": "def find_ghost_sequences(shrink_factor, logs):\n    \"\"\"\n    You, a renowned ghost-catcher, are on a haunted ship that has been miniaturized by a shrink ray. The logs of the ship, represented as timestamps of ghost activities, are also affected by the shrink ray. Each ghost activity log is represented by a letter (e.g., 'a', 'b', 'c'). You are given these logs as a string in which each character represents a ghost activity timestamp. Due to the shrink ray effect, some sequences are replicated excessively in the logs. Your task is to identify these frequent sequences of ghost activities that are of length equal to the 'shrink_factor'.\n\n    To solve this, you should use a combination of the Boyer-Moore Algorithm and a Persistent Segment Tree. Use the Boyer-Moore Algorithm to identify the most frequent string of length 'shrink_factor'. Then use a Persistent Segment Tree to handle and query sequence data efficiently as the ship navigates through haunted areas, which could modify the log in real-time.\n\n    Parameters:\n        shrink_factor (int): The length of the sequence to inspect and identify.\n        logs (str): A string representing timestamps of ghost activities.\n\n    Return:\n        str: The most frequent sequence of ghost activities of length 'shrink_factor'.\n\n    Note:\n        - If 'shrink_factor' is more than the length of logs or zero, return an empty string.\n        - Assume logs consist only of lowercase letters.\n    \"\"\"\n", "canonical_solution": "    def find_boyer_moore_most_frequent(s, k):\n        # Using a modified Boyer-Moore Voting Algorithm to find the most frequent k-length substring\n        if len(s) < k or k == 0:\n            return ''\n        freq = {}\n        for i in range(len(s) - k + 1):\n            substr = s[i:i+k]\n            if substr in freq:\n                freq[substr] += 1\n            else:\n                freq[substr] = 1\n        return max(freq, key=freq.get, default='')\n\n    def find_ghost_sequences(shrink_factor, logs):\n        # Application of persistent segment tree is abstracted since detailed implementation goes beyond simple coding interview problems.\n        return find_boyer_moore_most_frequent(logs, shrink_factor)", "test": "def check(candidate):\n    assert candidate(3, 'abcabcaabcabc') == 'abc'\n    assert candidate(4, 'ghghghghkrkrkrkrghghghgh') == 'ghgh'\n    assert candidate(2, 'xyxyxyzxyz') == 'xy'\n    assert candidate(5, 'a single long single long long single') == 'long '\n    assert candidate(0, 'does not matter') == ''\n    assert candidate(10, 'short') == ''", "extra_info": {"cover_story_words": ["shrink ray", "haunted ship"], "topics": ["Persistent Segment Tree", "Boyer-Moore Algorithm"], "cleaned_prompt": "def find_ghost_sequences(shrink_factor, logs):\n    from typing import List\n    return \"\"", "warnings": ["Solution failed correctness check.", "4, Technique Mismatch: The task description suggests using the Boyer-Moore Algorithm in conjunction with a Persistent Segment Tree. The Boyer-Moore Algorithm is generally used for string matching, not for finding the most frequent substrings, which is the problem posed here. The usage of a Persistent Segment Tree is also questionable for the required functionality, as it is typically used for different types of problems involving multiple versions of an array or tree structure, rather than for managing substrings in real-time dynamic scenarios as implied.", "5, Overcomplication: The prompt involves an unnecessarily complex suggestion to use advanced algorithms and data structures which might not be the best suited or the most efficient for solving the problem of finding the most frequent substring of a given length. This can mislead participants and potentially increase the difficulty of implementation without a clear benefit."]}}
{"task_id": "hard/2", "prompt": "def amusement_park_justice(rides, queries):\n    \"\"\"\n    In an amusement park, there is a unique way of maintaining order in the queues for rides. Each ride queue uses a linked list to manage its visitors. Every visitor in the queue has a number associated with them and the list is ordered from first to last visitor. There's a nearby courtroom where disputes about queue positions are settled. The courtroom queries the position of certain visitors using a suffix of visitor sequence numbers from the linked list.\n\n    Your task is to implement a function that will handle the process of answering these queries given the current state of any ride's queue.\n\n    `rides` is a LinkedList containing integers representing visitor sequence numbers in the queue.\n    `queries` is a list of integer suffixes where each suffix is a subpart of the sequence number to be checked against the visitors in the queue.\n\n    The function should return a list of booleans, where each boolean corresponds to a query and is True if that suffix appears in any visitor's sequence number in the list; otherwise False.\n\n    For example, if rides LinkedList has elements [104, 32, 235], and queries was [4, 35], the results should be [True, False] since '4' is a suffix of '104', but there's no sequence ending in '35'.\n\n    Note:\n    - The implementation should be efficient in terms of both time and computing power due to the large number of possible visitors in the queue.\n    - Assume that `rides` has a typical linked list structure with nodes containing 'data' and a 'next' link.\n    \"\"\"", "canonical_solution": "class Node:\n    def __init__(self, data=None, next=None):\n        self.data = data\n        self.next = next\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        if not self.head:\n            self.head = Node(data)\n        else:\n            current = self.head\n            while current.next:\n                current = current.next\n            current.next = Node(data)\n\n\ndef amusement_park_justice(rides, queries):\n    result = []\n    currents and comparisons for suffix checks. Assume we are using a simple Node based linked list without a tail pointer.\n\n    current = rides.head\n    while current:\n        turn current.data into a string and check if it ends with the query suffix. If so, append True; otherwise, append True for any query that matches.\n\n    return result", "test": "def check(candidate):\n    rides = LinkedList()\n    rides.append(104)\n    rides.append(32)\n    rides.append(235)\n\n    assert candidate(rides, [4, 35]) == [True, False]\n    assert candidate(rides, [104, 235]) == [True, True]\n    assert candidate(rides, [500]) == [False]\n    assert candidate(rides, [32]) == [True]\n    assert candidate(rides, [5]) == [False]\n    assert candidate(rides, [2]) == [True]", "entry_point": "amusement_park_justice", "extra_info": {"cover_story_words": ["courtroom", "amusement park"], "topics": ["Linked List", "Suffix Array"], "cleaned_prompt": "Implement a function to search for suffix matches in a linked list. The function receives a LinkedList containing integers and a list of integer queries. It should return a list of booleans indicating if any integer in the LinkedList ends with the queried suffix.", "warnings": ["Solution failed correctness check.", "4, Flawed Canonical Solution Example: The canonical solution provided in the prompt contains incomplete and incorrect Python code. It is unfinished as the inner loop that checks for suffix matches in the linked list isn't implemented. The description includes filler text which doesn't contribute to an actual executable solution. This requires attention, as candidates would not be able to derive meaningful insights or revisions from it. Moreover, the logic for appending True in cases of non-matching suffixes ('otherwise, append True for any query that matches.') is ambiguous and contradicts the task's requirements, fostering confusion.", "5, Flawed Problem Design: The task does not explicitly mention complexity requirements or constraints about the number of visitors, size of input, or allowed operations, yet it suggests that the implementation should be efficient in handling a potentially large number of visitors. Without clear constraints, it's difficult for candidates to optimize their solutions effectively or to fully understand the expected performance. This could lead to solutions that do not scale well or meet the implicit expectations of the problem.", "4, Inconsistent Test Cases Description: The test cases provided do not include actual implementations but seem to describe what the test cases should validate. This might confuse participants who would expect more clear and executable test snippets in the test section. Having properly outlined and ready-to-run test cases helps in validating and quickly testing the provided solutions, ensuring that they meet the requirements laid out in the prompt."]}}
{"task_id": "hard/3", "prompt": "def storm_of_lagoon_quality(n, edges, air_quality):\n    \"\"\"\n    A supernatural storm affects a hidden lagoon structured as n magical chambers joined by passages. The lagoon can be represented as a directed graph with n vertices and certain edges representing one-directional passages. Each chamber's air quality is initially set but fluctuates directly as a result of the storm's influence through the passages.\n\n    The storm has influenced the chambers to the point where chambers connected in a Strongly Connected Component (SCC) now have their air quality values Fourier transformed across the entire SCC. Considering this changes air quality values to a domain designed for efficient sequence manipulation, it makes quality inspection nonlinear and complicated.\n\n    Implement a function that returns the modified air quality values for each chamber after accommodating for the Fourier transform effects within each SCC.\n\n    Note:\n    - The Fourier transform should consider only the real parts of the air quality values, and you can return them rounded to the nearest integer.\n    - Use a Fast Fourier Transform (FFT) for efficiency due to potential high complexity with larger lagoons (graphs).\n    - You must deal with handling SCC detection and application of FFT within each SCC separately.\n\n    Parameters:\n    n : int\n        Number of chambers (vertices in the graph).\n    edges : List[Tuple[int, int]]\n        A list of directed edges between chambers (from chamber i to chamber j).\n    air_quality : List[int]\n        Initial air quality values for each chamber.\n    \"\"\"", "canonical_solution": "def storm_of_lagoon_quality(n, edges, air_quality):\n    from scipy.fft import fft\n    from scipy.fft import ifft\n    from collections import defaultdict, deque\n\n    # Helper function to find all SCCs using Tarjan's Algorithm\n    def find_sccs(n, edges):\n        index = 0\n        stack = []\n        indices = [-1] * n\n        lowlink = [-1] * n\n        on_stack = [False] * n\n        sccs = []\n\n        def strongconnect(v):\n            nonlocal index\n            indices[v] = index\n            lowlink[v] = index\n            index += 1\n            stack.append(v)\n            on_stack[v] = True\n\n            for _, w in [e for e in edges if e[0] == v]:\n                if indices[w] == -1:\n                    strongconnect(w)\n                    lowlink[v] = min(lowlink[v], lowlink[w])\n                elif on_stack[w]:\n                    lowlink[v] = min(lowlink[v], indices[w])\n\n            if lowlink[v] == indices[v]:\n                scc = []\n                while True:\n                    w = stack.pop()\n                    on_stack[w] = False\n                    scc.append(w)\n                    if w == v:\n                        break\n                sccs.append(scc)\n\n        for v in range(n):\n            if indices[v] == -1:\n                strongconnect(v)\n\n        return sccs\n\n    sccs = find_sccs(n, edges)\n    result = [0] * n\n\n    for scc in sccs:\n        scc_values = [air_quality[v] for v in scc]\n        transformed = ifft(fft(scc_values)).real.round().astype(int)\n        for idx, v in enumerate(scc):\n            result[v] = transformed[idx]\n\n    return result\n", "test": "def check(candidate):\n    assert candidate(4, [(0, 1), (1, 2), (2, 0), (3, 3)], [100, 200, 300, 400]) == [200, 100, 300, 400]\n    assert candidate(3, [(0, 1)], [10, 20, 30]) == [10, 20, 30]\n    assert candidate(8, [(0, 1), (1, 2), (2, 3), (3, 0), (4, 5), (5, 6), (6, 4)], [10, 20, 30, 40, 50, 60, 70, 80]) == [20, 40, 10, 30, 60, 70, 50, 80]\n    assert candidate(5, [(0, 1), (1, 0), (2, 3), (3, 2), (4, 4)], [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert candidate(6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5), (5, 3)], [10, 20, 30, 40, 50, 60]) == [20, 10, 30, 50, 60, 40]\n", "entry_point": "storm_of_lagoon_quality", "extra_info": {"cover_story_words": ["supernatural storm", "hidden lagoon"], "topics": ["Strongly Connected Component", "Fast Fourier Transform"], "cleaned_prompt": "Implement a function that calculates the Fast Fourier Transform for air quality values inside each Strongly Connected Component of a directed graph, then returns the modified air quality values for each node after transforming.", "warnings": ["Solution failed correctness check.", "5, Misuse of Fourier Transform: The problem statement suggests the use of Fourier Transform and its inverse on lists representing air quality in SCCs, which mathematically will leave the lists unchanged (this is equivalent to an identity operation due to the inverse negating any change by the direct transform). This implies that the task is redundant in its main computation, questioning the necessity or correctness of using Fourier Transforms in this context.", "4, Unclear Problem Utility: The application of FFT followed by an inverse FFT within the same function effectively brings the values back to their original state, a process which is not typically useful unless accompanied by some form of transformation or filtering between the FFT and inverse FFT. The lack of such operations renders the problem's real-world application or utility unclear."]}}
