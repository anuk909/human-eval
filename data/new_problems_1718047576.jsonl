{"task_id": "hard/1", "prompt": "def find_first_recurring_char(s):\n    \"\"\"\n    Write a function that takes a string and returns the first recurring character in it. If there are no recurring characters, return None.\n\n    A recurring character is the one that appears more than once in the string.\n\n    For example:\n    - If input is 'acbbac', the output should be 'b' since 'b' is the first character that appears more than once.\n    - If input is 'abcdef', the output should be None since there are no characters appearing more than once.\n\n    Parameters:\n    - s (str): The input string.\n\n    Returns:\n    - (Optional[char]): The first recurring character or None if there is no recurring character.\n    \"\"\"\n", "canonical_solution": "def find_first_recurring_char(s):\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None", "test": "def check(candidate):\n    assert candidate('acbbac') == 'b'\n    assert candidate('abcdef') == None\n    assert candidate('') == None\n    assert candidate('abba') == 'b'\n    assert candidate('xyz xyz') == 'x'\n    assert candidate('hello world') == 'l'", "entry_point": "find_first_recurring_char"}
{"task_id": "hard/2", "prompt": "def longest_non_repeating_substring(s):\n    \"\"\"\n    Write a function that takes a string and returns the length of the longest substring without repeating characters.\n\n    For example:\n    - If input is 'abcabcbb', the output should be 3 ('abc' is the longest substring without repeating characters).\n    - If input is 'bbbbb', the output should be 1 (the longest substring without repeating characters could be any single 'b').\n    - If input is '', the output should be 0 (no substring).\n\n    Parameters:\n    - s (str): The input string.\n\n    Returns:\n    - int: The length of the longest substring without repeating characters.\n    \"\"\"\n", "canonical_solution": "def longest_non_repeating_substring(s):\n    max_len = 0\n    start = 0\n    seen = {}\n\n    for i, char in enumerate(s):\n        if char in seen and seen[char] >= start:\n            start = seen[char] + 1\n        else:\n            max_len = max(max_len, i - start + 1)\n\n        seen[char] = i\n\n    return max_len", "test": "def check(candidate):\n    assert candidate('abcabcbb') == 3\n    assert candidate('bbbbb') == 1\n    assert candidate('') == 0\n    assert candidate('pwwkew') == 3\n    assert candidate('abcdefghi') == 9\n    assert candidate('dvdf') == 3", "entry_point": "longest_non_repeating_substring"}
{"task_id": "hard/3", "prompt": "def count_matched_parentheses(expressions):\n    \"\"\"\n    Write a function that takes a list of string expressions and returns the number of expressions that have perfectly matched parentheses.\n\n    An expression has perfectly matched parentheses if:\n    - Each opening parenthesis '(' has a corresponding closing parenthesis ')'.\n    - Parentheses are properly nested and matched from inside to outside.\n\n    For example:\n    - If the input is ['(a+b)', 'a+(b+c)', '(a+b))', 'a+b)'], the output should be 2 because only '(a+b)' and 'a+(b+c)' have perfectly matched parentheses.\n\n    Parameters:\n    - expressions (List[str]): A list of string expressions.\n\n    Returns:\n    - int: Number of expressions with perfectly matched parentheses.\n    \"\"\"\n", "canonical_solution": "def count_matched_parentheses(expressions):\n    def is_matched(expr):\n        balance = 0\n        for char in expr:\n            if char == '(': balance += 1\n            elif char == ')': balance -= 1\n            if balance < 0: return False\n        return balance == 0\n\n    return sum(is_matched(expr) for expr in expressions)", "test": "def check(candidate):\n    assert candidate(['(a+b)', 'a+(b+c)', '(a+b))', 'a+b)']) == 2\n    assert candidate(['()', '()()', '((()))', '(()']) == 3\n    assert candidate(['', '(())', '(()()())']) == 3\n    assert candidate(['(a(b)c))', ')(', '((a))', '(()']) == 1\n    assert candidate(['((((((((((a))))))))))', '(b(c(d)e)f)g)']) == 1\n    assert candidate([]) == 0", "entry_point": "count_matched_parentheses"}
{"task_id": "hard/4", "prompt": "def unique_strings_in_order(strings):\n    \"\"\"\n    Write a function that takes a list of strings and returns a new list containing only the unique strings in the order they first appeared in the input list.\n\n    For example:\n    - If the input is ['apple', 'banana', 'apple', 'orange', 'banana', 'pear'], the output should be ['apple', 'banana', 'orange', 'pear'] because 'apple' and 'banana' are repeated and we consider them only once in the order they first appear.\n\n    Parameters:\n    - strings (List[str]): The input list of strings.\n\n    Returns:\n    - List[str]: A list of strings with duplicates removed, preserving the original order of first occurrences.\n    \"\"\"\n", "canonical_solution": "def unique_strings_in_order(strings):\n    seen = set()\n    unique = []\n    for string in strings:\n        if string not in seen:\n            unique.append(string)\n            seen.add(string)\n    return unique", "test": "def check(candidate):\n    assert candidate(['apple', 'banana', 'apple', 'orange', 'banana', 'pear']) == ['apple', 'banana', 'orange', 'pear']\n    assert candidate([]) == []\n    assert candidate(['orange', 'apple', 'apple', 'banana', 'orange']) == ['orange', 'apple', 'banana']\n    assert candidate(['hello', 'hello', 'hello']) == ['hello']\n    assert candidate(['unique']) == ['unique']\n    assert candidate(['string', 'string', 'string', 'string']) == ['string']", "entry_point": "unique_strings_in_order"}
{"task_id": "hard/5", "prompt": "def group_anagrams(words):\n    \"\"\"\n    Write a function that takes a list of words and returns a list of lists, where each inner list contains words that are anagrams of each other. Words are considered to be anagrams if they contain the same characters with the same frequency.\n\n    For example:\n    - Input: ['eat', 'tea', 'tan', 'ate', 'nat', 'bat']\n    - Output: [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] because 'eat', 'tea', 'ate' are anagrams; similarly, 'tan' and 'nat' are anagrams, and 'bat' is in its own group.\n\n    All output inner lists should be sorted alphabetically, and the outer list should also be sorted based on the first element of each inner list.\n\n    Parameters:\n    - words (List[str]): The input list of words.\n\n    Returns:\n    - List[List[str]]: A list with grouped anagrams.\n    \"\"\"\n", "canonical_solution": "def group_anagrams(words):\n    from collections import defaultdict\n    anagrams = defaultdict(list)\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        anagrams[sorted_word].append(word)\n    result = [sorted(group) for group in anagrams.values()]\n    return sorted(result, key=lambda x: x[0])", "test": "def check(candidate):\n    result = candidate(['eat', 'tea', 'tan', 'ate', 'nat', 'bat'])\n    expected = [['ate', 'eat', 'tea'], ['bat'], ['nat', 'tan']]\n    assert all(sorted(r) == sorted(e) for r, e in zip(result, expected)), 'Test case 1 failed'\n    result = candidate([''])\n    expected = [['']]\n    assert all(sorted(r) == sorted(e) for r, e in zip(result, expected)), 'Test case 2 failed'\n    result = candidate(['a'])\n    expected = [['a']]\n    assert all(sorted(r) == sorted(e) for r, e in zip(result, expected)), 'Test case 3 failed'\n    result = candidate(['abc', 'bca', 'cab', 'test', 'sett'])\n    expected = [['abc', 'bca', 'cab'], ['sett', 'test']]\n    assert all(sorted(r) == sorted(e) for r, e in zip(result, expected)), 'Test case 4 failed'\n    result = candidate([])\n    expected = []\n    assert all(sorted(r) == sorted(e) for r, e in zip(result, expected)), 'Test case 5 failed'", "entry_point": "group_anagrams"}
