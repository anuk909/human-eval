{"task_id": "hard/1", "prompt": "def haunted_houses(layout):\n    \"\"\"\n    Cosmic Carnival has a haunted section known as the Ghost Town. This enthralling and spooky attraction consists of several haunted houses positioned in a straight line but varying in height, similar to the bars on a histogram chart.\n    Last night, a supernatural storm swept through the area, leaving pockets of ethereal rainwater trapped between the haunted houses. Your challenge is to calculate the amount of rainwater trapped between these haunted houses using a two-pointer technique that optimizes space usage.\n\n    The layout of the haunted houses is represented by an array of integers, where each element represents the height of each haunted house.\n\n    Explanation for various cases:\n    - Given the layout [4, 2, 0, 3, 2, 5], the visual representation would be:\n      Height:          4   2   0   3   2   5\n      Water trapped:    W W W W\n      Here, the output should be 9 (units of water).\n    - An empty layout should return 0 as there are no houses to trap water.\n    - Layouts where all houses have the same height or there are only two houses would also return 0 as no water can be trapped.\n\n    Constraints:\n    - Each house height is a non-negative integer.\n    - Optimize the solution using constant space. This constraint is feasible given the use of a two-pointer technique, which operates directly on the input array without needing extra space for another structure.\n    \"\"\"\n", "canonical_solution": "    def haunted_houses(layout):\n        if not layout:\n            return 0\n\n        left, right = 0, len(layout) - 1\n        left_max, right_max = 0, 0\n        water_trapped = 0\n\n        while left <= right:\n            if layout[left] < layout[right]:\n                if layout[left] >= left_max:\n                    left_max = layout[left]\n                else:\n                    water_trapped += left_max - layout[left]\n                left += 1\n            else:\n                if layout[right] >= right_max:\n                    right_max = layout[right]\n                else:\n                    water_trapped += right_max - layout[right]\n                right -= 1\n        return water_trapped", "entry_point": "haunted_houses", "test": "def check(candidate):\n    assert candidate([]) == 0\n    assert candidate([4, 2, 0, 3, 2, 5]) == 9\n    assert candidate([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6\n    assert candidate([3, 0, 2, 0, 4]) == 7\n    assert candidate([0, 0, 0, 0, 0]) == 0\n    assert candidate([1, 7, 5, 9, 6, 7, 4, 3, 5, 9]) == 11\n    assert candidate([2, 2]) == 0\n    assert candidate([3]) == 0", "extra_info": {"cover_story_words": ["cosmic carnival", "ghost town"], "topics": ["Trapping Rain Water", "Union Find"], "cleaned_prompt": "Given a list representing the heights of houses in a straight line where each house can trap rainwater based on the heights of its neighboring houses, calculate the total amount of trapped rainwater.\n    Example:\n    For layout = [4, 2, 0, 3, 2, 5]\n        Trapped water would calculate to 9.\n\n    Note: The solution should employ an optimal use of space.", "warnings": ["Solution failed correctness check.", "4, inconsistent_requirements: The problem specifies using a two-pointer technique as a constraint but does not clearly explain whether using other methods would lead to disqualification or reduced points. This inconsistency might lead to confusion regarding the acceptable solutions."]}}
{"task_id": "hard/4", "prompt": "def magical_lightnings(grid, lightning_energy):\n    \"\"\"\n    In a magical land, various creatures are scattered across an N x M grid. Each cell of the grid contains either a creature (denoted by 'C') or is empty (denoted by '.')\n\n    A magical lightning strikes the grid, and its energy is represented as a non-negative integer. The lightning starts at the top row and can travel down row by row to the bottom. The path of the lightning can only move down to the directly adjacent cell or diagonally adjacent cell in the next row. The goal of the lightning is to have exactly zero energy by the time it reaches the last row.\n\n    Each time the lightning travels through a cell with a creature, the energy of the lightning decreases by one. To successfully exhaust the energy by the last row, it must reach the bottom with zero remaining energy.\n\n    Your task is to return True if there's a path for the lightning that allows it to exhaust all its energy according to the given grid and movement restrictions. Otherwise, return False.\n\n    Example:\n    Input: grid = [\n        ['.','.','C'],\n        ['C','.','.'],\n        ['.','.','.'],\n        ['.','C','.']\n    ], lightning_energy = 2\n    Output: True\n    Explanation: One viable path is (0, 2) -> (1, 0) -> (2, 1) -> (3, 1). Along this path, the lightning strikes two creatures and arrives at the bottom with zero energy.\n\n    Note:\n    - The grid will only contain '.' or 'C' characters.\n    - The lightning can move from position (r, c) to (r+1, c-1), (r+1, c), or (r+1, c+1) in the grid.\n    - If the lightning starts or moves outside the grid boundaries at any point, that path is considered invalid.\n\n    \"\"\"\n", "canonical_solution": "    def magical_lightnings(grid, lightning_energy):\n        R, C = len(grid), len(grid[0])\n\n        def backtrack(r, c, energy):\n            if r == R - 1:  # When at the last row\n                return energy == 0\n            if energy < 0:  # Energy exhausted too early\n                return False\n\n            # Calculate current energy\n            current_energy = energy - 1 if grid[r][c] == 'C' else energy\n\n            for dc in (-1, 0, 1):  # Three possible movements\n                nc = c + dc\n                if 0 <= nc < C:\n                    if backtrack(r+1, nc, current_energy):\n                        return True\n            return False\n\n        # Starting from each position in the first row\n        for c in range(C):\n            initial_energy = lightning_energy - 1 if grid[0][c] == 'C' else lightning_energy\n            if backtrack(0, c, initial_energy):\n                return True\n        return False", "entry_point": "magical_lightnings", "test": "def check(candidate):\n    assert candidate([['.','.','C'], ['C','.','.'], ['.','.','.'], ['.','C','.']], 2) == True\n    assert candidate([['.','.','C'], ['C','.','.'], ['.','.','.'], ['.','C','.']], 3) == False\n    assert candidate([['.', 'C'], ['C', '.'], ['.', 'C'], ['.', '.']], 1) == True\n    assert candidate([['.', 'C', '.'], ['C', '.', 'C'], ['.', '.', '.'], ['C', '.', '.']], 3) == False\n    assert candidate([['.'], ['C'], ['C'], ['.']], 1) == True", "extra_info": {"cover_story_words": ["magical creatures", "energetic lightning"], "topics": ["Monotonic Queue", "Backtracking"], "cleaned_prompt": "Write a function to determine if a path exists for a magical lightning which starts at the top of a grid and moves to the bottom such that it exhausts its initial energy as it travels through cells containing creatures ('C'). The lightning can move straight down or diagonally to adjacent cells in the next row. Each cell with a creature 'C' reduces the lightning's energy by 1. The function should return True if the lightning can exhaust its energy exactly upon reaching the bottom row.", "warnings": ["Solution failed correctness check.", "5, Unclear behavior handling: The specification does not clearly address cases where the lightning starts with zero energy or what if no creatures are present along the possible paths while the energy is greater than zero. The expected behavior in these cases should be clearly defined to avoid ambiguity.", "4, Edge cases not specified: The problem does not specify behavior for edge cases such as very small grids (e.g., 1x1 grid) or very large values for 'lightning_energy' relative to the number of 'C' in the grid. This can lead to different interpretations and potentially incorrect implementations."]}}
{"task_id": "hard/5", "prompt": "def find_visibility_ratios(skyline):\n    \"\"\"\n    In a futuristic city inhabited by intelligent animals, there's a popular game called 'Skyline Silhouettes'. Each player selects a sequence of buildings represented by their heights. The aim is to determine how much of the skyline is visible when viewed from left to right.\n\n    Each element in the 'skyline' list represents the height of a building. A building's visibility is determined by the portion of its height not blocked by any taller building to its immediate right.\n\n    The function should take a list of integers representing the heights of buildings and return a list of floating-point visibility ratios. Each ratio is determined as the visible height divided by the total building height.\n\n    For instance, with the skyline [3, 2, 4, 3, 5], the expected output is [0.66, 0.0, 0.5, 0.0, 1.0] calculated as follows:\n      - The first building's top 1 height is obscured by the second building. Visibility is 2/3 = 0.66.\n      - The second building is completely blocked by the subsequent taller third building. Ratio is 0/2 = 0.0.\n      - The third building has its upper 1 height section visible over the fourth building, equaling 2/4 = 0.5.\n      - The fourth building is fully eclipsed by the final building, so its ratio is 0/3 = 0.0.\n      - The fifth building has no obstructions, thus visibility is 5/5 = 1.0.\n\n    Additional constraints:\n      - Building heights range from 1 to 50.\n      - The skyline list can contain up to 10,000 buildings.\n\n    It is critical to consider cases like empty lists, lists with equal heights, and lists with steadily increasing or decreasing heights. Your solution must efficiently handle these edge cases, with a recommendation to utilize a Monotonic Stack for optimization in time complexity.\n    \"\"\"", "canonical_solution": "    def find_visibility_ratios(skyline):\n        n = len(skyline)\n        if n == 0:  # Handle edge case of empty input\n            return []\n        visibility_ratios = [0.0] * n\n        mono_stack = []\n\n        for i in range(n - 1, -1, -1):\n            current_height = skyline[i]\n            visible_height = current_height\n            while mono_stack and mono_stack[-1] <= current_height:\n                visible_height -= mono_stack.pop()\n            visibility_ratios[i] = visible_height / current_height if current_height != 0 else 0.0\n            mono_stack.append(current_height)\n\n        return visibility_ratios", "entry_point": "find_visibility_ratios", "test": "def check(candidate):\n    assert candidate([3, 2, 4, 3, 5]) == [0.66, 0.0, 0.5, 0.0, 1.0]\n    assert candidate([1, 1, 1, 1, 1]) == [0.0, 0.0, 0.0, 0.0, 1.0]\n    assert candidate([5, 3, 4, 2, 1]) == [1.0, 0.6, 0.5, 1.0, 1.0]\n    assert candidate([3, 3, 3, 3, 3]) == [0.0, 0.0, 0.0, 0.0, 1.0]\n    assert candidate([15]) == [1.0]\n    assert candidate([10, 20, 30, 40, 50]) == [0.0, 0.0, 0.0, 0.0, 1.0]\n    assert candidate([50, 40, 30, 20, 10]) == [1.0, 1.0, 1.0, 1.0, 1.0]\n    assert candidate([]) == []", "extra_info": {"cover_story_words": ["talking animals", "cyberpunk"], "topics": ["Monotonic Stack", "Probability and Statistics"], "cleaned_prompt": "Write a function `find_visibility_ratios` that calculates the visibility ratio for each building in a skyline from left to right. You are given a list of building heights and should return a list of visibility ratios where each ratio represents the visible height divided by the height of the building.\n\nExample Input: [3, 2, 4, 3, 5]\nExample Output: [0.66, 0.0, 0.5, 0.0, 1.0]", "warnings": ["Solution failed correctness check.", "5, Incorrect Example Calculation: The description for the example calculation in the problem statement does not match the building visibility description. For the skyline [3, 2, 4, 3, 5]: the first building should have its entire height visible, not \"its top 1 height obscured by the second building.\" Visibility should be 3/3 = 1.0, not 2/3 = 0.66, based on the major visibility rule specified in the description. The rule states the height not blocked by any taller building to its immediate right is considered visible\u2014this means entire shorter buildings before a taller building should be visible.", "5, Incorrect Output in Example Description: The provided explanation and output in the problem's example scenario contradict each other and the expected logic of the function. In the first building of the example [3, 2, 4, 3, 5], it should not be obscured by the second building because there's no taller building immediately after. So, the expected result should probably be [1.0, 0.0, 0.5, 0.0, 1.0] instead of [0.66, 0.0, 0.5, 0.0, 1.0]. The first value 0.66 seems to be incorrectly calculated and explained based on the rules given."]}}
{"task_id": "hard/2", "prompt": "def shortest_safe_path(grid, entrance, exit):\n    \"\"\"\n    On Patient Mountain lies the Mysterious Cave, renowned for its complex network of rooms connected by passages. Each room has various types of traps that can be enabled or disabled with levers. You are given a map of the cave as a grid, where each cell represents a room.\n\n    The map is a 2D list, with each room described by an integer in binary format. Each bit in the integer represents the status of a different trap (1 for active, 0 for inactive). Each room contains a lever that toggles the status of all traps in that specific room when used.\n\n    Your task is to determine the shortest path from the 'entrance' to the 'exit' using Dijkstra's Algorithm. The path must navigate through the rooms by toggling levers to deactivate traps and ensure safety while passing.\n\n    Given the grid, the coordinates of the entrance and exit, develop a function that computes the safest (shortest) path while minimizing the activation of traps. Each move from one cell to any horizontally or vertically neighboring cell counts as one step.\n\n    Note:\n    - The 'entrance' and 'exit' are given as tuples (row, col).\n    - It is guaranteed that the grid will have at least one row and one column.\n    - To traverse a room safely, all traps in that room must be deactivated.\n\n    Example:\n    If the grid is [[0b111, 0b011], [0b000, 0b101]], the entrance is (0,0) and the exit is (1,1), the function should return 'No path'.\n\n    \"\"\"", "canonical_solution": "def shortest_safe_path(grid, entrance, exit):\n    import heapq\n\n    def is_safe(room):\n        return room == 0\n\n    def toggle(room):\n        return room ^ (1 << (len(bin(room)) - 2 - 1))\n\n    rows, cols = len(grid), len(grid[0])\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    pq = [(0, entrance[0], entrance[1], grid[entrance[0]][entrance[1]])]\n    visited = set()\n\n    while pq:\n        steps, r, c, state = heapq.heappop(pq)\n        if (r, c) == exit and is_safe(state):\n            return steps\n        visited.add((r, c, state))\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc, state) not in visited:\n                new_state = toggle(grid[nr][nc])\n                heapq.heappush(pq, (steps + 1, nr, nc, new_state))\n    return 'No path'", "entry_point": "shortest_safe_path", "test": "def check(candidate):\n    assert candidate([[0b111, 0b011], [0b000, 0b101]], (0,0), (1,1)) == 'No path'\n    assert candidate([[0b000, 0b000], [0b000, 0b000]], (0,0), (1,1)) == 2\n    assert candidate([[0b001, 0b100], [0b000, 0b101]], (0,0), (1,1)) == 'No path'\n    assert candidate([[0b000, 0b011], [0b000, 0b010]], (0,0), (1,1)) == 3\n    assert candidate([[0b000, 0b000, 0b000], [0b010, 0b010, 0b000], [0b000, 0b000, 0b000]], (0,0), (2,2)) == 4", "extra_info": {"cover_story_words": ["patient mountain", "mysterious cave"], "topics": ["Dijkstra's Algorithm", "Bitmask"], "cleaned_prompt": "Write a function that finds the shortest safe path from an entrance to an exit in a cave represented as a grid. Each cell in the grid contains an integer where each bit of the integer represents a different trap. The traps can be toggled on or off. Only move through rooms where all traps are deactivated. Use Dijkstra's Algorithm for finding the shortest path.", "warnings": ["Solution failed correctness check.", "5, Logic Flaw in Toggle Function: The function to toggle the traps in a room 'toggle(room)' is incorrectly designed. It uses logic to only toggle a specific bit determined by the length of the binary representation of the room. This should not focus on just the most significant bit, rather, it should toggle all bits since any could be active. This is a fundamental error and makes the solution logic incorrect for toggling trap statuses.", "4, Algorithmic Inefficiency: The program neglects efficient validation of safe traversals over altered trap states between rooms. Each room's toggling state is dependent on its lever alone, but the solution's use of Dijkstra's algorithm could be problematically inefficient because each step recalculates trap toggling without memorization or an effective pruning strategy for unsafe states \u2014 potentially resulting in high computational complexities with larger grids."]}}
{"task_id": "hard/3", "prompt": "def treasure_map_minimization(treasure_map):\n    \"\"\"\n    You are a software consultant for a famous pirate, Captain Hook, who has a treasure map laid out as a grid, where each cell signifies the quantity of gemstones at that location. Due to a curse, the number of gemstones can fluctuate, necessitating updates to the map.\n\n    Implement a system to efficiently query the minimum number of gemstones in any rectangular subset of the map and accommodate dynamic changes in gemstone counts.\n\n    Implement the following functions for this task:\n    - `initialize(treasure_map)`: Initializes and builds the data structures from the map.\n    - `update(x, y, value)`: Modifies the gemstone count at (x, y) to 'value'.\n    - `query(x1, y1, x2, y2)`: Returns the minimum number of gemstones in the region defined from (x1, y1) to (x2, y2).\n\n    For optimal performance, utilize a 2D segment tree with balancing techniques derived from Red-Black Trees. The grid is 0-indexed.\n    \"\"\"", "canonical_solution": "\n    class SegmentTree2D:\n        def __init__(self, grid):\n            self.rows = len(grid)\n            self.cols = len(grid[0]) if self.rows > 0 else 0\n            self.tree = [[0] * (4 * self.cols) for _ in range(4 * self.rows)]\n            self.build_y(0, 0, self.rows - 1, grid)\n\n        def build_y(self, node_x, start_x, end_x, grid):\n            if start_x == end_x:\n                self.build_x(node_x, 0, 0, self.cols - 1, start_x, grid)\n            else:\n                mid_x = (start_x + end_x) // 2\n                self.build_y(2 * node_x + 1, start_x, mid_x, grid)\n                self.build_y(2 * node_x + 2, mid_x + 1, end_x, grid)\n                for i in range(self.cols * 4):\n                    self.tree[node_x][i] = min(self.tree[2 * node_x + 1][i], self.tree[2 * node_x + 2][i])\n\n        def build_x(self, node_x, node_y, start_y, end_y, row, grid):\n            if start_y == end_y:\n                self.tree[node_x][node_y] = grid[row][start_y]\n            else:\n                mid_y = (start_y + end_y) // 2\n                self.build_x(node_x, 2 * node_y + 1, start_y, mid_y, row, grid)\n                self.build_x(node_x, 2 * node_y + 2, mid_y + 1, end_y, row, grid)\n                self.tree[node_x][node_y] = min(self.tree[node_x][2 * node_y + 1], self.tree[node_x][2 * node_y + 2])\n\n        def update(self, x, y, value):\n            self._update_y(0, 0, self.rows - 1, x, y, value)\n\n        def _update_y(self, node_x, start_x, end_x, x, y, value):\n            if start_x == end_x:\n                self._update_x(node_x, 0, 0, self.cols - 1, start_x, y, value)\n            else:\n                mid_x = (start_x + end_x) // 2\n                if x <= mid_x:\n                    self._update_y(2 * node_x + 1, start_x, mid_x, x, y, value)\n                else:\n                    self._update_y(2 * node_x + 2, mid_x + 1, end_x, x, y, value)\n            self.tree[node_x] = min(self.tree[2 * node_x + 1], self.tree[2 * node_x + 2])\n\n        def _update_x(self, node_x, node_y, start_y, end_y, x, y, value):\n            if start_y == end_y:\n                self.tree[node_x][node_y] = value\n            else:\n                mid_y = (start_y + end_y) // 2\n                if y <= mid_y:\n                    self._update_x(node_x, 2 * node_y + 1, start_y, mid_y, x, y, value)\n                else:\n                    self._update_x(node_x, 2 * node_y + 2, mid_y + 1, end_y, x, y, value)\n                self.tree[node_x][node_y] = min(self.tree[node_x][2 * node_y + 1], self.tree[node_x][2 * node_y + 2])\n\n        def query(self, x1, y1, x2, y2):\n            return self._query_y(0, 0, self.rows - 1, x1, y1, x2, y2)\n\n        def _query_y(self, node_x, start_x, end_x, x1, y1, x2, y2):\n            if x1 > end_x || x2 < start_x:\n                return float('inf')\n            if x1 <= start_x && x2 >= end_x:\n                return self._query_x(node_x, 0, 0, self.cols - 1, y1, y2)\n            mid_x = (start_x + end_x) // 2\n            left_query = self._query_y(2 * node_x + 1, start_x, mid_x, x1, y1, x2, y2)\n            right_query = self._query_y(2 * node_x + 2, mid_x + 1, end_x, x1, y1, x2, y2)\n            return min(left_query, right_query)\n\n        def _query_x(self, node_x, node_y, start_y, end_y, y1, y2):\n            if y1 > end_y || y2 < start_y:\n                return float('inf')\n            if y1 <= start_y && y2 >= end_y:\n                return self.tree[node_x][node_y]\n            mid_y = (start_y + end_y) // 2\n            left_query = self._query_x(2 * node_x + 1, start_y, mid_y, y1, y2)\n            right_query = self._query_x(2 * node_x + 2, mid_y + 1, end_y, y1, y2)\n            return min(left_query, right_query)\n    \n    # Entry functions:\n    def initialize(treasure_map):\n        return SegmentTree2D(treasure_map)\n\n    def update(st, x, y, value):\n        st.update(x, y, value)\n\n    def query(st, x1, y1, x2, y2):\n        return st.query(x1, y1, x2, y2)", "entry_point": "initialize, update, query", "test": "\ndef check(candidate):\n    treasure_map = [[3, 2, 1, 4], [5, 1, 2, 3], [9, 8, 7, 6], [4, 5, 2, 3]]\n    st = candidate.initialize(treasure_map)\n    assert candidate.query(st, 0, 0, 3, 3) == 1, 'Test case 1 failed'\n    assert candidate.query(st, 1, 1, 2, 2) == 2, 'Test case 2 failed'\n    assert candidate.query(st, 0, 1, 1, 2) == 1, 'Test case 3 failed'\n    candidate.update(st, 2, 2, 0)\n    assert candidate.query(st, 0, 0, 3, 3) == 0, 'Test case 4 failed'\n    assert candidate.query(st, 2, 2, 2, 2) == 0, 'Test case 5 failed'\n\n", "extra_info": {"cover_story_words": ["pirate ship", "gemstone mine"], "topics": ["Red-Black Tree", "Recursion"], "cleaned_prompt": "Create functions to manage and query the minimum values in a dynamically updatable 2D grid. The functions should handle initializing the grid, updating specific cell values, and querying minimum values in rectangular subregions. The solution should use 2D segment trees or range trees, potentially using Red-Black trees for balancing, to ensure efficient operations.", "warnings": ["Solution failed correctness check.", "5, Lacking problem constraints: The problem fails to specify the constraints on the size of the treasure map (grid dimensions), the range of gemstone values, and the number of operations (queries and updates). Without these constraints, it is challenging to evaluate the efficiency and correctness requirements of the implementation.", "4, Incomplete function specifications: The prompt mentions using a 2D segment tree with balancing techniques from Red-Black Trees but does not provide clear instructions or requirements on how to integrate these balancing techniques into the segment tree structure. This lack of detailed methodological guidance can lead to ambiguous implementations.", "4, Inconsistent function signature: The function prompts (initialize, update, query) imply that there should be a global object or state maintained across these functions. However, the problem statement does not clearly specify whether these functions should handle such state internally or if the state should be passed explicitly between functions, leading to possible confusion in function API design."]}}
