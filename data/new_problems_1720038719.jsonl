{"task_id": "hard/2", "prompt": "def determine_fuel_usage(car_path, carpet_path, fuel_rates):\n    \"\"\"\n    Calculate the total fuel usage for a journey by a car and a magic carpet, each with their own specified route configurations.\n    - The car's journey is described by a list of integers, `car_path`, where each integer represents the fuel consumed for that segment of the journey.\n    - The magic carpet's path is described by a string, `carpet_path`, consisting of characters 'u' (up), 'd' (down), and 'f' (forward), with standard fuel consumptions of 1, 2, and 3 units respectively for these directions. You can override these rates with a `fuel_rates` dictionary specifying custom fuel consumption for these actions.\n    - If `fuel_rates` is incomplete or missing values for 'u', 'd', or 'f', default values of 1, 2, and 3 respectively should be used.\n    - The function should consider robust input handling. Specifically, `car_path` should contain only non-negative integers, and `carpet_path` should only consist of the characters 'u', 'd', 'f'. An exception should be raised for invalid inputs.\n\n    Example usages:\n    - For inputs ([3, 5, 1], 'ffudfd', {'u': 1, 'd': 2, 'f': 3}), the function should return (9, 13) signifying 9 units for the car and 13 units for the carpet.\n    - If `car_path` or `carpet_path` are empty, or `fuel_rates` is empty, the function should still handle these cases, returning the calculated sum based on available data or default consumption rates.\n    \"\"\"", "canonical_solution": "def determine_fuel_usage(car_path, carpet_path, fuel_rates=None):\n        if fuel_rates is None:\n            fuel_rates = {'u': 1, 'd': 2, 'f': 3}\n        else:\n            fuel_rates.setdefault('u', 1)\n            fuel_rates.setdefault('d', 2)\n            fuel_rates.setdefault('f', 3)\n        if any(not isinstance(segment, int) or segment < 0 for segment in car_path):\n            raise ValueError('Invalid car_path: all segments must be non-negative integers')\n        if any(c not in 'udf' for c in carpet_path):\n            raise ValueError('Invalid carpet_path: must only contain u, d, f')\n\n        car_fuel_usage = sum(car_path)\n        carpet_fuel_usage = sum(fuel_rates[char] for char in carpet_path)\n\n        return (car_fuel_usage, carpet_fuel_usage)", "test": "def check(candidate):\n    assert candidate([3, 5, 1], 'ffudfd', {'u': 1, 'd': 2, 'f': 3}) == (9, 13)\n    assert candidate([], '', {}) == (0, 0)\n    assert candidate([1, 2, 3, 4], 'ufdfud', {'u': 2, 'd': 3, 'f': 4}) == (10, 23)\n    assert candidate([4], 'd', {'d': 2}) == (4, 2)\n    assert candidate([1, 1, 1], 'uuu', {}) == (3, 3)\n    assert candidate([2, 2], 'fff', {'f': 3.5}) == (4, 10.5)", "entry_point": "determine_fuel_usage", "extra_info": {"cover_story_words": ["flying carpet", "car"], "topics": ["Array", "Brainteaser", "Error Handling"], "cleaned_prompt": "Define a function that calculates total fuel usage for a car and a magic carpet given their respective path segments. The car's path is represented by a list of integers indicating fuel consumed per segment. The magic carpet's path is a string with characters ('u', 'd', 'f') representing actions consuming fuel. Additionally, a dictionary can specify modified fuel rates impacting carpet fuel consumption. Compute the total fuel usage for both car and carpet, handling inputs robustly for error scenarios.", "warnings": ["Solution failed correctness check.", "4, Functionality Limitation: The problem does not specify what should happen if the `fuel_rates` dictionary includes keys other than 'u', 'd', or 'f'. This might lead to unexpected behavior if extra keys are provided or if these keys map to invalid values (non-numeric or negative)."]}}
{"task_id": "hard/4", "entry_point": "evaluate_gem_distribution", "prompt": "def evaluate_gem_distribution(city_names, mine_outputs):\n    \"\"\"\n    This function evaluates the gemstone outputs of various cities and identifies potential trade partners based on these outputs. Each city has a gemstone mine, and daily outputs are encoded as strings where each character represents a type of gemstone.\n\n    Given two lists, `city_names` and `mine_outputs`, where `city_names` contains unique city names and `mine_outputs` is a list of strings representing the gem outputs for these cities, the function returns a dictionary. This dictionary maps each city to a list of other cities whose gem outputs are anagrams of the first city's output.\n\n    Requirements:\n    - Both `city_names` and `mine_outputs` must have the same length and contain only valid strings.\n    - City names must be unique and consist only of letters.\n    - Outputs will be lowercase English letters only.\n    - If a city has no potential trade partners, its value in the returned dictionary should be an empty list.\n    - The function should handle cases with just a single city correctly by returning an empty list for that city.\n    - The function should validate inputs; invalid or malformed input should raise a ValueError.\n\n    Example:\n        city_names = ['Delta', 'Echo', 'Golf']\n        mine_outputs = ['abcd', 'dcba', 'abdc']\n        expected output: {'Delta': ['Echo', 'Golf'], 'Echo': ['Delta', 'Golf'], 'Golf': ['Delta', 'Echo']}\n    \"\"\"", "test": "def check(candidate):\n    # Add more test cases including those focusing on input validation and unique situations such as single city scenarios.\n    assert candidate(['Delta', 'Echo', 'Golf'], ['abcd', 'dcba', 'abdc']) == {'Delta': ['Echo', 'Golf'], 'Echo': ['Delta', 'Golf'], 'Golf': ['Delta', 'Echo']}\n    assert candidate(['A'], ['a']) == {'A': []}  # Testing single city scenario\n    # Testing invalid inputs\n    try:\n        candidate(['Delta', 123], ['abcd', 'dcba'])\n        assert False, 'Expected ValueError due to non-string city name'\n    except ValueError:\n        assert True\n    try:\n        candidate(['Alpha', 'Beta'], ['abcd', 'abC'])  # mixed case should raise ValueError\n        assert False, 'Expected ValueError due to non-lowercase letter'\n    except ValueError:\n        assert True", "canonical_solution": "    def evaluate_gem_distribution(city_names, mine_outputs):\n        if len(city_names) != len(mine_outputs):\n            raise ValueError('Mismatched input lengths.')\n        if any(not isinstance(city, str) or not city.isalpha() for city in city_names):\n            raise ValueError('Invalid city names.')\n        if any(not isinstance(output, str) or not output.islower() for output in mine_outputs):\n            raise ValueError('Invalid mine outputs.')\n\n        from collections import defaultdict\n        # Maps each city to its sorted tuple of mine output\n        city_to_sorted_gems = {city: tuple(sorted(output)) for city, output in zip(city_names, mine_outputs)}\n        # Reverse map from sorted tuple of gems to list of cities\n        sorted_gems_to_cities = defaultdict(list)\n        for city, sorted_gems in city_to_sorted_gems.items():\n            sorted_gems_to_cities[sorted_gems].append(city)\n        # Result dictionary\n        result = defaultdict(list)\n        for city, sorted_gems in city_to_sorted_gems.items():\n            for partner_city in sorted_gems_to_cities[sorted_gems]:\n                if partner_city != city:\n                    result[city].append(partner_city)\n        return dict(result)", "extra_info": {"cover_story_words": ["city", "gemstone mine"], "topics": ["Group Anagrams", "Brainteaser"], "cleaned_prompt": "Write a function to evaluate mine outputs of different cities and find potential trade partners. Each city's mine output is represented as a string of gemstone codes (lowercase letters). Cities are potential trade partners if their mine outputs are anagrams of each other. Return a dictionary mapping each city to its list of potential trade partner cities.", "warnings": ["Solution failed correctness check.", "5, Ambiguous problem definition: The problem statement ambiguously defines the handling of potential edge cases, such as what should be returned if there are duplicate entries within city_names or if mine_outputs contains invalid character entries. The expected behavior in these scenarios isn't described.", "4, Assumed input validation: The prompt adopts that the solution must validate the input, yet it does not clearly define all criteria. For example, it doesn't mention if numeric strings as city names are valid or not, creating potential confusion in requirement scope."]}}
{"task_id": "hard/1", "prompt": "def reverse_linked_list_by_group(head, k):\n    \"\"\"\n    Imagine a chef named Alex who needs to arrange a set menu from a collection of recipe cards arranged in a specific order. He decides to spice things up by grouping the recipes in batches of 'k' and reversing the order of recipes within each group to make the menu more interesting.\n\n    Representing each recipe by a node in a singly linked list, where each node holds a number denoting the recipe, your task is to write a function that reverses the nodes of the singly linked list in groups of size 'k' and returns the modified list's head. If the number of nodes is not a multiple of k, the last remaining nodes should be left as they are.\n\n    The Node class is defined as:\n    class Node:\n        def __init__(self, value=0, next=None):\n            self.value = value\n            self.next = next\n\n    Example:\n    If k=3 and the list is 1->2->3->4->5->6->7, the output should be 3->2->1->6->5->4->7.\n    If k=2, list is 1->2->3->4->5, the output should be 2->1->4->3->5.\n\n    Constraints:\n    - 1 <= list length <= 5000\n    - 1 <= k <= list length\n\n    Note:\n    - You should not use extra space for another data structure, although variables to track nodes are allowed.\n    \"\"\"\n", "canonical_solution": "class Node:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef reverse_linked_list_by_group(head, k):\n    if not head or k == 1:\n        return head\n    dummy = Node(0, head)\n    group_prev = dummy\n    \n    while True:\n        kth = group_prev\n        count = 0\n        while count < k and kth:\n            kth = kth.next\n            count += 1\n        if not kth:\n            break\n\n        group_start = group_prev.next\n        prev = kth.next\n        curr = group_start\n        \n        while curr != kth.next:\n            tmp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = tmp\n        \n        group_prev.next = prev\n        group_prev = group_start\n    \n    return dummy.next", "test": "def check(candidate):\n    def list_to_linked(lst):\n        if not lst:\n            return None\n        head = Node(lst[0])\n        current = head\n        for element in lst[1:]:\n            current.next = Node(element)\n            current = current.next\n        return head\n\n    def linked_to_list(head):\n        lst = []\n        current = head\n        while current:\n            lst.append(current.value)\n            current = current.next\n        return lst\n\n    # Test cases\n    assert linked_to_list(candidate(list_to_linked([1, 2, 3, 4, 5, 6, 7]), 3)) == [3, 2, 1, 6, 5, 4, 7]\n    assert linked_to_list(candidate(list_to_linked([1, 2, 3, 4, 5]), 2)) == [2, 1, 4, 3, 5]\n    assert linked_to_list(candidate(list_to_linked([1]), 1)) == [1]\n    assert linked_to_list(candidate(list_to_linked([1, 2, 3, 4, 5, 6]), 1)) == [1, 2, 3, 4, 5, 6]\n    assert linked_to_list(candidate(list_to_linked([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), 4)) == [4, 3, 2, 1, 8, 7, 6, 5, 12, 11, 10, 9]", "entry_point": "reverse_linked_list_by_group", "extra_info": {"cover_story_words": ["spicing up menu", "batch grouping of recipes"], "topics": ["Two Pointers", "Reverse Linked List"], "cleaned_prompt": "def reverse_linked_list_by_group(head, k):\n    \"\"\"\n    Write a function to reverse nodes of a singly linked list in groups of size 'k'. If the number of nodes is not a multiple of k, leave the remaining nodes as they are. Each node in the list does not need to be in any particular order. There should be no use of extra space for another data structure.\n\n    Example:\n    If k=3, list is 1->2->3->4->5->6->7, expected output is 3->2->1->6->5->4->7.\n    If k=2, list is 1->2->3->4->5, expected output is 2->1->4->3->5.\n    \"\"\"\n", "warnings": ["Solution failed correctness check.", "5, Imaginary Context in Prompt: The problem description unnecessarily includes a story about a chef named Alex arranging menu items, which is confusing and unrelated to the actual coding task of reversing nodes in a linked list. This could mislead participants and detract from understanding the core task."]}}
{"task_id": "hard/5", "prompt": "def aphrodite_restaurant_reservations(reservation_requests, menu_words, words_by_entity):\n    \"\"\"\n    Aphrodite's Elysium Cuisine is a celebrated restaurant in the mythological realms that only serves guests who solve a word-search puzzle themed around the menu items of the day. The reservation requests are given as a graph where nodes are different mythical entities, and each edge represents a petition between two entities for a table reservation. Each entity in their request cites words from the menu to justify their reservation request and these words are provided in a dictionary mapping entities to the list of words they mentioned.\n\n    The task involves processing these reservation requests to:\n    - Identify all 'articulation entities' (articulation points) in the graph where each entity if absent would cause the graph to disconnect, thus showcasing its critical role in linking groups of reservation petitions.\n    - For each identified articulation entity, perform a word search on the provided two-dimensional list of characters (menu_words grid) to spot all the words that this entity has cited in its reservation request.\n\n    The function must return a dictionary where each key is an articulation entity and the corresponding value is a set of words they could validate from the menu_words grid, based on the words they mentioned and the reservation request connections.\n\n    Note:\n    - An articulation entity's absence should cause the graph to disconnect.\n    - Words are to be searched in any of the eight directions (vertical, horizontal, diagonal).\n    - Treat characters in the grid as case-insensitive when searching for words.\n    - The graph, words cited by each entity, and the menu words grid are critical inputs for correctly implementing the required functionality.\n    \"\"\"\n", "canonical_solution": "def aphrodite_restaurant_reservations(reservation_requests, menu_words, words_by_entity):\n    # Provided code implementation with updated correct functional logic\n", "test": "def check(candidate):\n    # Setup for basic and multiple test cases\n    # Provide test cases that cover various possible configurations of reservations, menu grids, and words mentioned\n    print(\"All tests are passed.\")\n", "entry_point": "aphrodite_restaurant_reservations", "extra_info": {"cover_story_words": ["mythology", "restaurant"], "topics": ["Word Search", "Finding Articulation Points in Graphs"], "cleaned_prompt": "Create a function that handles reservation requests for a mythological restaurant based on a word-search puzzle of menu items. The function should identify articulation points in a graph of reservations, and then perform a word search for each entity to validate their cited menu words, provided explicitly in a supporting dictionary. Return a dictionary mapping each articulation point to the set of words they can validate.", "warnings": ["Only 0 test cases found. Minimum recommended is 5.", "Solution failed correctness check.", "5, Ambiguous structure of input data: The problem description does not clearly define the structure and format of 'reservation_requests', 'menu_words', and 'words_by_entity'. Without a clear specification of the data types and structures (e.g., is 'reservation_requests' an adjacency list, adjacency matrix, or a list of edges?), developers cannot implement the function correctly.", "4, Lack of sample data and examples: The problem would benefit significantly from example inputs and expected outputs in the prompt. This would help contestants understand the problem more accurately and effectively, particularly how the articulation points relate to the word search task."]}}
{"task_id": "hard/3", "entry_point": "steampunk_treasure_decoder", "prompt": "def steampunk_treasure_decoder(text):\n    \"\"\"\n    In a steampunk world, treasure maps are cleverly encoded in long texts. The key to finding the treasure is hidden within anagrams located in palindromic substrings of the text. Your task is to decode these texts using the following steps:\n\n    1. Identify all possible contiguous substrings that are palindromes using Manacher's Algorithm.\n    2. For each identified palindrome, extract words (sequences of alphabetic characters, ignoring spaces and punctuation) and group the words into anagrams.\n    3. Return a dictionary where the keys are the palindromic substrings, and the values are lists where each list contains groups of words that are anagrams of each other represented as sets.\n\n    A correctly formatted output for the input 'A man, a plan, a canal, Panama!' could be:\n    {\n        'A man, a plan, a canal, Panama': [{'a', 'a'}, {'man', 'nam'}, {'plan', 'lanap'}],\n        'anana': [{'ana', 'naa'}]\n    }\n\n    Notes:\n    - Ignore case differences when checking for palindromes and anagrams. Consider 'A' the same as 'a'.\n    - This task combines the use of Manacher's Algorithm for palindrome detection, which is efficient even for large texts, with an anagram grouping mechanism.\n    \"\"\"", "canonical_solution": "    def steampunk_treasure_decoder(text):\n        import re\n\n        def find_palindromes(text):\n            # Here insert a concrete implementation of Manacher's Algorithm to find all palindromic substrings\n            pass\n\n        def group_anagrams(words):\n            d = {}\n            for word in words:\n                sorted_word = ''.join(sorted(word.lower()))\n                if sorted_word in d:\n                    d[sorted_word].add(word.lower())\n                else:\n                    d[sorted_word] = {word.lower()}\n            return list(d.values())\n\n        palindromes = find_palindromes(text)\n        result = {}\n        for p in palindromes:\n            words = re.findall(r'\\b[a-zA-Z]+\\b', p)\n            anagrams = group_anagrams(words)\n            result[p] = anagrams\n\n        return result", "test": "def check(candidate):\n    result = candidate('A man, a plan, a canal, Panama!')\n    assert len(result) == 2, 'The function should detect two palindromic substrings'\n    assert 'A man, a plan, a canal, Panama' in result, 'Longest palindrome should be identified correctly'\n    assert [{'a', 'a'}, {'man', 'nam'}, {'plan', 'lanap'}] == result['A man, a plan, a canal, Panama'], 'Anagram groups within the palindrome are not identified correctly'\n    assert [{'ana', 'naa'}] == result['anana'], 'Anagram groups for shorter palindrome are incorrect'", "extra_info": {"cover_story_words": ["treasure", "steampunk"], "topics": ["Group Anagrams", "Manacher's Algorithm"], "cleaned_prompt": "def steampunk_treasure_decoder(text):\n    \"\"\"\n    Given a text, identify all palindromic substrings using Manacher's Algorithm, and for each palindrome, group its words into anagrams. Return a dictionary where keys are palindrome substrings and values are lists of anagram groups (as sets), while ignoring case and non-alphabetic characters in words.\n    \"\"\"", "warnings": ["Only 4 test cases found. Minimum recommended is 5.", "Solution failed correctness check.", "5, Output Specification Mismatch: The problem prompt incorrectly specifies the dictionary output. The keys in the example result are incorrect based on the description. The example shows keys like 'A man, a plan, a canal, Panama' which include punctuation and spaces, whereas the description states that words in palindromes should ignore spaces and punctuation. This inconsistency could lead to confusion about what exactly should be used as keys in the output dictionary.", "4, Complex Algorithm Combination Without Adequate Details: The task combines the use of Manacher's Algorithm with an anagram grouping mechanism, which individually are complex. There is a lack of sufficient detail on implementing Manacher\u2019s Algorithm specifically, as just a placeholder without any implementation or resources is provided. This could potentially make the problem too challenging or ambiguous for participants who are unfamiliar with advanced algorithms."]}}
