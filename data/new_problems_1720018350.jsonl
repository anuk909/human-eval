{"task_id": "hard/2", "prompt": "def energy_vortex_intervals(crystals, energy_intervals):\n    \"\"\"\n    In the mystical world of Gorgania, you are a magician trying to manipulate energy vortices using your crystal ball. Each crystal has a unique energy signature represented by a time interval during which it can be harnessed to manipulate a vortex.\n\n    You are given two lists:\n    - `crystals`: where each crystal is represented as a tuple (start, end) indicating the interval in which it can manipulate energy.\n    - `energy_intervals`: where each interval is a critical phase where energy manipulation is necessary to maintain the stability of a vortex.\n\n    Your task is to determine the minimal number of crystals needed to cover all the energy intervals. If an energy interval cannot be completely covered by the available crystals, return -1.\n\n    Each interval (start, end) is inclusive, meaning it goes from 'start' to 'end' both included. Assume that all values are non-negative integers and that the intervals are sorted by their start times. Merge overlapping intervals where necessary.\n\n    Note:\n    - Implement this using a combination of dynamic programming (to determine the minimal number of crystals for each interval) and a greedy approach (to decide how to best cover an interval with available crystals).\n    - An efficient solution would utilize an approach similar to interval scheduling optimization, where you process the least ending intervals first for a better greedy selection.\n    \"\"\"", "canonical_solution": "def energy_vortex_intervals(crystals, energy_intervals):\n        if not energy_intervals:\n            return 0\n        covered = [-1] * (energy_intervals[-1][1] + 1)\n        for start, end in crystals:\n            for i in range(start, end + 1):\n                covered[i] = max(covered[i], end)\n\n        dp = [float('inf')] * (energy_intervals[-1][1] + 2)\n        dp[0] = 0\n        for i in range(1, len(dp)):\n            dp[i] = dp[i - 1]\n            if covered[i - 1] != -1:\n                dp[i] = min(dp[i], dp[i - 1], 1 + dp[max(0, covered[i - 1] + 1)])\n\n        result = max(dp[energy_intervals[j][1] + 1] for j in range(len(energy_intervals)))\n        return -1 if result == float('inf') else result", "test": "def check(candidate):\n    assert candidate([(1, 3), (4, 10), (8, 12)], [(0, 5), (6, 10)]) == 2\n    assert candidate([(1, 5), (4, 8), (10, 15)], [(0, 3), (6, 11)]) == 3\n    assert candidate([(1, 3), (6, 9)], [(0, 4), (5, 10)]) == -1\n    assert candidate([(0, 3), (2, 8), (9, 10)], [(0, 5), (6, 10)]) == 2\n    assert candidate([], [(0, 2)]) == -1", "entry_point": "energy_vortex_intervals", "extra_info": {"cover_story_words": ["energy vortex", "crystal ball"], "topics": ["Insert Interval", "Topological Sort", "Dynamic Programming"], "cleaned_prompt": "Define a function that, given lists of available crystals' time intervals and required energy manipulations intervals, determines the minimal number of crystals needed to entirely cover all the energy intervals. If at least one interval cannot be covered, return -1.", "warnings": ["Solution failed correctness check.", "5, Unclear Problem Statement: The problem statement's combination of requirements for dynamic programming and greedy algorithm is confusing and contradictory. It suggests using dynamic programming for determining the minimal number of crystals for each interval and a greedy approach simultaneously, which might not be straightforward or even feasible for the described problem.", "4, Inefficient Canonical Solution: The suggested canonical solution involves a significant amount of iteration over possible ranges, leading to potential inefficiency. For a significant input size, this could lead to performance problems, and it might not scale well.", "5, Complexity and Feasibility: The task requires merging overlapping intervals and covering them with possibly overlapping ranges from another list, which is inherently complex. The statement requires a specific approach (dynamic programming combined with greedy) without clear justification of why this combination is necessary or optimal, which could mislead readers or result implementational errors."]}}
{"task_id": "hard/5", "prompt": "def submarine_magic(numbers):\n    \"\"\"\n    Imagine you're in a submarine using a magic wand that alters depths recorded in binary format. For the list of depths (integers), the magic wand makes permutations based on binary representations of numbers.\n\n    The depths must first be sorted in ascending order using a radix sort algorithm based on their binary forms without considering the actual integer values. Then, for each depth, output the sum of depths of all unique subsets that can be formed with the sorted list (excluding the empty set).\n\n    However, there's an additional twist. The wand can only consider subsets that have an even number of digits in their binary representation (including the leading zeros consistent with the maximum length among the initial depths).\n\n    Example:\n    For input [3, 1], the binary forms are ['11', '01'], sorted they are ['01', '11']. The valid subsets with even digits are ['01', '11']. Hence, the sums are [1, 3] and the final output is 4.\n\n    Note:\n    - Ensure radix sorting algorithm is binary-based.\n    - Include all subsets with even binary digit counts before summing.\n    - An input list of depths is given as an integer list.\n    \"\"\"\n", "canonical_solution": "def submarine_magic(numbers):\n    def to_binary(x):\n        return format(x, 'b')\n\n    def radix_sort_binary(nums):\n        max_len = len(format(max(nums), 'b'))\n        for i in range(max_len):\n            bucket_zero = []\n            bucket_one = []\n            for num in nums:\n                if num & (1 << i):\n                    bucket_one.append(num)\n                else:\n                    bucket_zero.append(num)\n            nums = bucket_zero + bucket_one\n        return nums\n\n    sorted_bin_nums = radix_sort_binary(numbers)\n    results = []\n    max_len = len(format(max(sorted_bin_nums), 'b'))\n    for i in range(1 << len(sorted_bin_nums)):\n        subset = [sorted_bin_nums[j] for j in range(len(sorted_bin_nums)) if (i & (1 << j))]\n        if subset and len(to_binary(sum(subset))) % 2 == 0:\n            results.append(sum(subset))\n    return sum(results)\n", "test": "def check(candidate):\n    assert candidate([3, 1]) == 4\n    assert candidate([8, 3, 5, 1]) == 60\n    assert candidate([]) == 0\n    assert candidate([2]) == 0\n    assert candidate([15, 7, 3, 1]) == 194\n    assert candidate([15, 7, 3, 1, 8]) == 448\n", "entry_point": "submarine_magic", "extra_info": {"cover_story_words": ["submarine", "magic wand"], "topics": ["Subsets", "Binary Tree", "Radix Sort"], "cleaned_prompt": "Write a function submarine_magic that takes a list of integers and returns the sum of all unique subsets sums that have an even number of digits in their binary representation. The integers must first be sorted using radix sort based on their binary representation.", "warnings": ["Solution failed correctness check.", "5, Problem definition ambiguity: The problem statement ambiguously specifies the requirement for subsets. It states to consider subsets with \"an even number of digits in their binary representation,\" which isn't clearly defined as even-numbered binary digits or even length of binary strings. This can lead to different interpretations and incorrect implementations.", "4, Implementation difficulty: The requirement to use a radix sort based on binary representation and then calculate sums for all subsets based on specific conditions could be computationally heavy for larger inputs. This might not scale well or could lead to performance issues, questioning the practicality of the problem for time-limited contests."]}}
{"task_id": "hard/3", "prompt": "def cyber_cafe_analysis(max_capacity, logs):\n    \"\"\"\n    In the bustling city of Neonopolis, a hybrid entertainment venue called 'CyberBrewCafe' is known for its urban jungle theme adorned with aesthetic digital trees. The cafe comprises different sections, each represented as a node in an undirected tree graph structure and halls as edges. Each node has a maximum capacity of attendees and logs are maintained to record visitors' timestamps and sections visited.\n\n    The venue uses a special analysis to optimize visitor experience by estimating the average number of visitors per section over a time frame. However, due to constantly changing visitor patterns, they cannot store all past data but rather sample them using the Reservoir Sampling technique.\n\n    Given the maximum capacities of each section (in a list where index represents the section/node) and a list of logs (each log is a tuple of timestamp, list of visited sections for that timestamp), implement a function to estimate the average occupancy rate across all sections for the given logs.\n\n    Each section's occupancy rate is calculated as the average number of visitors during the observed timestamps, divided by the maximum capacity of the section.\n\n    For example: If max_capacity is [10, 15, 20] and logs are [(1, [0, 1]), (2, [0, 1, 2]), (3, [2])], the estimated average occupancy rates would be approximately [0.20, 0.13, 0.10] respectively for each section considering each timestamp sees each section visited as one visitor unit.\n\n    Note:\n    - Sections' indices and logs must be valid. Assume a correct graph structure and valid logs.\n    - Resulting occupancy rates should be a list of floats rounded to two decimal places.\n    \"\"\"\n", "canonical_solution": "from collections import defaultdict\n\ndef cyber_cafe_analysis(max_capacity, logs):\n    visitor_counts = defaultdict(int)\n    timestamps_per_section = defaultdict(int)\n\n    for _, sections_visited in logs:\n        unique_sections = set(sections_visited)\n        for section in unique_sections:\n            visitor_counts[section] += 1\n\n    for _, sections_visited in logs:\n        for section in set(sections_visited):\n            timestamps_per_section[section] += 1\n\n    occupancy_rates = []\n    for i, max_cap in enumerate(max_capacity):\n        if i in timestamps_per_section:\n            average = visitor_counts[i] / timestamps_per_section[i]\n            occupancy_rate = round(average / max_cap, 2)\n        else:\n            occupancy_rate = 0.0\n        occupancy_rates.append(occupancy_rate)\n\n    return occupancy_rates", "test": "def check(candidate):\n    assert candidate([10, 15, 20], [(1, [0, 1]), (2, [0, 1, 2]), (3, [2])]) == [0.67, 0.67, 0.50]\n    assert candidate([10, 10, 10], [(1, [0, 1]), (5, [0, 2]), (7, [2])]) == [0.67, 0.33, 0.67]\n    assert candidate([100, 150, 200], [(1, [0]), (2, [1]), (3, [0, 1, 2])]) == [0.67, 0.67, 0.33]\n    assert candidate([5, 15, 25], []) == [0.0, 0.0, 0.0]\n    assert candidate([1, 1, 1, 1], [(1, [0, 1, 2, 3]), (2, [0, 1, 2, 3]), (3, [0, 1, 2, 3])]) == [3.0, 3.0, 3.0, 3.0]", "entry_point": "cyber_cafe_analysis", "extra_info": {"cover_story_words": ["urban jungle", "cyber cafe"], "topics": ["Subsets", "Reservoir Sampling", "Tree"], "cleaned_prompt": "Given the maximum capacities of each cafe section and a list of logs (each log is a tuple of timestamp, list of visited sections), implement a function to estimate the average occupancy rate across all sections for the given logs. Each section's occupancy rate is calculated as the average number of visitors during the observed timestamps, divided by the maximum capacity of the section.", "warnings": ["Solution failed correctness check.", "5, Inconsistent problem description and example: The prompt describes the task as calculating the \"average occupancy rate\" but then provides incorrect calculations in the examples that do not match the described methodology. The examples calculate occupancy based on total visitor visits divided by the number of timestamps, and not the average number of visitors per section over time divided by the maximum capacity.", "4, Misleading problem context with unnecessary details: The description of the cafe as a venue with an urban jungle theme and a tree graph structure is misleading and irrelevant to the solution of the problem. It suggests complexities related to graph theory which are not actually applied in the given solution, potentially confusing participants about the nature of the problem."]}}
{"task_id": "hard/4", "prompt": "def illusionist_library_sorting(books, k):\n    \"\"\"\n    In a mystical library used by famous illusionists, there are a series of spell books each having a unique enchantment strength represented as an integer in a list called books. The illusionists have a tradition where, before every grand show at the theater, they need to pick books whose combined strength is precisely the k-th strongest possible combination that can be formed with any subset of the books. Each book can only be used once per combination.\n\n    Write a function to find the sum of the strengths of the books in the k-th strongest subset of given books. If there are fewer than k subsets, return 0. For example, if the books have enchantments [1,2,3] and k is 3, the function should return 4 because the third strongest subset is {1, 3} or {2, 2} (if duplicates were allowed).\n\n    Note:\n    - If k is negative or 0, return 0.\n    - Books list can be empty, and as per the definition, return 0.\n\n    Constraints:\n    - Books can have repeated elements.\n    - The function should focus on optimal counting and selection methods, considering subsets.\n\n    The problem combines subset/enchantment strength calculation, quick-select for k-th element identification, and combinatorial counting.\n    \"\"\"\n", "canonical_solution": "    import itertools\n\n    def illusionist_library_sorting(books, k):\n        if k <= 0 or not books:\n            return 0\n\n        powerset = [subset for i in range(len(books) + 1) for subset in itertools.combinations(books, i)]\n        all_sums = sorted([sum(subset) for subset in powerset if subset], reverse=True)\n        if len(all_sums) < k:\n            return 0\n        return all_sums[k-1]", "test": "def check(candidate):\n    assert candidate([1,2,3], 3) == 4\n    assert candidate([1,2,3,4], 5) == 6\n    assert candidate([4,4,4,5], 3) == 13\n    assert candidate([], 1) == 0\n    assert candidate([3,5,7], 8) == 0\n    assert candidate([10, 10, 10], 1) == 30\n    assert candidate([1,2,3], 0) == 0\n    assert candidate([1,2,3,-1,0], 4) == 3", "entry_point": "illusionist_library_sorting", "extra_info": {"cover_story_words": ["library", "illusionist's theater"], "topics": ["Counting", "Quickselect", "Decode Ways"], "cleaned_prompt": "def illusionist_library_sorting(books, k):\n    \"\"\"\n    Write a function that calculates the sum of the strengths of the books in the k-th strongest subset of a given list of books. Each subset is formed by any combination of books, each book can be used once per subset. If k is negative or 0, or if fewer than k subsets can be formed, return 0. Books list can be empty.\n    \"\"\"\n", "warnings": ["Solution failed correctness check.", "4, inconsistency_in_problem_definition: The problem prompt states that \"Books can have repeated elements,\" but under the operational constraints contradicts this by providing test cases with repeated elements leading to specific expected sums. The provided solution and example also use repeated numbers, which implies it's expected that duplicates might change the results, yet the prompt's language and constraints make this unclear.", "5, potentially_incorrect_tests: One of the test cases asserts `candidate([1,2,3], 3) == 4`, which presupposes the subsets are ranked in a specific, yet undisclosed, order. Additionally, the consistent result in `assert candidate([1,2,3,4], 5) == 6` and `assert candidate([4,4,4,5], 3) == 13` without clarifying how duplication affects outcome rankings leads to confusion. This might lead to different subsets being considered as \"strongest\" based on undisclosed rules."]}}
{"task_id": "hard/1", "prompt": "def highest_elevation_path(elevations, steps):\n    \"\"\"\n    Imagine you are in prehistoric times, where floating islands exist. Your task is to jump between these floating islands, trying to reach the highest elevation possible in a set number of jumps. Each jump can either go to a higher elevation or stay on the same elevation, you can never move to a lower elevation.\n\n    You are given a list 'elevations' of integers which represent the elevation of each floating island. The 'steps' parameter represents the maximum number of jumps you can make from your starting point at the first island.\n\n    Your function should return the highest elevation you can reach within the given number of steps. If it is not possible to make any jump, the function should return the elevation of the first island.\n\n    Use a combination of Math, Divide and Conquer, and Monotonic Stack strategies for this task.\n\n    Constraints:\n    - Islands are linearly positioned.\n    - Elevation values and number of steps are positive integers.\n    - Elevations list contains at least one element.\n\n    Examples:\n    - If elevations = [3, 6, 7, 5, 8], and steps = 2, the output should be 7 (3 -> 6 -> 7).\n    - If elevations = [1, 1, 1, 1, 1], and steps = 4, the output is 1 since all islands are at the same elevation.\n    \"\"\"\n", "canonical_solution": "def highest_elevation_path(elevations, steps):\n    if not elevations or steps == 0:\n        return elevations[0]\n\n    def process_segment(segment):\n        stack = []\n        max_val = segment[0]\n        for val in segment:\n            while stack and stack[-1] < val:\n                stack.pop()\n            stack.append(val)\n            max_val = max(max_val, val)\n        return max_val\n\n    max_elevation = elevations[0]\n    segment = [max_elevation]\n    for i in range(1, min(len(elevations), steps + 1)):\n        if elevations[i] >= max_elevation:\n            segment.append(elevations[i])\n            max_elevation = process_segment(segment)\n    return max_elevation", "test": "def check(candidate):\n    assert candidate([3, 6, 7, 5, 8], 2) == 7\n    assert candidate([1, 1, 1, 1, 1], 4) == 1\n    assert candidate([5, 7, 6, 8, 10], 3) == 10\n    assert candidate([10, 9, 8, 7, 15], 1) == 10\n    assert candidate([3, 4, 5, 6, 7, 8, 9], 4) == 7", "entry_point": "highest_elevation_path", "extra_info": {"cover_story_words": ["prehistoric times", "floating island"], "topics": ["Math", "Divide and Conquer", "Monotonic Stack"], "cleaned_prompt": "Write a function that takes a list of integers 'elevations' and an integer 'steps' and returns the highest elevation possible within given number of steps. You can only move to a higher or same elevation with each step.", "warnings": ["Solution failed correctness check.", "5, Problem Definition Ambiguity: The provided problem statement and examples are ambiguous regarding the behavior when consecutive elevations decrease but then increase again within allowed steps. For instance, with the input elevations = [10, 9, 8, 7, 15], and steps = 1, according to the problem setup, it should be impossible to reach elevation 15 if you can only move to higher or same elevations, conflicting with the test assert candidate([10, 9, 8, 7, 15], 1) == 10 which suggests implicitly resolving at the current highest, not just the first peak or continuing despite declines. Moreover, the canonical solution and test cases seem inconsistent in enforcing or explaining the intended mechanism clearly.", "5, Implementation Error: The solution logic in `highest_elevation_path` function combined with lack of clarity in requirements states that the elevation evaluation can go beyond defined `steps` if islands continue to increase or remain flat in elevation, potentially violating constraints indirectly described in the task (e.g. example with elevations = [5, 7, 6, 8, 10], steps = 3 functionally yields 10 even if elevation dropped to 6). This potentially leads to unintentionally permitting declines if they lead to an eventual higher elevation within step limits, conflicting with the initial directive \"can never move to a lower elevation\"."]}}
