{"task_id": "hard/4", "prompt": "def predict_delays(flights, crystal_ball_data):\n    \"\"\"\n    An airport traffic system is simulated using a network where each node represents a different city and each edge represents a flight between those cities with an associated probability of delay. Given a list of flights, use a crystal ball data to enhance the predictions.\n\n    The flights are represented as a list of tuples (origin, destination, nominal_delay_prob) where 'nominal_delay_prob' is between 0 and 1. The crystal ball data provides additional delay insights as a dictionary mapping (origin, destination) to a new delay probability. Combine the nominal delay probability from the flights list and the crystal insights using the formula:\n    adjusted_delay_prob = (nominal_delay_prob + crystal_prob) / 2\n\n    Determine the maximum probability of any single flight being delayed using this combined data. You need to consider only those probabilities provided either in the flight list or crystal ball data.\n\n    Note:\n    - If there's no crystal data for a particular flight, use the nominal probability.\n\n    Example:\n    flights = [('NYC', 'LA', 0.3), ('LA', 'SF', 0.2), ('SF', 'NYC', 0.4)]\n    crystal_ball_data = {('NYC', 'LA'): 0.4, ('LA', 'SF'): 0.3}\n    The maximum probability of delay should be calculated as:\n    adjusted for 'NYC' -> 'LA' = (0.3 + 0.4) / 2 = 0.35\n    adjusted for 'LA' -> 'SF' = (0.2 + 0.3) / 2 = 0.25\n    'SF' -> 'NYC' remains as 0.4 (since no crystal data)\n    The output should be 0.4, which is the highest of these.\n    \"\"\"\n", "canonical_solution": "    def predict_delays(flights, crystal_ball_data):\n        max_delay_prob = 0\n        for origin, destination, nominal_prob in flights:\n            if (origin, destination) in crystal_ball_data:\n                crystal_prob = crystal_ball_data[(origin, destination)]\n                adjusted_prob = (nominal_prob + crystal_prob) / 2\n            else:\n                adjusted_prob = nominal_prob\n            max_delay_prob = max(max_delay_prob, adjusted_prob)\n        return max_delay_prob", "test": "def check(candidate):\n    flights1 = [('NYC', 'LA', 0.3), ('LA', 'SF', 0.2), ('SF', 'NYC', 0.4)]\n    crystal_ball_data1 = {('NYC', 'LA'): 0.4, ('LA', 'SF'): 0.3}\n    assert candidate(flights1, crystal_ball_data1) == 0.4\n    flights2 = [('NYC', 'LA', 0.5), ('LA', 'TX', 0.5)]\n    crystal_ball_data2 = {('NYC', 'LA'): 0.6, ('LA', 'TX'): 0.4}\n    assert candidate(flights2, crystal_ball_data2) == 0.55\n    assert candidate([], {}) == 0 # No flights, no delay\n    flights3 = [('A', 'B', 0.7)]\n    crystal_ball_data3 = {}\n    assert candidate(flights3, crystal_ball_data3) == 0.7 # No crystal data uses nominal\n    flights4 = [('A', 'B', 0.85)]\n    crystal_ball_data4 = {('A', 'B'): 0.95}\n    assert candidate(flights4, crystal_ball_data4) == 0.9 # High delay probability", "entry_point": "predict_delays", "extra_info": {"cover_story_words": ["airplane", "crystal ball"], "topics": ["Kd-Tree", "Find Missing Number", "Maximum Flow Problem"], "cleaned_prompt": "Define a function that calculates the maximum probability of a flight being delayed based on its nominal delay probabilities and enhancements by crystal ball data using the formula: (nominal_delay_prob + crystal_prob) / 2. If there is no crystal data, use the nominal probability. Return the highest probability of delay.", "warnings": ["Solution failed correctness check.", "5, Missing Return Type Description: The problem prompt does not indicate the expected type of the output value. Although the examples suggest it should be a floating-point number, the explicit description in the prompt is missing.", "4, Inconsistency Between Examples and Probable Output: The prompt ambiguously states the merging of probabilities from both the flight list and the crystal ball data. It needs to clarify whether to calculate probabilities only for those flights provided in the input list or also independently derive probabilities for any unique pairs found solely within the crystal ball data not present in the flight list."]}}
{"task_id": "hard/1", "prompt": "def fairy_tale_vortex_energy_network(events):\n    \"\"\"\n    In the surreal world of Aletheria, there are various energy vortexes produced by fairy tales. Each vortex has a specified start and end time and can interact with others to form a powerful energy network. Two vortexes connect if their times overlap. The strength of the network is determined by the size of the connected components of overlapping vortexes.\n\n    You are given a list of events, where each event is represented as (start, end) tuple indicating the start and end times of a vortex.\n\n    Your task is to compute the number of unique connected components (distinct networks of overlapping vortexes) using the Union-Find (or Disjoint Set Union, DSU) technique.\n\n    Example:\n        events = [(1, 3), (2, 5), (6, 8)]\n        Output should be 2 because:\n            - First two vortexes are connected (form one network), (1, 3) overlaps with (2, 5).\n            - Third vortex (6, 8) doesn't overlap with others.\n\n    Note:\n    - If there are no events, the result should be 0.\n    - Start time is always less than end time for an event.\n    \"\"\"", "canonical_solution": "    class DSU:\n        def __init__(self):\n            self.parent = {}\n\n        def find(self, a):\n            if self.parent[a] != a:\n                self.parent[a] = self.find(self.parent[a])\n            return self.parent[a]\n\n        def union(self, a, b):\n# Determine the roots of the sets of elements a and b\n            rootA = self.find(a)\n            rootB = self.find(b)\n# Only union sets if they have different roots (not already connected)\n            if rootA != rootB:\n                self.parent[rootB] = rootA\n\n    def fairy_tale_vortex_energy_network(events):\n        if not events:\n            return 0\n# Initialize DSU\n        dsu = DSU()\n# Fill the DSU with events indices as their own parents initially\n        for i in range(len(events)):\n            dsu.parent[i] = i\n\n# Check all pairs of events to determine if they overlap\n        for i in range(len(events)):\n            for j in range(i + 1, len(events)):\n                if (events[i][1] >= events[j][0] and events[i][0] <= events[j][1]):\n                    dsu.union(i, j)\n\n# Retrieve all unique roots which represent different connected components\n        unique_components = set()\n        for i in range(len(events)):\n            unique_components.add(dsu.find(i))\n\n        return len(unique_components)\n", "test": "def check(candidate):\n    assert candidate([(1, 3), (2, 5), (6, 8)]) == 2, \"Test case 1 failed\"\n    assert candidate([(1, 2), (3, 4), (5, 6)]) == 3, \"Test case 2 failed\"\n    assert candidate([(1, 10), (2, 3), (4, 5), (6, 7), (8, 9)]) == 1, \"Test case 3 failed\"\n    assert candidate([]) == 0, \"Test case 4 failed\"\n    assert candidate([(1, 5), (5, 10), (10, 15)]) == 1, \"Test case 5 failed\"\n    assert candidate([(1, 3), (2, 6), (4, 5), (7, 8)]) == 2, \"Test case 6 failed\"\n    assert candidate([(1, 3), (3, 5), (5, 7), (7, 9)]) == 1, \"Test case 7 failed\"\n    assert candidate([(1, 2), (3, 5), (6, 8), (9, 10), (11, 13), (12, 15), (14, 18)]) == 3, \"Test case 8 failed\"", "entry_point": "fairy_tale_vortex_energy_network", "extra_info": {"cover_story_words": ["fairy tale", "energy vortex"], "topics": ["Union Find", "Network Flow", "Insert Interval"], "cleaned_prompt": "def fairy_tale_vortex_energy_network(events):\n    \"\"\"\n    Compute the number of unique connected components in a list of time events using Union-Find technique, where each event is a tuple (start, end) and components are formed by overlapping events.\n\n    Examples:\n        events = [(1, 3), (2, 5), (6, 8)] -> Output: 2\n        events = [(1, 2), (3, 4), (5, 6)] -> Output: 3\n    \"\"\"", "warnings": ["Solution failed correctness check.", "5, Incorrect Overlap Condition: The prompt specifies overlap condition as \"Two vortexes connect if their times overlap.\" However, the interval condition used in the canonical solution `if (events[i][1] >= events[j][0] and events[i][0] <= events[j][1])` also considers intervals that touch each other without actually overlapping as connected. For example, the intervals (1, 5) and (5, 10) are treated as overlapping by this condition, which can lead to incorrect results as these two do not truly overlap but just touch at the boundary.", "5, Inconsistent Test Cases with Overlap Definition: The problem's test cases imply that touching intervals (end of one event = start of another) should be considered as a single component, which contradicts typical definitions of overlap and also clashes with the natural interpretation of 'overlapping'. This inconsistency can lead to confusion and incorrect implementations. For instance, test case 5 `[(1, 5), (5, 10), (10, 15)]` results in a single component, suggesting touching intervals form a connected network, which is not explained or justified in the problem description."]}}
{"task_id": "hard/3", "prompt": "def protect_carnival(activities, times):\n    \"\"\"\n    The town you live in is hosting a Cosmic Carnival that opens portals to various dimensions, and each dimension offers unique activities. However, a supernatural storm, known only as 'The Voidstorm', accompanies the carnival and may cut off access to these activities abruptly at different times.\n\n    For this problem, you are given a list of activities and the last time they can be safely accessed before possibly being cut off by the storm. Your goal is to determine the maximum number of unique activities that can be enjoyed exactly once if activities must be done in the given sequence and completed before their respective cutoff times.\n\n    You need to use Dynamic Programming to solve for the maximum number of activities that can be enjoyed without repeating any and before time runs out due to the storm.\n\n    Parameters:\n    - activities (List[str]): A list of activity names represented as strings.\n    - times (List[int]): A list of cutoff times for each activity. The order of times corresponds with the activities. Activities and their times cannot be reordered.\n\n    Example:\n    activities = ['a1', 'a2', 'a3', 'a4']\n    times = [3, 5, 2, 6]\n    - This means up to time = 2, only 'a3' can be enjoyed. Up to time 3, 'a1' can be enjoyed, and so on.\n    - Using the constraints and access times, the result should be 3 since we can enjoy 'a3', 'a1', and 'a4' in this order before their cutoff times.\n\n    Note:\n    - If no activities can be enjoyed before their times run out, return 0.\n    - The lists 'activities' and 'times' are both non-empty and have equal lengths. Activities can only be started and completed if the current time does not exceed their cutoff time.\n    \"\"\"", "canonical_solution": "def protect_carnival(activities, times):\n    n = len(activities)\n    # Define the DP array where dp[i] means the maximum activities we can enjoy from index 0 to i\n    dp = [0] * n\n    for i in range(n):\n        # Normally we can always do at least 1 activity if time allows\n        if i == 0 and times[i] >= 1:\n            dp[i] = 1\n        elif times[i] >= i + 1:\n            dp[i] = max(dp[i-1] + 1, dp[i-1])\n        else:\n            dp[i] = dp[i-1]\n    # Run through the activities and update the DP array based on the maximum number of activites that can be safely done\n        for j in range(i):\n            if times[j] >= i + 1 and times[i] >= i + 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[-1]", "test": "def check(candidate):\n    assert candidate(['a1', 'a2', 'a3', 'a4'], [3, 5, 2, 6]) == 3\n    assert candidate(['a1', 'a2', 'a3'], [1, 2, 1]) == 1\n    assert candidate(['a1', 'a2'], [2, 1]) == 1\n    assert candidate(['a1', 'a2', 'a3', 'a4', 'a5'], [2, 4, 1, 5, 3]) == 3\n    assert candidate(['a1', 'a2', 'a3', 'a4', 'a5', 'a6'], [6, 5, 4, 3, 2, 1]) == 6", "entry_point": "protect_carnival", "extra_info": {"cover_story_words": ["supernatural storm", "cosmic carnival"], "topics": ["Convex Hull", "Word Break", "Dynamic Programming"], "cleaned_prompt": "def protect_carnival(activities, times):\n    \"\"\"\n    Given a list of activities and the last time they can be safely accessed before getting cut off by a storm, determine the maximum number of unique activities that can be enjoyed exactly once using Dynamic Programming. Activities must be completed in sequence and before their respective cutoff times.\n\n    Each activity can only be started and completed if the current time doesn't exceed its cutoff time.\n\n    Examples:\n    For activities = ['a1', 'a2', 'a3', 'a4'] and times = [3, 5, 2, 6], the solution should be 3, enjoying 'a3', 'a1', and 'a4' in this order before their cutoff times.\n    \"\"\"", "warnings": ["Solution failed correctness check.", "5, Problem Context Clarity: The problem statement conflicts with the example provided regarding the sequence in which activities must be completed. The problem states \"activities must be done in the given sequence,\" implying a fixed order, yet the example suggests that activities can be chosen out of order ('a3', then 'a1', then 'a4'). This lack of clarity could confuse participants about whether they can choose activities out of initial order or must follow the list strictly from start to end.", "4, DP Array Initialization: The canonical solution's approach to initialize and update the `dp` array includes conditions that are inconsistently explained or aligned with the problem description. For example, the check `times[i] >= i + 1` tries to validate whether an activity can be completed before its cutoff but the index `i + 1` doesn\u2019t clearly translate to \"current time\" since current time isn\u2019t defined or updated in the function. This misalignment between the described mechanism (sequential access) and the implemented checks could lead to incorrect implementations.", "5, Example and Explanation Missmatch: The explanation in the problem statement and the details given in the example contradict each other. The problem explanation suggests a dynamic programming solution where activities are sequentially considered, but the example jumps to an optimized order without detailing how this reordering is compatible with dynamic programming constraints which conventionally imply a sequence or subset must be followed as given.", "5, Misleading Problem Category: The problem is labeled under topics like \"Convex Hull\" and \"Word Break\", which are unrelated to the actual dynamic programming challenge described. This could mislead participants or set incorrect expectations about the nature of the algorithmic problem they are about to solve."]}}
{"task_id": "hard/2", "prompt": "def alien_trip_planner(matrix, carpet_capacity, alien_tours):\n    \"\"\"\n    During a diplomatic mission, aliens have brought a magical flying carpet to Earth. The carpet can travel in any matrix-like structure (2D grid). Each cell in the matrix has a weight that represents the interest level of that cell. The carpet has a maximum capacity of alien tourists it can carry.\n\n    However, there's a catch: whenever the sum of the interest levels in a subsequence of cells (visited adjacently in any direction) equals carpet_capacity, the aliens take a tour (signifying a successful sightseeing trip).\n\n    The grid is represented as a matrix where each element indicates the interest level of that cell. The task is to find out the total number of unique tours the aliens can take where the sum of the weights in the selected contiguous subsequence of cells matches exactly the carpet_capacity. A subsequence is defined as a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n    The tours should be considered unique based on start and end cell coordinates in the matrix. Additionally, they should be contiguous either horizontally or vertically.\n\n    For example, given a matrix:\n    [[1, 2, 3],\n     [4, 5, 6],\n     [7, 8, 9]]\n    and carpet_capacity=12 (capacity of the carpet in alien tourists),\n    there's exactly one possible tour: subsequence [[4, 5, 3]] because 4 + 5 + 3 = 12.\n\n    Constraints:\n    - matrix contains only positive integers.\n    - Each dimension of the matrix is guaranteed to be at least 1 and at most 100.\n    - carpet_capacity is a positive integer and can be as large as the sum of all elements in the matrix.\n\n    Note: Use an efficient approach as the matrix can be large and multiple queries (tours) might be required.\n    \"\"\"", "canonical_solution": "def alien_trip_planner(matrix, carpet_capacity, alien_tours):\n    rows, columns = len(matrix), len(matrix[0])\n    tour_count = 0\n\n    # Horizontal tours\n    for row in matrix:\n        for start in range(columns):\n            current_sum = 0\n            for end in range(start, columns):\n                current_sum += row[end]\n                if current_sum == carpet_capacity:\n                    tour_count += 1\n                    break  # Once a valid tour is found, move to next starting point\n\n    # Vertical tours\n    for col in range(columns):\n        for start in range(rows):\n            current_sum = 0\n            for end in range(start, rows):\n                current_sum += matrix[end][col]\n                if current_sum == carpet_capacity:\n                    tour_count += 1\n                    break  # Once a valid tour is found, move to next starting point\n\n    return tour_count", "test": "def check(candidate):\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 12, 1) == 1\n    assert candidate([[1, 2, 3, 2, 1], [1, 3, 6, 2, 1], [1, 3, 5, 2, 1]], 6, 3) == 3\n    assert candidate([[100]], 100, 1) == 1\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 27, 1) == 1\n    assert candidate([[10, 10, 10],[10, 10, 10],[10, 10, 10]], 30, 3) == 3", "entry_point": "alien_trip_planner", "extra_info": {"cover_story_words": ["aliens", "flying carpet"], "topics": ["Set Matrix Zeroes", "Longest Increasing Subsequence", "3-Sum Problem"], "cleaned_prompt": "def alien_trip_planner(matrix, carpet_capacity, alien_tours):\n    \"\"\"\n    Given a matrix, find the number of unique tours where the sum of weights in the selected contiguous subsequence of cells is equal to the carpet_capacity.\n    A subsequence should be contiguous either horizontally or vertically. The start and end coordinates of subsequences should be considered for uniqueness.\n\n    Example:\n    Matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], Carpet Capacity: 12\n    Output: 1 (Only subsequence [[4, 5, 3]] makes 12)\n    \"\"\"", "warnings": ["Solution failed correctness check.", "5, Conflicting Description: The problem statement defines a subsequence in the traditional sense (elements in the same order, not necessarily contiguous) but then requests a contiguous sequence. This conflicting description may confuse participants about what is actually required.", "4, Invalid Format of Example Output: The example tour [[4, 5, 3]] mentioned in the prompt does not reflect a valid sub-array or sub-matrix from the matrix provided, either horizontally or vertically. This might mislead participants regarding the expectations of valid solutions."]}}
{"task_id": "hard/5", "prompt": "def cloak_activation_code(encoded_msg, jump_lengths):\n    \"\"\"\n    A supernatural storm has hit the city and the only hope is the 'Invisibility Cloak' which is sealed. To activate it, two puzzles related to the encoded message need to be solved:\n\n    1. The encoded message consists of numbers only, representing a complex system to decode the activation sequence for the cloak. Every digit from 1 to 9 maps directly to the first nine letters of the alphabet (e.g., '1' -> 'A', '2' -> 'B', ..., '9' -> 'I'). Each '0' you encounter in the message represents a 'space' symbol used to indicate a break in the encoding. You need to calculate the total number of ways this encoded message can be split into parts which represent valid letters, using the described mapping. Consecutive zeroes are not valid, and any segment with a number greater than 9 or starting with zero (other than a lone '0') should not be considered.\n\n    2. An array of jump_lengths is given where each jump_length[i] tells how many steps you can potentially take from position i. You need to find out whether it's possible to move from the start (index 0) of the array to the end (last index) by jumping according to the given lengths.\n\n    Example:\n\n    encoded_msg: '101' (interpret as 'J A')\n    jump_lengths: [1, 1, 0]\n    This determines possible ways to decode '101' as 'J A', and it is also possible to jump through the array from the beginning to the end.\n\n    Provide a solution that returns a tuple:\n    First element being the number of ways to decode the message, second element being a boolean indicating if jumping from start to end is possible.\n\n    Note:\n    - Each part of the encoded message should be treated independently for decoding.\n    - In the cloak activation, both decoding the message and successful jumping are required.\n    - Assume the input encoded message will be a non-empty string of digits and jump_lengths will be a non-empty list of positive integers.\n    \"\"\"", "canonical_solution": "    def num_ways_to_decode(encoded):\n        n = len(encoded)\n        if n == 0 or encoded[0] == '0':\n            return 0\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1 if encoded[0] != '0' else 0\n        for i in range(2, n + 1):\n            if encoded[i-1] != '0':\n                dp[i] += dp[i-1]\n            if encoded[i-2:i] in {'10', '20'}:\n                dp[i] += dp[i-2]\n        return dp[n]\n\n    def can_jump(jump_lengths):\n        n = len(jump_lengths)\n        reachable = 0\n        for i in range(n):\n            if i > reachable:\n                return False\n            reachable = max(reachable, i + jump_lengths[i])\n        return reachable >= n - 1\n\n    def cloak_activation_code(encoded_msg, jump_lengths):\n        way_to_decode = num_ways_to_decode(encoded_msg)\n        can_make_jump = can_jump(jump_lengths)\n        return (way_to_decode, can_make_jump)", "test": "def check(candidate):\n    assert candidate('10', [2, 0]) == (1, True)\n    assert candidate('210', [1, 1, 1]) == (1, True)\n    assert candidate('101', [1, 1, 0]) == (1, True)\n    assert candidate('111', [1, 2, 3]) == (3, True)\n    assert candidate('230', [1, 3, 1]) == (0, False)\n    assert candidate('110', [3, 2, 0]) == (1, True)\n    assert candidate('01', [1, 1]) == (0, False)", "entry_point": "cloak_activation_code", "extra_info": {"cover_story_words": ["invisibility cloak", "supernatural storm"], "topics": ["Decode Ways", "Prim's Algorithm", "Jump Game"], "cleaned_prompt": "Define a function cloak_activation_code(encoded_msg, jump_lengths) that calculates:\n- The number of ways to decode a numerically encoded message into letters, where '1' to '9' map to 'A' to 'I' and '0' is a space symbol.\n- If it is possible to jump from the start to the end of a list given possible jump lengths at each index.\nReturns a tuple of (number of ways to decode, boolean indicating if end is reachable).\nExamples are provided to clarify how the inputs relate to decoding and jump possibility.", "warnings": ["Solution failed correctness check.", "5, Ambiguous Functionality: The function prompt combines two unrelated computational tasks (decoding a numeric message into letters and checking the possibility of jumps in an array) into a single function. This forces dual functionality that doesn\u2019t appear logically connected, which can lead to confusion in understanding requirements and implementing solutions.", "4, Incomplete Specification on Output Requirements: While the problem description mentions that successful decoding and jump are both required, it is unclear what output is expected if one of the conditions (either decoding or jumping) fails. This may lead to ambiguous outputs that are not fully specified or misinterpreted by the user.", "4, Mixed Difficulty Levels: The encoding-decoding part is a typical dynamic programming problem that could be quite challenging, while the jumping part might be simpler. Combining these in a single task without clear separations can make it difficult to approach, especially under time constraints typically found in coding competitions."]}}
