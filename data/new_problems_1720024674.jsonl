{"task_id": "hard/5", "prompt": "def optimal_path_schedule(events):\n    \"\"\"\n    Imagine a new, highly automated shopping mall connected by an underground train system to different residential sectors. The mall management needs to tackle the challenge of organizing automatic event schedules for promotional events in the mall stations, in a way that the events do not clash with each other due to visitor or commuter flow.\n\n    Each station has events scheduled, and each event has dependencies which mean that some events must occur before others due to logistics and the sequence of setups. Your task is to simulate this scenario and provide the order in which these events should be scheduled using a topological sort.\n\n    The input 'events' is a list of (int, [int]) tuples that represent each event and its dependencies. The first element of the tuple is the event id, and the second element is a list of event ids that must happen before this event.\n\n    Return a list of event ids in a valid order so that for every event, all its dependencies have occurred before it, if possible. If there is no possible valid order, return an empty list.\n\n    Example:\n    Input: events = [(1, []), (2, [1]), (3, [2]), (4, [2]), (5, [1, 3])]\n    Output should be [1, 2, 3, 4, 5] or [1, 2, 4, 3, 5] representing an order where dependencies are respected.\n\n    Note:\n    - Implement a robust solution considering events might increase in number.\n    - Consider the computational and memory limitations when scaling up the number of events.\n    \"\"\"\n", "canonical_solution": "    from collections import deque, defaultdict\n\n    def optimal_path_schedule(events):\n        adj_list = defaultdict(list)\n        indegree = defaultdict(int)\n        for event, deps in events:\n            for dep in deps:\n                adj_list[dep].append(event)\n                indegree[event] += 1\n\n        # using Kahn's algorithm for topological sort\n        queue = deque([v for v in indegree if indegree[v] == 0])\n        top_order = []\n\n        while queue:\n            vertex = queue.popleft()\n            top_order.append(vertex)\n            for neighbor in adj_list[vertex]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        if len(top_order) == len(events):\n            return top_order\n        return []", "test": "def check(candidate):\n    assert candidate([(1, []), (2, [1]), (3, [2]), (4, [2]), (5, [1, 3])]) in [[1, 2, 3, 4, 5], [1, 2, 4, 3, 5]]\n    assert candidate([]) == []\n    assert candidate([(1, []), (2, [1]), (3, [1, 2])]) == [1, 2, 3]\n    assert candidate([(1, [2]), (2, [1])]) == []  # Circular dependency\n    assert candidate([(1, []), (2, [3]), (3, [1]), (4, [3]), (5, [2, 4])]) == []  # Insufficient resolution for valid ordering", "entry_point": "optimal_path_schedule", "extra_info": {"cover_story_words": ["train station", "shopping mall"], "topics": ["Simulation", "Topological Sort"], "cleaned_prompt": "Given a list of events where each event has other event dependencies for scheduling, write a function that returns an ordering of these events that respects their dependencies using topological sort. If no such ordering is possible due to cyclical or unresolved dependencies, return an empty list. Each event is identified by a unique integer ID.", "warnings": ["Solution failed correctness check.", "5, Ambiguous Functionality Description: The problem statement should clarify if each event ID in the list of dependencies of an event is unique or if duplicates are allowed. This affects how the topological sort treats these dependencies and can impact the resulting sort order.", "4, Input Specification Issue: The problem does not specify whether all events mentioned in dependencies are guaranteed to be in the main event list. This is crucial to determining the size and integrity of the directed graph used in topological sorting."]}}
{"task_id": "hard/4", "prompt": "def escape_plan(plans):\n    \"\"\"\n    In a mystical RPG game, players navigate through dungeons that have magically enhanced security systems.\n    Each dungeon security system is represented by a special linked list called a 'Skip List'.\n\n    A skip list enhances a regular linked list by adding 'forward links' in addition to the 'next' link.\n    These forward links allow quick jumps over several nodes promoting fast access and quick escapes.\n    Each node in the list also captures images from the room it represents using infrared.\n\n    To escape the dungeon, players need to find if any cycle exists using the regular 'next' links. If a cycle exists,\n    adventurers can exploit the repeating sequence to trick the infrared cameras by looping unexpectedly, causing the cameras to desynchronize and allowing escape.\n\n    Your function should receive a skip list (represented in a simplified form as a list of tuples where each tuple is (node_value, next_index, optional_forward_index)) \n    and return True if a cycle is detected in the 'next' links and False otherwise. The 'next_index' and 'optional_forward_index' are the indices in the list representing the respective links. A 'None' value in these indices indicates no link.\n\n    Example:\n    Input: [(0, 1, None), (1, 2, 4), (2, None, None), (3, 4, None), (4, 1, None)]\n    It represents a list where:\n      - Node with value 0 points to node with value 1. Node 0 has no forward link.\n      - Node 1 points to node 2 and has a forward link to node 4.\n      - Node 2 has no next or forward link.\n      - Node 3 points to node 4 and has no forward link.\n      - Node 4 points back to node 1, forming a cycle.\n\n    Output: True - because there is a cycle (1 -> 2 -> None -> 4 -> 1).\n\n    Note: Consider using techniques from computer vision like synchronicity problems to think about how adventurers could exploit the cycle.\n    \"\"\"", "canonical_solution": "def escape_plan(plans):\n    def detect_cycle(plans):\n        slow = fast = 0\n        while True:\n            if slow is None or fast is None or plans[fast][1] is None:\n                return False\n            slow = plans[slow][1]\n            fast = plans[fast][1]\n            if plans[fast][1] is not None:\n                fast = plans[fast][1]\n            if slow == fast:\n                return True\n        return False\n    return detect_cycle(plans)", "test": "def check(candidate):\n    assert candidate([(0, 1, None), (1, 2, 4), (2, None, None), (3, 4, None), (4, 1, None)]) == True\n    assert candidate([(0, 1, 2), (1, None, None), (2, None, None)]) == False\n    assert candidate([(0, 1, None), (1, 2, None), (2, 0, None)]) == True\n    assert candidate([]) == False\n    assert candidate([(0, None, None),]) == False\n    assert candidate([(0, 1, 2), (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (5, 6, None), (6, 1, None)]) == True", "entry_point": "escape_plan", "extra_info": {"cover_story_words": ["dungeon", "restaurant"], "topics": ["Linked List Cycle", "Skip List"], "cleaned_prompt": "Write a function that takes a skip list (represented as a list of tuples (node_value, next_index, optional_forward_index)) and returns True if a cycle is detected in the 'next' links and False otherwise. A skip list is a linked list with additional forward links that allow for quick jumps over nodes.\n\nExample: Input: [(0, 1, None), (1, 2, 4), (2, None, None), (3, 4, None), (4, 1, None)] meaning Node 0 points next to Node 1 and Node 1 points next to Node 2 and forward to Node 4, etc. Output: True as there's a cycle 1 -> 2 -> None -> 4 -> 1.", "warnings": ["Solution failed correctness check.", "5, Unclear Problem Statement: The problem statement involves multiple confusing elements, potentially leading to misunderstandings about what is needed. The prompt includes non-relevant details about dungeons and magic, which does not add value to understanding the core problem of detecting cycles in skip lists.", "4, Inconsistent Handling of 'None': The sample input allows for a 'None' index, implying that this makes a logical end to a linked chain. However, the problem setup and description do not clarify the expected behavior when such a 'next' link points to 'None'. This could cause incorrect implementations or interpretations of what constitutes a cycle.", "4, Unspecified List Boundary Conditions: The prompt does not specify how out-of-range indices should be handled (i.e., if an index greater than list length is given). This can lead to confusion or inconsistency in implementing and understanding the cycle detection logic."]}}
{"task_id": "hard/1", "prompt": "def sorcerers_library(tomes, enchantments):\n    \"\"\"\n    In an ancient sorcerer's tower, there's a unique library filled with magical tomes. Each tome details an enchantment technique encoded as an integer. A sorcerer apprentice discovered that the tomes have been enchanted and thus, form a magical link among themselves.\n\n    These links create a magical formation where three specific tomes' enchantments, when summed, produce a magical glyph (a value of 0). The tomes themselves are arranged in a complex spiral linked list structure. The apprentice suspects that this linked list has a cycle formed by a corrupt magic that must be broken to stop the enchantments from causing havoc.\n\n    You need to write a function that explores this list of tomes, represented by list 'tomes', and list 'enchantments', which represents the enchantments as integers on each tome. You'll need to find a triplet of integers among the enchantments that sum to zero, and also detect if there's a cycle in the linked list structure where each node points to a next tome, using the integer list form as indices.\n\n    Your solution should return a tuple (contains_cycle, zero_sum_triplet_exists).\n\n    Examples:\n    If 'tomes' = [1, 4, 3, 2, 0] and 'enchantments' = [-1, 0, 2, -3, 1], the output should be (True, True) as there's a cycle (0->1->4->0) and the triplet (-1, 2, -3) corresponding to indices (0, 2, 3) sum to zero.\n\n    Note:\n    - The 'tomes' list will be non-empty and have length equal to 'enchantments'.\n    \"\"\"\n", "canonical_solution": "def sorcerers_library(tomes, enchantments):\n    def has_cycle(node):\n        slow = tomes[node]\n        fast = tomes[tomes[node]]\n        while fast != slow:\n            if fast == tomes[fast]: break # detecting self-loop\n            fast = tomes[tomes[fast]]\n            slow = tomes[slow]\n        return fast == slow\n\n    def three_sum_zero(enchantments):\n        enchantments.sort()\n        n = len(enchantments)\n        for i in range(n):\n            if i > 0 and enchantments[i] == enchantments[i - 1]: continue\n            l, r = i + 1, n - 1\n            while l < r:\n                sum_lr = enchantments[i] + enchantments[l] + enchantments[r]\n                if sum_lr == 0: return True\n                elif sum_lr < 0: l += 1\n                else: r -= 1\n        return False\n\n    contains_cycle = has_cycle(0)\n    zero_sum_triplet_exists = three_sum_zero(enchantments)\n\n    return (contains_cycle, zero_sum_triplet_exists)", "test": "def check(candidate):\n    assert candidate([1, 4, 3, 2, 0], [-1, 0, 2, -3, 1]) == (True, True)\n    assert candidate([0, 2, 3, 4, 1], [5, 1, -2, -4, 0]) == (True, True)\n    assert candidate([2, 0, 3, 4, 1], [1, -1, 1, -1, 0]) == (False, False)\n    assert candidate([3, 2, 0, 1], [-1, 2, -3, 2]) == (False, True)\n    assert candidate([0, 1, 2, 3], [0, 0, 0, 0]) == (False, True)", "entry_point": "sorcerers_library", "extra_info": {"cover_story_words": ["library", "sorcerer's tower"], "topics": ["Linked List Cycle", "3-Sum Problem"], "cleaned_prompt": "Write a function that takes two lists: 'tomes' which represents indices pointing to other indices in the same list forming a linked list, and 'enchantments' which are integers associated with each tome. Your function should determine if a cycle exists in the linked list represented by 'tomes' and whether any triplet of integers in 'enchantments' sums to zero. The function should return a tuple (contains_cycle, zero_sum_triplet_exists). Implement a function that efficiently addresses both problems considering the distinct constraints. Example: for tomes [1, 4, 3, 2, 0] and enchantments [-1, 0, 2, -3, 1], return (True, True).", "warnings": ["Solution failed correctness check.", "5, Unclear Data Structure Description: The problem description does not adequately explain the structure or expected values within the 'tomes' list, particularly how they represent a \"complex spiral linked list.\" It also assumes knowledge that indices can refer to other indices, which isn't a usual interpretation and may confuse participants unfamiliar with such representations.", "5, Problem Complexity Misalignment: The task combines the detection of a cycle in a linked list and finding a zero-sum triplet, which are significantly different in complexity, potentially leading to confusion over the focus required to address each sub-problem effectively. This could affect the design of an efficient solution and is not typical in competitive programming where problems usually focus on a single clear objective.", "4, Inconsistent Example Mapping to Problem Description: In the given examples, there's an implied assumption that elements in 'tomes' are always valid indices within its own range (e.g., no index out of bound errors), but there's no explicit guarantee mentioned in the problem description that 'tomes' will not contain out-of-range values. This might lead to runtime errors in implementations if not properly handled."]}}
{"task_id": "hard/3", "prompt": "def recover_artifacts(artifact_images, artifact_connections):\n    \"\"\"\n    In the folklore of an ancient lost city, it is said that there exists a wise old tree that holds the knowledge of the city's once-thriving artifacts. These artifacts are scattered around the world, and legends suggest that if one could merge the stories of these artifacts in the correct order, the location of the city could be found.\n\n    You have been provided with two inputs:\n    - artifact_images: A list of lists of matrices (numpy arrays) where each matrix represents a greyscale image of an artifact.\n    - artifact_connections: A list of tuples (a, b), representing that the artifact image_list 'a' must be merged after artifact image_list 'b'.\n\n    Your task is to merge the artifact image lists in an order consistent with the provided 'artifact_connections' requirements. The merging should respect the constraints of 'artifact_connections' implying a clean, sequential manner to reveal a final M x N matrix representing the full picture of the artifacts combined.\n\n    Additionally, use memoization to efficiently handle repetitive computations while merging these images. Apply image processing techniques to accurately merge them without data distortion.\n\n     Further Considerations:\n    - Every single artifact in 'artifact_images' represents a sequence of artifact conditions through time presented as a series of matrices.\n    - The merged result must be a single matrix which is the composition of all these image lists in a sequence dictated by 'artifact_connections'.\n    - Use numpy for matrix operations.\n    - Assume all matrices within each list are of equal dimensions MxN and all merge operations work on matrices of the same size.\n    \n    Example:\n    if artifact_images = [\n        [np.array([[1, 1], [1, 1]]), np.array([[2, 2], [2, 2]])],\n        [np.array([[3, 3], [3, 3]])],\n        [np.array([[4, 4], [4, 4]])]\n    ]\n    and artifact_connections = [(1, 0), (2, 1)]\n\n    The correct order of merging would be list 0 -> list 1 -> list 2 which means:\n    - First, [np.array([[1, 1], [1, 1]]), np.array([[2, 2], [2, 2]])],\n    - Next,  [np.array([[3, 3], [3, 3]])],\n    - Finally, [np.array([[4, 4], [4, 4]])].\n\n    \"\"\"", "canonical_solution": "    import numpy as np\n    def merge_images(images):\n        return np.sum(images, axis=0)\n\n    def compute_merge_order(connections):\n        from collections import defaultdict, deque\n        in_degree = defaultdict(int)\n        graph = defaultdict(list)\n        for child, parent in connections:\n            graph[parent].append(child)\n            in_degree[child] += 1\n        # 0 in-degree means no dependency, can process\n        process_queue = deque([k for k in range(len(images)) if in_degree[k] == 0])\n        order = []\n        while process_queue:\n            node = process_queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    process_queue.append(neighbor)\n        return order\n\n    def recover_artifacts(artifact_images, artifact_connections):\n        order = compute_merge_order(artifact_connections)\n        merged_artifact = np.zeros(artifact_images[0][0].shape)\n        for idx in order:\n            image_list = artifact_images[idx]\n            merged_image = merge_images(image_list)\n            merged_artifact += merged_image\n        return merged_artifact\n", "test": "def check(candidate):\n    import numpy as np\n    test_artifacts1 = [\n        [np.array([[1, 1], [1, 1]]), np.array([[2, 2], [2, 2]])],\n        [np.array([[3, 3], [3, 3]])],\n        [np.array([[4, 4], [4, 4]])]\n    ]\n    test_connections1 = [(1, 0), (2, 1)]\n    test_result1 = np.array([[10, 10], [10, 10]])\n    assert np.array_equal(candidate(test_artifacts1, test_connections1), test_result1)\n\n    test_artifacts2 = [\n        [np.array([[2, 2], [3, 3]])],\n        [np.array([[0, 0], [1, 1]])],\n        [np.array([[4, 4], [5, 5]])]\n    ]\n    test_connections2 = [(2, 0)]\n    test_result2 = np.array([[6, 6], [9, 9]])\n    assert np.array_equal(candidate(test_artifacts2, test_connections2), test_result2)\n\n    assert np.array_equal(candidate([], []), np.zeros((0, 0)))\n\n    check(recover_artifacts)", "entry_point": "recover_artifacts", "extra_info": {"cover_story_words": ["lost city", "wise old tree"], "topics": ["Memoization", "Merge k Sorted Lists"], "cleaned_prompt": "Define a function recover_artifacts that takes a list of lists of matrices where each matrix is a greyscale image of an artifact and a list of tuples representing a mandatory merge order. Merge these matrices respecting this order to reveal a final composition that unveils more information.", "warnings": ["Only 3 test cases found. Minimum recommended is 5.", "Solution failed correctness check.", "4, Unclear Merge Mechanism: The problem description ambiguously outlines how the matrices should be merged. Beyond saying that matrices should be merged in a sequence, it doesn\u2019t specify the merge operation - sum, average, max, etc. This lack of definition could lead to different interpretations of the required output.", "4, Vague Use of Memoization: While the prompt suggests using memoization to manage repetitive computations, it doesn't specify which part of the computation is repetitive and would benefit from memoization. This could lead to incorrect implementations, especially since matrix operations can be computationally expensive without clear guidance."]}}
{"task_id": "hard/2", "prompt": "def traffic_light_schedule(intersections):\n    \"\"\"\n    In a city planning simulator, you are tasked to write a function that manages the scheduling of traffic lights at various road intersections using a set of images. Each intersection is equipped with cameras that capture the current traffic scenario as an image, and these images are passed to your function in the form of matrices (list of lists) of pixels.\n\n    Each pixel value represents the traffic density and 0 represents no traffic. The higher the number, the denser the traffic at that location. Your function will receive a list of such matrices for different intersections.\n\n    Your task is to implement a function that schedules traffic lights' green time dynamically based on the traffic density captured in the images using a combination of Red-Black Trees and Queues. Intersections that consistently show higher traffic should have longer green light durations for smoother traffic flow.\n\n    Example:\n    For the intersections described by the following matrices:\n    [\n        [[0, 0, 3], [0, 0, 4], [0, 0, 0]],  # Intersection 1\n        [[0, 0, 0], [0, 5, 0], [0, 0, 0]]   # Intersection 2\n    ]\n    The function might determine longer green times for Intersection 2 because of the higher central traffic density.\n\n    Note:\n    - Assume the matrices are equitably square and of reasonable size (e.g., 9x9).\n    - You must leverage Red-Black Tree structures for efficient priority and update mechanisms, and Queues for scheduling decisions.\n    - Consider the time complexity for real-time traffic management response.\n    \"\"\"\n", "canonical_solution": "from collections import deque\nimport random\n\nclass Node:\n    def __init__(self, value, color='red', left=None, right=None, parent=None):\n        self.value = value\n        self.color = color\n        self.left = left\n        self.right = right\n        self.parent = parent\n\nclass RedBlackTree:\n    def __init__(self):\n        self.NIL = Node(value=None, color='black')\n        self.root = self.NIL\n\n    # Code to implement Red-Black Tree insertion and rotation\n    # Code to update and balance the Red-Black Tree\n\ndef calculate_density(matrix):\n    total_density = sum(sum(row) for row in matrix)\n    return total_density\n\ndef traffic_light_schedule(intersections):\n    tree = RedBlackTree()\n    queue = deque()\n\n    # Populate the tree with initial densities\n    for idx, intersection in enumerate(intersections):\n        density = calculate_density(intersection)\n        tree.insert(density, idx)  # Red-Black Tree insertion\n        queue.append((density, idx))\n\n    # Scheduler decision logic using the queue\n    # Traffic light adjustment and updates\n\n    return queue  # This will represent the scheduled order\n", "test": "def check(candidate):\n    result = candidate([\n        [[0, 0, 3], [0, 0, 4], [0, 0, 0]],\n        [[0, 0, 0], [0, 5, 0], [0, 0, 0]]\n    ])\n    assert len(result) == 2  # Ensure all intersections are processed\n    assert result[0][1] > result[1][1]  # Based on the example, intersection 2 should have higher priority\n\n    result = candidate([\n        [[1, 2, 1], [0, 0, 0], [1, 2, 1]],\n        [[2, 2, 2], [2, 8, 2], [2, 2, 2]],\n        [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    ])\n    assert len(result) == 3\n    assert result[0][1] == 1 and result[1][1] == 0 and result[2][1] == 2  # Intersection with densest center should be first\n", "entry_point": "traffic_light_schedule", "extra_info": {"cover_story_words": ["car", "city"], "topics": ["Red-Black Tree", "Queue"], "cleaned_prompt": "def traffic_light_schedule(intersections):\n    \"\"\"\n    Write a function that manages the scheduling of traffic lights at various road intersections using traffic density data from images. Each 'image' of an intersection is represented as a matrix showing traffic density at each point.\n\n    Implement a function that schedules traffic lights' green time based on traffic density captured in these matrices using Red-Black Trees for efficient priority updates and Queues for scheduling decisions.\n\n    Examples:\n    - For matrices representing traffic density at different intersections, set longer green times for intersections with higher central traffic density.\n    \"\"\"\n", "warnings": ["Only 4 test cases found. Minimum recommended is 5.", "Solution failed correctness check.", "5, Unrealistic Implementation Requirement: The problem requires the use of Red-Black Trees and Queues to manage real-time traffic light scheduling based on traffic density images. This requirement is non-trivial and significantly complex, especially when the correlation between these data structures and their application in controlling traffic systems is not adequately explained or justified.", "4, Unclear Problem Objectives: The problem statement lacks clarity about how to use traffic density data to determine the duration of traffic lights. No specific rules or formulas are provided to convert the matrix data into actionable traffic light durations. It leaves too much ambiguity for contestants on how to implement the function practically."]}}
