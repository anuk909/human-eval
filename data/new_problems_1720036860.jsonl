{"task_id": "hard/5", "prompt": "def enchanted_forest_paths(landmarks, paths):\n    \"\"\"\n    In an ancient enchanted forest, there are several landmarks connected by magical paths. Each path and landmark has special properties defined by enchantments.\n\n    Landmarks are points on a 2D plane given as (x, y) coordinates. Paths are defined as line segments between two distinct landmarks.\n\n    There is an upcoming celestial event that will activate intersections of paths, granting access to hidden knowledge. Your task is to find how many distinct points there are where at least two paths intersect.\n\n    For this task, an intersection is defined as a point where two lines would cross if extended infinitely (excluding endpoints). Do not include intersections occurring solely at endpoints shared by paths.\n\n    The implementation should leverage efficient computational geometry algorithms to find intersections between line segments that meet the requirements. Return the number of such distinct intersection points.\n\n    Example:\n    - landmarks = [(0, 0), (2, 0), (1, 4)],\n    - paths = [(0, 1), (1, 2), (0, 2)]. Here, paths between landmarks 0-1, 1-2, and 0-2 do not intersect at any internal points when extended infinitely.\n    The function should return 0 for this set of paths.\n\n    \"\"\"\n", "canonical_solution": "    def line_intersection(p1, p2, p3, p4):\n        # Advanced computational geometry to find intersection between two line segments excluding endpoints\n        # Return intersection coordinate (x, y) if they intersect, else None\n        pass\n\n    def find_intersections(paths_coordinates):\n        intersections = set()\n        for i in range(len(paths_coordinates)):\n            for j in range(i + 1, len(paths_coordinates)):\n                p1, p2 = paths_coordinates[i]\n                p3, p4 = paths_coordinates[j]\n                intersection = line_intersection(p1, p2, p3, p4)\n                if intersection:\n                    intersections.add(intersection)\n        return len(intersections)\n\n    paths_coordinates = [(landmarks[a], landmarks[b]) for a, b in paths]\n    return find_intersections(paths_coordinates)\n", "test": "def check(candidate):\n    assert candidate([(0, 0), (2, 0), (1, 4)], [(0, 1), (1, 2), (0, 2)]) == 0\n    assert candidate([(0, 0), (1, 1), (2, 2)], [(0, 1), (1, 2)]) == 0\n    assert candidate([(0, 0), (2, 0), (3, 3), (4, 4)], [(0, 1), (2, 3)]) == 0\n    assert candidate([(0, 0), (2, 0), (1, 4), (2, 5)], [(0, 1), (2, 3)]) == 1\n    assert candidate([(0, 0), (1, 2), (2, 0), (3, 2)], [(0, 1), (2, 3)]) == 1", "entry_point": "enchanted_forest_paths", "extra_info": {"cover_story_words": ["ancient civilization", "enchanted forest"], "topics": ["Subsets", "Line Segment Intersection"], "cleaned_prompt": "Calculate the number of valid subsets of paths between landmarks on a 2D plane that intersect at least once, not just at endpoints but any internal point. Example:\n - landmarks: [(0, 0), (2, 0), (1, 4)]\n - paths: [(0, 1), (1, 2), (0, 2)] form a triangle with intersecting paths.\n All three paths intersect at least at one point. Output should be 7, considering all non-empty subsets.", "warnings": ["Solution failed correctness check.", "4, Ambiguity in Description: The problem statement should provide clearer specifications on what constitutes a \"distinct\" intersection point. This includes how close two intersections would need to be considered the same, especially when the resultant intersection coordinates could be floating-point numbers with precision issues.", "5, Mathematical Complexity: The prompt requires efficiency in computational geometry algorithms but does not specify constraints for computational complexity or limit the size of input (number of landmarks and paths). Without this, the solution might not be optimally designed for larger datasets."]}}
{"task_id": "hard/3", "prompt": "def sleepy_sun_search(show_times, query_times):\n    \"\"\"\n    In a magical circus, every day the sun behaves differently. At random, the sun might either shine brightly or it might be sleepy and barely shine. The circus manager keeps track of show times but needs your help to determine if the sleepy sun is affecting the circus shows.\n\n    Given a list of show times (sorted in ascending order) where each time represents when a show starts or ends during a day (format: [start_1, end_1, start_2, end_2,...]), and a list of query times (in ascending order), where each time represents a specific moment the manager wants to check for visibility, return a list indicating if at each query time the sun was sleepy (0 - not sleepy, 1 - sleepy).\n\n    A query time is considered 'sleepy' if it falls strictly between any of the [start_time, end_time] intervals, not inclusive of endpoints.\n\n    For example, show_times = [2, 5, 7, 10], and query_times = [1, 6, 9], the result should be [0, 1, 0]. For these query times:\n     - At time 1, there was no show so the sun was not sleepy (0).\n     - At time 6, it falls between the intervals [2, 5] and [7, 10], not including interval endpoints, so the sun was sleepy (1).\n     - At time 9, it does not fall within any show time interval so the sun was not sleepy (0).\n\n    Note:\n    - If there are no show times, then the result for all queries should be 0 (not sleepy).\n    - The input list may contain large ranges but wouldn't violate reasonable processing limits.\n    - The input show_times strictly follows the format of alternating start and end times.\n    - The solution must correctly handle overlapping intervals and robustly ascertain sleepiness status, including rigorous handling of interval endpoints.\n    \"\"\"\n", "canonical_solution": "    def is_sleepy(time, show_times):\n        for i in range(0, len(show_times), 2):\n            if show_times[i] < time < show_times[i+1]:\n                return 1\n        return 0\n\n    return [is_sleepy(time, show_times) for time in query_times]", "test": "def check(candidate):\n    assert candidate([2, 5, 7, 10], [1, 6, 9]) == [0, 1, 0]\n    assert candidate([], [1, 2, 3, 4, 5, 6]) == [0, 0, 0, 0, 0, 0]\n    assert candidate([0, 1, 5, 6], [1, 2, 3]) == [0, 1, 1]\n    assert candidate([1, 4, 5, 8], [0, 5, 7]) == [0, 0, 1]\n    assert candidate([999, 1000], [999, 1000, 1001]) == [0, 0, 0]", "entry_point": "sleepy_sun_search", "extra_info": {"cover_story_words": ["circus", "sleepy sun"], "topics": ["Array", "Binary Search"], "cleaned_prompt": "Given a list of show times marking intervals when the 'sleepy sun' occurs, and a list of specific moments to query, return a list indicating if the sun was sleepy at each query time. A query time is 'sleepy' if it falls strictly between any of the show time intervals. If there are no show times, then the result for all queries should be 0 (not sleepy).", "warnings": ["Solution failed correctness check.", "4, Unclear Relationship Between Show Times and Sleepy Sun: The problem statement suggests that the sun's sleepiness (whether bright or barely shining) is related to show times, but this link is not explicitly defined or clearly explained. It states that if a query time is strictly between show times, the sun is considered sleepy. However, it does not clarify why these intervals directly relate to the sun's behavior, creating potential confusion about the logic behind why these times affect or indicate the sun's sleepiness."]}}
{"task_id": "hard/4", "prompt": "def color_probability(img_data, patterns, memory):\n    \"\"\"\n    In her cosmic exploration, Captain Elara uses an enchanted instrument, 'SpectroLume', aboard her spaceship to analyze the surface of unknown planets. The SpectroLume captures images in which each pixel exhibits a predominant color represented as an RGB tuple (e.g., (255, 0, 0) for red).\n\n    The task is to write a function evaluating the probability of given color patterns appearing together within the image data captured by the SpectroLume. The image data (`img_data`) is a list of lists, with each element being a tuple representing an RGB pixel value.\n\n    The 'patterns', a list of tuples, each represent an RGB color. The function will determine the probability of all colors in 'patterns' occurring next to each other in the data, respecting the sequence provided in 'patterns'.\n\n    The function should utilize the 'memory' dictionary passed as an argument to store and retrieve pre-computed probabilities (memoization) to optimize performance on repeated calls with the same data.\n\n    The function should return the decimal probability (0 to 1, inclusive) of finding the 'patterns' sequence within the image data.\n\n    Example Image Data (simplified):\n    [\n        [(255, 0, 0), (0, 255, 0)],\n        [(0, 0, 255), (255, 255, 0)]\n    ]\n\n    Example Patterns:\n    [(255, 0, 0), (0, 255, 0)]\n\n    Note:\n    - Implement memoization to efficiently handle identical pattern sets in subsequent function calls.\n    - Use appropriate statistical calculations to evaluate the pattern probability.\n    \"\"\"\n", "canonical_solution": "    def color_probability(img_data, patterns, memory):\n        from hashlib import sha256\n        import json\n\n        unique_key = sha256(json.dumps(sorted(patterns)).encode()).hexdigest()\n        if unique_key in memory:\n            return memory[unique_key]\n\n        total_checks = 0\n        successful_matches = 0\n        for i in range(len(img_data)):\n            for j in range(len(img_data[0]) - len(patterns) + 1):\n                if all(img_data[i][j + k] == patterns[k] for k in range(len(patterns))):\n                    successful_matches += 1\n                total_checks += 1\n        probability = successful_matches / total_checks if total_checks > 0 else 0\n        memory[unique_key] = probability\n        return probability\n", "test": "def check(candidate):\n    patterns = [(255, 0, 0), (0, 255, 0), (0, 0, 255)]\n    memory = {}\n    image_data = [[(255, 0, 0), (0, 255, 0)], [(0, 0, 255), (255, 255, 0)]]\n    assert candidate(image_data, patterns, memory) == 0.5\n    assert candidate(image_data, patterns, memory) == 0.5  # check for memoized result without recalculation\n    assert candidate([], patterns, memory) == 0  # empty image \n    assert candidate([[tuple()]], patterns, memory) == 0  # non-matching single pixel image\n    assert candidate([[(255, 0, 0), (0, 255, 0), (255, 255, 0)]], patterns, memory) == 1  # full row match \n    assert candidate([[(255, 0, 0), (0, 255, 0)], [(255, 0, 0), (0, 255, 0)]], patterns, memory) == 0.5  # partial match\n", "entry_point": "color_probability", "extra_info": {"cover_story_words": ["enchanted instrument", "spaceship"], "topics": ["Memoization", "Probability and Statistics"], "cleaned_prompt": "def color_probability(img_data, patterns, memory):\n    \"\"\"\n    This function calculates the likelihood of a specific set of RGBA color patterns appearing together in an image dataset. It uses memoization to store computed probabilities and improve efficiency for repeated checks on the same pattern sets.\n    The img_data is presented as a list of lists of tuples, where each tuple contains RGB color values. The function should return the probability, from 0 to 1 inclusive, of the entire pattern set appearing coherently within the given data.\n    \"\"\"\n", "warnings": ["Solution failed correctness check.", "4, Incorrect probability calculation method: The canonical solution calculates the probability of a pattern being found in the image based solely on adjacency in rows, without considering vertical or diagonal adjacent occurrences. This limits the ability of the function to correctly evaluate all possible neighboring patterns as described in the prompt."]}}
{"task_id": "hard/2", "prompt": "def optimal_athlete_composition(players, sports_data):\n    \"\"\"\n    As a sport analytics expert, you have been tasked with analyzing and optimizing compositions for a set of athletes in a game played in an arena consisting of distinct zones. Each zone employs skills from different traditional sports like basketball and soccer.\n\n    You are provided with:\n    - players: List of distinct string identifiers for each player.\n    - sports_data: A dictionary containing information on zones, portals, and portal link rules.\n\n    The 'sports_data' dictionary consists of:\n    - 'zones': List of strings, each representing a different zone in the arena.\n    - 'portals': List of tuples, each tuple represents a bi-directional portal between two zones (e.g., ('zone1', 'zone2')).\n    - 'rules': Dictionary where keys are tuples representing zones connected by a portal and values are strings describing word break rules applied to player identifiers for using the portal.\n\n    Each player has a set of skills rated for each zone. Your task is to suggest the optimal player distribution across zones and identify any portal disconnections that would strategically benefit your team. Avoid complex computer vision scenarios or unrealistic algorithm applications and focus on logically distributing players and managing portal rules.\n\n    You may return a dictionary indicating player allocation to zones and a list of portal disconnections that would be strategic based on given rules and portal connectivity.\n\n    Example:\n    players = ['alice1', 'bob22', 'charlie333']\n    sports_data = {\n        'zones': ['basketball', 'soccer', 'hockey'],\n        'portals': [('basketball', 'soccer'), ('soccer', 'hockey')],\n        'rules': {('basketball', 'soccer'): 'ba*so', ('soccer', 'hockey'): 'so*ho'}\n    }\n    The output might suggest distributions like {'alice1': 'soccer', 'bob22': 'basketball', 'charlie333': 'hockey'} and disconnections like [('basketball', 'soccer')].\n    \"\"\"\n", "canonical_solution": "    def can_break(word, pattern):\n        dp = [False] * (len(word) + 1)\n        dp[0] = True\n        for i in range(1, len(word) + 1):\n            for j in range(i):\n                if dp[j] and word[j:i] in pattern:\n                    dp[i] = True\n                    break\n        return dp[-1]\n\n    optimal_distribution = {}\n    disconnections = []\n    all_zones = sports_data['zones']\n    existing_portals = sports_data['portals']\n    rules = sports_data['rules']\n    for zone in all_zones:\n        optimal_distribution[zone] = []\n    for player in players:\n        best_zone = None\n        best_score = 0\n        for zone in players[player]:\n            current_score = players[player][zone]\n            if current_score > best_score:\n                best_zone = zone\n                best_score = current_score\n        optimal_distribution[best_zone].append(player)\n    for portal, rule in rules.items():\n        if not can_break(player_identifier, rule):\n            disconnections.append(portal)\n    return {'distribution': optimal_distribution, 'disconnections': disconnections}", "test": "def check(candidate):\n    players = ['alice1', 'bob22', 'charlie333']\n    sports_data = {\n        'zones': ['basketball', 'soccer', 'hockey'],\n        'portals': [('basketball', 'soccer'), ('soccer', 'hockey')],\n        'rules': {('basketball', 'soccer'): 'ba*so', ('soccer', 'hockey'): 'so*ho'}\n    }\n    result = candidate(players, sports_data)\n    assert type(result) is dict\n    assert 'distribution' in result\n    assert 'disconnections' in result\n    assert len(result['disconnections']) == 1\n    assert len(result['distribution']) == 3\n    assert 'alice1' in result['distribution']['soccer']\n    assert 'bob22' in result['distribution']['basketball']\n    assert 'charlie333' in result['distribution']['hockey']", "entry_point": "optimal_athlete_composition", "extra_info": {"cover_story_words": ["sports", "portal"], "topics": ["Minimum Cut Problem", "Word Break"], "cleaned_prompt": "You are an analytics expert tasked with configuring optimal compositions for athletes in a new game. The game, played in different zones, requires you to distribute players optimizing their skills. Additionally, determine if repositioning by cutting portal relations could strategically disadvantage opposing teams.", "warnings": ["Solution failed correctness check.", "5, Unclear Definition: The outline for the 'rules' dictionary in 'sports_data' is inadequately defined. The values are supposed to be \"strings describing word break rules\" but the format and interpretation of these strings are not explained (e.g., 'ba*so'). This lack of clarity on how word break rules should be interpreted makes it impossible to proceed with any logic related to portal usage.", "4, Unachievable Result: The 'canonical_solution' referencing 'players[player]' suggests each player has a dictionary of zones with associated scores, however, this structure is neither described in the prompt nor included in the example input structure. This mismatch suggests a flaw in either the canonical solution or the problem prompt, leading to possible misinterpretation or errors when writing a solution."]}}
{"task_id": "hard/1", "prompt": "def find_route(map_matrix, start, destination, forbidden_words):\n    \"\"\"\n    Imagine a mythical realm composed of cities linked by bridges, each adorned with inscriptions of whimsical creatures. Your task as an explorer is to chart a route from your starting city to your destination while avoiding any paths inscribed with certain dangerous creatures listed as forbidden words. These mythical creatures' names, if represented on the bridges, signify perilous or impassable paths.\n\n    Your inputs are as follows:\n    - 'map_matrix': a 2D list where cities and their connecting bridges are depicted. Each element is a string, either a city name or a bridge description.\n    - 'start' and 'destination': The cities represented as strings, marking the start and end of your journey.\n    - 'forbidden_words': a list of strings, where each string is a forbidden sequence that, if found within a bridge's description, signals a danger.\n\n    The function must return True if there exists a path from the start city to the destination city that avoids any bridges containing these forbidden words, using techiques related to computer vision and pattern recognition for identifying dangerous sequences. You need to simulate how computer vision would interpret these sequences as images.\n\n    Example:\n    Input: map_matrix = [[\"Alpha\", \"A-B\", \"Beta\"], [\"-\", \"Beta-Obstacle-Omicron\", \"Omicron\"], [\"-\", \"-\", \"Gamma\"]],\n            start = \"Alpha\",\n            destination = \"Gamma\",\n            forbidden_words = [\"Obstacle\"]\n    Output: True, as the path from Alpha to Beta to Omicron to Gamma avoids the dangerous bridge Beta-Obstacle-Omicron containing the forbidden word \"Obstacle\".\n\n    Constraints:\n    - Assume map_matrix forms a valid undirected graph with non-empty strings.\n    - Verify that there is at least one valid path in the optimal solution.\n    \"\"\"", "canonical_solution": "    def is_forbidden(bridge, forbidden_words):\n        for word in forbidden_words:\n            using computer vision techniques, simulate the detection of word in bridge as if analyzed in an image\n            if simulated_detection_based_on_cv(bridge, word):\n                return True\n        return False\n\n    def find_paths(current, destination, visited, path):\n        if current == destination:\n            return [path]\n        if current in visited:\n            return []\n        visited.add(current)\n        result = []\n        for next_city, bridge in graph[current].items():\n            if not is_forbidden(bridge, forbidden_words):\n                result.extend(find_paths(next_city, destination, visited.copy(), path + [next_city]))\n        return result\n\n    create_graph_based_on_map_matrix()\n    return bool(find_paths(start, destination, set(), [start]))", "test": "def check(candidate):\n    assert candidate([[\"Atlantis\", \"A-C\", \"Centuros\"], [\"-\", \"Centuros-Cirrus-Obstacle\", \"Cirrus\"], [\"-\", \"-\", \"Nimbus\"]], \"Atlantis\", \"Nimbus\", [\"Obstacle\"]) == False\n    assert candidate([[\"Alpha\", \"A-B\", \"Beta\"], [\"-\", \"Beta-Obstacle-Omicron\", \"Omicron\"], [\"-\", \"-\", \"Gamma\"]], \"Alpha\", \"Gamma\", [\"Obstacle\"]) == True\n    assert candidate([[\"Triton\", \"T-K\", \"Kraken\"], [\"-\", \"Kraken-K-Obstacle\", \"Cumulus\"]], \"Triton\", \"Cumulus\", [\"K-\"]) == False\n    assert candidate([[\"Oasis\", \"O-E\", \"Echo\"], [\"-\", \"Echo-Epsilon-Obstacle\", \"Vista\"], [\"-\", \"-\", \"Vista-V-Oasis\"]], \"Oasis\", \"Vista\", [\"Void\"]) == True\n    assert candidate([[\"Zenith\", \"Z-P\", \"Pinnacle\"], [\"-\", \"Pinnacle-Pride-Zero\", \"Zero\"]], \"Zenith\", \"Zero\", [\"Danger\"]) == True", "entry_point": "find_route", "extra_info": {"cover_story_words": ["lost city", "cloud city"], "topics": ["Detect Cycle in Graph", "Word Search"], "cleaned_prompt": "Write a function that, given a map of cities, a start and a destination city, and a list of forbidden words, returns True if there is a safe path from the start to the destination avoiding any dangerous bridges with forbidden words, otherwise False. Treat names as sequences of characters. Example: Input: map_matrix = [[\"Alpha\", \"A-B\", \"Beta\"], [\"-\", \"Beta-Bridge-Omicron\", \"Omicron\"], [\"-\", \"-\", \"Gamma\"]], start = \"Alpha\", destination = \"Gamma\", forbidden_words = [\"Bridge\"] Output: True.", "warnings": ["Solution failed correctness check.", "5, Unrealistic technical requirements: The prompt describes a requirement to use \"computer vision and pattern recognition\" techniques for analyzing if a string contains forbidden words within a bridge description. This application is practically misplaced as the problem is inherently a text-based or string analysis problem, not an image or pattern recognition problem. This could confuse participants about the expectations and requirements of the problem."]}}
