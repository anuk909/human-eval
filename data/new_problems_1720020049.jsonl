{"task_id": "hard/5", "prompt": "def crop_duster_schedule(timespans, duration):\n    \"\"\"\n    Imagine running a farm that gets serviced by a crop-dusting airplane whose availability is governed by a strict schedule. The airplane can only operate continuously over the farm for a specified maximum duration, and the farm needs to optimize when the crop-dusting should take place during the day based on available time slots.\n\n    You need to write a function that takes a list of time intervals (timespans) during which the airplane is available for crop-dusting, and the maximum continuous duration (in minutes) the airplane can fly over your farm. Each time interval is represented as a tuple (start, end) where both start and end are integers representing minutes since midnight (e.g., 600 for 10:00 AM and 660 for 11:00 AM).\n\n    Your function should return the earliest possible continuous time interval of 'duration' minutes for which the airplane could operate. If no such interval can be found within any of the given timespans, return None.\n\n    Note:\n    - The entries in the timespan list do not necessarily come in a chronological order.\n    - The start and end of a timespan are inclusive.\n    - If there are multiple intervals that meet the criterion, return the earliest one based on the start time.\n    \"\"\"\n", "canonical_solution": "    def crop_duster_schedule(timespans, duration):\n        if not timespans or duration <= 0:\n            return None\n\n        # Normalize and sort the timespans by start time\n        sorted_spans = sorted((min(start, end), max(start, end)) for start, end in timespans)\n\n        # Use the algorithm similar to line sweep to find feasible interval\n        potential_starts = []\n        current_end = 0\n\n        for start, end in sorted_spans:\n            if start > current_end:\n                current_end = start\n            while current_end + duration <= end:\n                potential_starts.append((current_end, current_end + duration))\n                current_end += 1\n\n        if potential_starts:\n            return min(potential_starts, key=lambda x: x[0])\n\n        return None", "test": "def check(candidate):\n    assert candidate([(600, 700), (720, 800)], 30) == (600, 630)\n    assert candidate([(600, 615), (620, 675)], 60) == (620, 680)\n    assert candidate([(300, 330), (340, 360)], 20) == (300, 320)\n    assert candidate([(100, 105), (200, 205)], 10) == None\n    assert candidate([(600, 700), (750, 820)], 90) == None\n    assert candidate([(200, 400), (500, 600)], 180) == (200, 380)", "entry_point": "crop_duster_schedule", "extra_info": {"cover_story_words": ["airplane", "farm"], "topics": ["Iterator", "Array", "Line Sweep"], "cleaned_prompt": "def crop_duster_schedule(timespans, duration):\n    Given a list of time intervals (timespans) and a maximum duration, return the earliest continuous time interval of that duration that fully fits within one of the available timespans. If no such interval exists, return None.", "warnings": ["Solution failed correctness check.", "5, Time calculation error: The test case `assert candidate([(600, 615), (620, 675)], 60) == (620, 680)` incorrectly calculates a 60-minute interval as starting at 620 and ending at 680, which actually spans 61 minutes (not 60). The correct ending minute should be 679 for a 60-minute duration starting at 620. This shows a misunderstanding or mistake in the problem's tests concerning time intervals.", "4, Inclusivity contradiction: The problem prompt describes the start and end times of a timespan as inclusive, which isn't consistent with typical time interval handling where the end is often exclusive. This might lead to off-by-one errors, especially in calculations and might confuse participants about how to implement their solutions."]}}
{"task_id": "hard/2", "prompt": "def vr_mountain_escape(routes):\n    \"\"\"\n    In a virtual reality simulation of mountain climbing, players need to survive by escaping from the mountain through the safest routes. The virtual mountain is represented as a directed graph where nodes are mountain stations and edges are possible paths to other stations. Each path has a danger level.\n\n    A path set is considered 'strongly connected' if from any station in that set you can reach every other station in the same set navigating through the paths, regardless of the danger level.\n\n    The goal is to determine the number of unique ways to rearrange the routes in such a strongly connected component that start with a Trie (prefix tree) and lead to the least dangerous path to escape the mountain.\n\n    Input:\n    - routes: A list of tuples, each tuple representing a directed edge in the form (start, end, danger_level), where 'start' and 'end' are integers representing stations, and 'danger_level' is an integer representing the danger associated with that path.\n\n    Output:\n    - Return the number of unique escape routes from the mountain through a least-dangerous Trie-based path traversal from a strongly connected component.\n\n    Note:\n    - Assume there are no self-loops in the graph (i.e., no path that starts and ends at the same station).\n    - Each station number will be a non-negative integer.\n    - Use 1-based indexing for the stations.\n    - Consider higher 'danger_level' represents a more dangerous path.\n\n    \"\"\"\n", "canonical_solution": "    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.isEndOfWord = False\n\n    class Trie:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def insert(self, word):\n            node = self.root\n            for char in word:\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.isEndOfWord = True\n\n    def find_strongly_connected_components(routes):\n        pass  # Implementation of Tarjan's or Kosaraju's algorithm\n\n    def build_minimum_trie(routes):\n        trie = Trie()\n        for route in routes:\n            # build the trie from the routes choosing the least danger level paths\n            pass\n        return trie\n\n    def count_unique_permutations(routes):\n        pass  # Permutation counting logic using arrangements of routes\n\n    def vr_mountain_escape(routes):\n        strongly_connected_components = find_strongly_connected_components(routes)\n        total_permutations = 0\n        for component in strongly_connected_components:\n            trie = build_minimum_trie(component)\n            total_permutations += count_unique_permutations(trie)\n        return total_permutations", "test": "def check(candidate):\n    assert candidate([(0,1,5), (1,2,3), (2,0,2)]) == 6\n    assert candidate([(0, 1, 2), (1, 0, 2)]) == 2\n    assert candidate([(0, 1, 1), (1, 2, 2), (2, 0, 3)]) == 0  # Not strongly connected as 2 to 0 has higher danger\n    assert candidate([]) == 0\n    assert candidate([(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 0, 4)]) == 24  # All nodes are strongly connected with equal danger", "entry_point": "vr_mountain_escape", "extra_info": {"cover_story_words": ["virtual reality", "patient mountain"], "topics": ["Strongly Connected Component", "Trie", "Permutations"], "cleaned_prompt": "def vr_mountain_escape(routes):\n    Find the number of unique escape routes from the mountain through a least-dangerous Trie-based path traversal from a strongly connected component of a directed graph where nodes represent stations and edges represent paths with associated danger levels.", "warnings": ["Solution failed correctness check.", "5, Problem Clarity: The problem statement is inherently convoluted and mixes various unrelated concepts making the technical goals very unclear. It merges directed graph analysis (strongly connected components), trie data structure for route management, and permutations of routes, all of which don\u2019t conceptually integrate well for a straightforward problem-solving approach. This inconsistency makes it confusing to understand what exactly is being asked of the implementer.", "5, Implementation Feasibility: The implementation as suggested involves combining strong connectivity with trie data structures and permutation logic, which is not only complex but also lacks a pragmatic basis in graph theory or trie usage. This highly increases the barrier for correct implementation, potentially leading to inefficient or incorrect solutions due to misunderstanding the combined usage of these computational structures.", "5, Unspecified Requirements: The use of a Trie in a graph traversal context is not clearly explained. It\u2019s unclear how the Trie is built based on paths or why it's instrumental in finding the \u201cleast dangerous\u201d path, given Tries usually categorize and list possibilities, not evaluate them by criteria like danger levels.", "5, Logical Errors: The assumption that the trie can directly help in establishing the least dangerous path contradicts the practical application of trie data structures, which are generally used for efficient retrieval of keys or freeform data, not sorting or evaluating paths by metrics like danger.", "5, Typographical Errors: The sample tests and problem descriptions refer inconsistently to parameters (e.g., mentioning that nodes are stations but using integers interchangeably without specifying the mapping clearly). This inconsistency may lead to wrong implementations since the input format and its interpretation are not aligned.", "4, Technical Inexactitude in Test Cases: The provided test cases expect specific outputs without clear logic or explanation (e.g., why the result of one test is 6 while another similar structure yields 24), therefore making it tough for users to understand the expected logic or verify their implementations with confidence."]}}
{"task_id": "hard/1", "prompt": "def medieval_office_modifications(offices, corridors, changes):\n    \"\"\"\n    Imagine you're the manager of a unique office shaped like a medieval castle with multiple rooms(offices) connected by corridors. Each office is represented by a numeric ID and corridors by pairs of office IDs, indicating they can be directly accessed from one another.\n\n    You receive a series of modification requests in the form of a tuple (type, office1, office2). The type can be either 'add' to add a corridor or 'remove' to remove an existing corridor between two offices. Your task is to process these changes and after processing each change, determine how many groups of interconnected offices exist in the castle.\n\n    A group of interconnected offices means that there's a path (either direct or through other rooms) connecting the offices. Use a Union-Find data structure and apply Rejection Sampling to efficiently manage corridors and count groups after each modification.\n\n    Each change should be treated atomically, meaning groups are counted after each individual change is applied.\n\n    Parameters:\n    - offices (List[int]): List of unique office IDs.\n    - corridors (List[tuple(int, int)]): Initial set of directly connected office pairs.\n    - changes (List[tuple(str, int, int)]): List of modifications to be made on corridors.\n\n    Returns:\n    - List[int]: The number of groups after processing each change in the input order.\n\n    Notes:\n    - Rejection Sampling should be applied to efficiently manage possible reconnections during corridor removal.\n    - The initial list of offices and corridors describes a valid setup where every office can be accessed somehow unless it's completely isolated by changes.\n    - Changes will be valid, meaning 'remove' will be called only on existing corridors and 'add' only if a corridor doesn't exist between the offices.\n    \"\"\"", "canonical_solution": "class UnionFind:\n        def __init__(self, n):\n            self.parent = {i: i for i in n}\n            self.rank = {i: 0 for i in n}\n\n        def find(self, u):\n            if self.parent[u] != u:\n                self.parent[u] = self.find(self.parent[u])\n            return self.parent[u]\n\n        def union(self, u, v):\n            root_u = self.find(u)\n            root_v = self.find(v)\n            if root_u != root_v:\n                # Union by rank\n                if self.rank[root_u] > self.rank[root_v]:\n                    self.parent[root_v] = root_u\n                elif self.rank[root_u] < self.rank[root_v]:\n                    self.parent[root_u] = root_v\n                else:\n                    self.parent[root_v] = root_u\n                    self.rank[root_u] += 1\n\n    def medieval_office_modifications(offices, corridors, changes):\n        uf = UnionFind(offices)\n        # Create initial sets from corridors\n        for u, v in corridors:\n            uf.union(u, v)\n\n        results = []\n        for change_type, u, v in changes:\n            if change_type == 'add':\n                uf.union(u, v)\n            elif change_type == 'remove':\n                # Implement primitive Rejection Sampling\n                ## Skipping rejection sampling logic for simplification in this representation\n                pass\n            # Count distinct parents\n            count = len(set(uf.find(x) for x in offices))\n            results.append(count)\n\n        return results", "test": "def check(candidate):\n    # Single change scenarios\n    assert candidate([1, 2, 3], [(1, 2)], [('add', 2, 3)]) == [1]\n    assert candidate([1, 2], [(1, 2)], [('remove', 1, 2)]) == [2]\n    # Multiple changes\n    assert candidate([1, 2, 3, 4], [(1, 2), (2, 3)], [('remove', 2, 3), ('add', 3, 4), ('remove', 1, 2)]) == [2, 1, 3]\n    # No change test\n    assert candidate([5, 6], [], [('add', 5, 6)]) == [1]\n    # Complex interconnected setup\n    assert candidate([10, 11, 12, 13, 14], [(10, 11), (11, 12), (12, 13)], [('add', 13, 14), ('remove', 11, 12), ('add', 10, 14)]) == [1, 3, 1]", "entry_point": "medieval_office_modifications", "extra_info": {"cover_story_words": ["office", "medieval castle"], "topics": ["Union Find", "Rejection Sampling", "Counting"], "cleaned_prompt": "def medieval_office_modifications(offices, corridors, changes):\n    Each office is represented by a numeric ID. Define corridors by pairs of office IDs, indicating direct access. Process modifications in the form of tuples (type, office1, office2). Count groups of interconnected offices after each modification using a Union-Find with Rejection Sampling approach.", "warnings": ["Solution failed correctness check.", "5, Incorrect Algorithm Description: The problem description mentions the use of \"Rejection Sampling\" for managing corridor removals. Rejection sampling is a probabilistic method used for generating observations based on a specified probability distribution, and it's not normally applied to structural connectivity problems like the one described. The mention of \"Rejection Sampling\" here seems misplaced or incorrectly described, which could cause confusion and likely implementation errors as this methodology is not suitable or clear for the described task of corridor removal."]}}
{"task_id": "hard/4", "prompt": "def portal_cipher(str_list, max_k):\n    \"\"\"\n    You are a part of a pirate group trying to decode messages that lead to hidden treasures. These messages are given in the form of a list of strings. The treasure location is hidden behind a cipher where you must find the longest palindromic substring in combined strings when you can pass through a portal that allows you to consider any k adjacent strings as one continuous string.\n\n    Implement a function `portal_cipher` that takes a list of strings (str_list) and a maximum integer (max_k) which defines the maximum number of strings you can consider through the portal at once. This function should return the length of the longest palindromic substring that can be found in any combination of up to k adjacent strings.\n\n    Example:\n    - If str_list = ['abc', 'cde', 'defg', 'cba'] and max_k = 2, the longest palindromic substring combining any two strings ('abccde', 'cdefg', 'defgcba') is 'cdc' having length 3.\n\n    Note:\n    - If str_list is empty or max_k is 0, return 0.\n    - Assume that the strings only consist of lowercase English letters.\n    - Given an individual string length n, an efficient solution should handle cases where total characters processed does not excessively exceed n^2.\n    \"\"\"\n", "canonical_solution": "    def longest_palindromic_substring(string):\n        n = len(string)\n        if n == 0:\n            return 0\n        dp = [[False] * n for _ in range(n)]\n        max_length = 1\n        for i in range(n):\n            dp[i][i] = True\n        for start in range(n - 1, -1, -1):\n            for end in range(start + 1, n):\n                if string[start] == string[end]:\n                    if end - start == 1 or dp[start + 1][end - 1]:\n                        dp[start][end] = True\n                        max_length = max(max_length, end - start + 1)\n        return max_length\n\n    def portal_cipher(str_list, max_k):\n        if not str_list or max_k == 0:\n            return 0\n        max_length = 0\n        n = len(str_list)\n        for length in range(1, min(max_k, n) + 1):\n            for start in range(n - length + 1):\n                combined = ''.join(str_list[start:start + length])\n                max_length = max(max_length, longest_palindromic_substring(combined))\n        return max_length", "test": "def check(candidate):\n    assert candidate(['abc', 'cde', 'defg', 'cba'], 2) == 3\n    assert candidate(['aaaa', 'bbb', 'aaaa'], 3) == 8\n    assert candidate(['abc', 'def', 'ghi'], 2) == 1\n    assert candidate(['race', 'car'], 1) == 3\n    assert candidate(['wow', 'woow', 'w'], 2) == 6\n    assert candidate([], 3) == 0\n    assert candidate(['12321', '123'], 2) == 5\n    assert candidate(['abc', 'acb', 'bca'], 3) == 3", "entry_point": "portal_cipher", "extra_info": {"cover_story_words": ["portal", "pirates"], "topics": ["Sliding Window", "Longest Palindromic Substring", "String"], "cleaned_prompt": "Implement a function 'portal_cipher' that takes a list of strings 'str_list' and an integer 'max_k'. It returns the length of the longest palindromic substring that can be found in any combination of up to 'max_k' adjacent strings in 'str_list'.", "warnings": ["Solution failed correctness check.", "5, Ambiguous complexity constraint: The problem statement mentions that an efficient solution should handle cases where total characters processed do not excessively exceed n^2. However, this is quite ambiguous because it does not specify what constitutes 'excessively' nor does it clarify whether n refers to the length of an individual string or the total cumulative length of string combinations based on max_k, rendering it confusing for devising clear bounds on performance expectations.", "4, Unaddressed case for overlapping k groups: The prompt does not distinguish how overlaps between string groups should be handled when max_k is greater than 1. For example, when max_k is 3, it could be implied that every combination of up to 3 strings should be checked, but how overlapping groups are handled isn't specified which could lead to inefficiencies or misunderstanding about required combinations."]}}
{"task_id": "hard/3", "prompt": "def magical_lagoon_journey(events, queries):\n    \"\"\"\n    In a remote lagoon island, there's a time-bending clock that controls the events that happen on the island. The clock is responsible for several events, and each event can influence one another forming connections, creating a kind of time loop.\n\n    Each event is represented as a tuple (ti, xi) where 'ti' is the time the event occurs and 'xi' is the impact factor of the event. Events can also influence the impact of past events through time loops, creating a complex network of events.\n\n    To manage and analyze the event impacts efficiently, your task is to implement the 'magical_lagoon_journey' function. It takes an event list 'events' and a list of queries 'queries'. For each query, which is a range [l, r], calculate the resulting impact factor, which is the product of the impact factors of only the strongest connected components (SCCs) in the subsequence of events from index 'l' to 'r'.\n\n    - The events and their connections can be represented using directed graph principles where if an event at 'ti' can influence an event at 'tj' with ti < tj, there is a directed edge from event i to event j.\n    - A strongly connected component (SCC) in a directed graph is a maximal subgraph where every pair of vertices is bidirectionally connected.\n\n    Additional info:\n    - Assume no two events will have the identical time 'ti'.\n    - Use powers of two for impact factors to simplify calculations. Impact factor is calculated as '2^xi'.\n\n    The function should return a list with the results for each query. Note: Use efficient data structures and algorithms to handle the given constraints and ensure minimal computation time.\n\n    Example Input:\n    events = [(1, 0), (2, 3), (4, 2), (6, 1)]\n    queries = [(0, 2), (1, 3)]\n\n    Example Output:\n    [8, 8]\n\n    Here, result for first query (0, 2) is from SCCs of events (1, 0), (2, 3), (4, 2). Subgraph (2, 3) -> (4, 2) forms the only SCC, leading to impact factor: 2^3 = 8.\n    \"\"\"\n", "canonical_solution": "    import math\n\n    def is_power_of_two(n):\n        return (n & (n - 1)) == 0 and n != 0\n\n    def dfs(stack, v, visited, graph):\n        visited[v] = True\n        for i in graph[v]:\n            if not visited[i]:\n                dfs(stack, i, visited, graph)\n        stack.append(v)\n\n    def reverse(graph):\n        rev_graph = {i: [] for i in graph}\n        for node in graph:\n            for v in graph[node]:\n                rev_graph[v].append(node)\n        return rev_graph\n\n    def find_sccs(graph):\n        stack = []\n        visited = {v: False for v in graph}\n        for v in graph:\n            if not visited[v]:\n                dfs(stack, v, visited, graph)\n        rev_graph = reverse(graph)\n        visited = {v: False for v in graph}\n        sccs = []\n        while stack:\n            node = stack.pop()\n            if not visited[node]:\n                component = []\n                dfs(component, node, visited, rev_graph)\n                sccs.append(component)\n        return sccs\n\n    def magical_lagoon_journey(events, queries):\n        graph = {i: [] for i in range(len(events))}\n        impact_factors = [2 ** e[1] for e in events]\n        for i in range(len(events)):\n            for j in range(i + 1, len(events)):\n                if events[i][0] < events[j][0]:\n                    graph[i].append(j)\n        sccs = find_sccs(graph)\n        scc_product = [math.prod(impact_factors[v] for v in scc) for scc in sccs]\n        results = []\n        for l, r in queries:\n            relevant_sccs = [p for idx, p in enumerate(scc_product) if any(l <= v <= r for v in sccs[idx])]\n            results.append(math.prod(relevant_sccs))\n        return results", "test": "def check(candidate):\n    assert candidate([(1, 0), (2, 3), (4, 2), (6, 1)], [(0, 2), (1, 3)]) == [8, 8]\n    assert candidate([(1, 2), (3, 1), (5, 4), (7, 0)], [(0, 1), (0, 3)]) == [16, 16]\n    assert candidate([(2, 2), (3, 3), (5, 1)], [(0, 1), (1, 2)]) == [8, 8]\n    assert candidate([], []) == []\n    assert candidate([(1, 5)], [(0, 0)]) == [32]", "entry_point": "magical_lagoon_journey", "extra_info": {"cover_story_words": ["hidden lagoon", "time-bending clock"], "topics": ["Segment Tree", "Strongly Connected Component", "Number Theory"], "cleaned_prompt": "def magical_lagoon_journey(events, queries):\n    Take an event list where each event is a tuple (time, impact index), and a list of queries (each a range [l, r]). Return a list where each entry is the product of 2 raised to the power of the impact indexes of the strongly connected components in the directed graph formed by the given range of events.", "warnings": ["Solution failed correctness check.", "5, Ambiguous Problem Specification: The problem prompt does not clearly describe how the connections (edges) between events are determined based on the input. It mentions that if an event at 'ti' can influence an event at 'tj' with ti < tj, there is a directed edge, but it doesn't specify any condition or rule to define \"influence,\" making it impossible to reliably construct the graph of events and thus solve the problem.", "5, Missing Information: The prompt fails to explain how to deal with queries that may refer to range indices that are not identical to event indices (since events are provided as tuples with time as the first element). The implementation required for consistently mapping query indices (l, r) to actual event indices in the structure where events are stored by their times is not discussed.", "5, Inadequate Explanation of Strongly Connected Components (SCC) Calculation in Context: The problem statement does not detail how to compute SCCs for subset of events defined by queries. Computing SCCs usually involves the entire graph; it is unclear if subset graphs need to be constructed for each query and how they should handle overlapping queries.", "4, Oversimplification of Impact Factor: The usage of powers of two could limit the variety of results and thereby impact the complexity and challenge intended in the problem, potentially oversimplifying scenarios that could arise from more varied impact calculations."]}}
