{"task_id": "hard/3", "prompt": "def dragon_sightings_median(operations):\n    \"\"\"\n    A robotic theme park filled with dragons has a special system to track the spotting of dragons. Each dragon sighting is marked with its X-coordinate on a 1D stretch of the park which ranges from 0 to 2000 units.\n    Since it's hard to calculate the median on the fly as the sightings are continuously monitored, you are tasked to develop a system to track and provide the median sighting position effectively after each operation.\n\n    The operations will be provided as a list of tuples where each tuple can be either:\n    - ('add', X), meaning a new sighting is added at point X, or\n    - ('get_median',), which requests the current median of all sightings added until then.\n\n    The median is the middle value in an array of numbers. If there are an even number of numbers, the median is taken as the average of the two middle numbers.\n\n    Note):\n    - Use bucket sort-like techniques, given the limited range of possible sighting positions (0 to 2000).\n    - Ensure efficient operations for both adding sightings and retrieving the median.\n\n    Examples:\n    - If operations = [('add', 1000), ('get_median',)] -> returns [1000.0]\n    - If operations = [('add', 500), ('add', 1500), ('get_median',)] -> returns [1500.0]\n\n    Return a list of the results for all 'get_median' operations in the order they are requested.\n    \"\"\"\n", "canonical_solution": "    def dragon_sightings_median(operations):\n        limits = 2001\n        buf = [0] * limits\n        count = 0\n\n        def add(val):\n            buf[val] += 1\n            nonlocal count\n            count += 1\n\n        def get_median():\n            mid_index = (count + 1) // 2\n            current = 0\n            for i in range(limits):\n                current += buf[i]\n                if count % 2 == 1:\n                    if current >= mid_index:\n                        return float(i)\n                else:\n                    if current == mid_index:\n                        for j in range(i + 1, limits):\n                            if buf[j] > 0:\n                                return (i + j) / 2.0\n                    elif current > mid_index:\n                        if current - buf[i] < mid_index:\n                            return float(i)\n                        \n        result = []\n        for operation in operations:\n            if operation[0] == 'add':\n                add(operation[1])\n            elif operation[0] == 'get_median':\n                result.append(get_median())\n        return result", "test": "def check(candidate):\n    assert candidate([('add', 1000), ('get_median',)]) == [1000.0]\n    assert candidate([('add', 500), ('add', 1500), ('get_median',)]) == [1000.0]\n    assert candidate([('add', 0), ('add', 0), ('add', 2000), ('add', 2000), ('get_median',)]) == [1000.0]\n    assert candidate([('add', 50), ('add', 50), ('add', 80), ('get_median',), ('add', 100), ('get_median',)]) == [60.0, 65.0]\n    assert candidate([('add', 100), ('add', 700), ('add', 800), ('add', 900), ('add', 1600), ('get_median',)]) == [800.0]", "entry_point": "dragon_sightings_median", "extra_info": {"cover_story_words": ["dragons", "robotic theme park"], "topics": ["Find Median from Data Stream", "Geometry", "Bucket Sort"], "cleaned_prompt": "Write a function that simulates tracking dragon sightings in a robotic theme park. It takes a list of operations about additions of sightings and requests for the median sighting position, processing them effectively.\n\nExample:\n- operations = [('add', 1000), ('get_median',)]: return [1000.0]\n- operations = [('add', 500), ('add', 1500), ('get_median',)]: return [1000.0]\n\nEach sighting is reported with an X-coordinate ranging from 0 to 2000. Use bucket sort to handle sightings and efficiently compute the median as requested.", "warnings": ["Solution failed correctness check.", "5, Inconsistent Result Examples: The provided example results in the problem description do not match the outcomes specified in the testing assertions. This discrepancy creates confusion about what the correct output should be. For instance, the problem statement example [('add', 500), ('add', 1500), ('get_median',)] suggests a result of [1500.0], whereas the test asserts it should be [1000.0]. Similarly, the example for operations with values 50, 50, 80, 100 does not align well with both expected and asserted medians.", "4, Ambiguous Problem Statement: The problem statement implies the use of bucket sort for performance efficiency but does not clearly define how to handle large numbers of operations efficiently, especially with frequent median calculations. While it mentions a range limitation (0 to 2000), it does not provide a clear directive or suggestion on how to manage or optimize multiple 'add' operations followed by 'get_median' operations without causing performance degradation."]}}
{"task_id": "hard/5", "prompt": "def find_secret_artifacts(locations, connections, photos):\n    \"\"\"\n    In a remote arctic monastery near the north pole, there are several sacred locations scattered across the area where ancient artifacts are hidden. These locations are identified by coordinates on a 2D plane. The connections between locations are provided which indicate paths that need to be cleared of snow to access the artifacts. Each connection is bidirectional.\n\n    As a part of an initiation ritual, scholars need to find out if it's possible to clear a path to collect all artifacts from all the sacred locations. The monastery uses ancient blueprints (represented as photos), which are noisy binary images (0s and 1s) representing large artifacts. Each image corresponds to one location, and major artifacts appear as large connected components of 1s in the image.\n\n    To determine if a complete path can be established, use the following methods:\n    - Use Kosaraju\u2019s Algorithm to check if all locations are strongly connected when considering the given `connections`.\n    - Use a Line Sweep Algorithm to determine the complexity of each area around the locations based on the number of major artifacts identified in the photos using a Computer Vision connected components algorithm.\n    - Store the analysis results efficiently using a Bloom Filter to filter locations with major artifacts for quick checks.\n\n    Implement the function such that it returns True if it is possible to establish a complete path to collect all artifacts (assuming that Kosaraju's and Line Sweep results are favorable) and False otherwise.\n\n    Example:\n    locations = [(0,0), (2,3), (5,5)]\n    connections = [(0, 1), (1, 2)]\n    photos = [\n        [[0, 1], [1, 1]], # Photo for location 0\n        [[1, 0], [0, 0]], # Photo for location 1\n        [[0, 0], [0, 1]]  # Photo for location 2\n    ]\n    The function should return True since there is a direct path covering all locations and at least one major artifact can be detected from the photos.\n    \"\"\"\n", "canonical_solution": "    import cv2\n    import numpy as np\n    from scipy.sparse.csgraph import csgraph_from_dense, connected_components\n\n    def is_strongly_connected(connections, num_locations):\n        matrix = np.zeros((num_locations, num_locations), dtype=int)\n        for conn in connections:\n            matrix[conn[0], conn[1]] = 1\n            matrix[conn[1], conn[0]] = 1\n        graph = csgraph_from_dense(matrix, null_value=0)\n        n_components, labels = connected_components(graph, connection='strong')\n        return n_components == 1\n\n    def detect_major_artifacts(photo):\n        # Using connectedComponentsWithStats to find blobs\n        _, _, stats, _ = cv2.connectedComponentsWithStats(np.array(photo, dtype=np.uint8))\n        # Considering a blob major if it has area > 1\n        major_artifacts = sum(1 for _, _, _, _, area in stats[1:] if area > 1)\n        return major_artifacts > 0\n\n    def check_bloom_filter(locations, photos, bf_size=1000):\n        bloom_filter = set()\n        major_found = False\n        # Assuming simple hash function for bloom filter\n        hash_func = lambda x: hash(x) % bf_size\n        for loc, photo in zip(locations, photos):\n            if detect_major_artifacts(photo):\n                bloom_filter.add(hash_func(loc))\n                major_found = True\n        return major_found\n\n    def find_secret_artifacts(locations, connections, photos):\n        if not is_strongly_connected(connections, len(locations)):\n            return False\n        if not check_bloom_filter(locations, photos):\n            return False\n        return True", "test": "def check(candidate):\n    # Test cases will reflect the complexity and cover different scenarios including edge and generic cases.\n\n    # All locations are connected and at least one major artifact is detected\n    assert candidate([(0,0), (2,2), (3,4)], [(0, 1), (1, 2)], [[[0,1],[1,1]], [[0,0],[0,1]], [[1,0],[1,1]]]) is True\n\n    # Locations are not strongly connected\n    assert candidate([(0,0), (10,10), (20,20)], [(0, 1)], [[[1,0],[0,1]], [[0,1],[1,0]], [[1,1],[1,1]]]) is False\n\n    # Locations are connected but no major artifacts\n    assert candidate([(0,0), (5,5), (10,10)], [(0, 1), (1, 2)], [[[0,0],[0,0]], [[0,0],[0,0]], [[0,0],[0,0]]]) is False\n\n    # Only one location with everything as an artifact\n    assert candidate([(0,0)], [], [[[1,1],[1,1]]]) is True\n\n    # Dense connectivity and multiple major artifacts\n    assert candidate([(0,0), (2,2), (5,5), (10,10)], [(0, 1), (1, 2), (2, 3), (3, 0)], [[[0,1],[1,1]], [[1,1],[1,1]], [[1,0],[1,1]], [[1,1],[1,1]]]) is True", "entry_point": "find_secret_artifacts", "extra_info": {"cover_story_words": ["mystic monastery", "arctic"], "topics": ["Line Sweep", "Kosaraju's Algorithm", "Bloom Filter"], "cleaned_prompt": "Determine if all sacred locations in a remote arctic monastery can be strongly interconnected for initiating access to artifacts using Kosaraju\u2019s Algorithm, Line Sweep Algorithm, and Bloom Filters.\nExample:\nlocations = [(0,0), (2,3), (5,5)]\nconnections = [(0, 1), (1, 2)]\nphotos = [\n    [[0, 1], [1, 1]], # Photo for location 0\n    [[1, 0], [0, 0]], # Photo for location 1\n    [[0, 0], [0, 1]]  # Photo for location 2\n]\nReturn True or False denoting if artifact paths can be entirely connected and major artifacts are detected at these coordinates.", "warnings": ["Solution failed correctness check.", "4, Misaligned Algorithms: The problem statement introduces three separate algorithms (Kosaraju's Algorithm for strong connectivity, Line Sweep Algorithm for artifact detection complexity, and Bloom Filter for efficient storage) but provides no clear explanation on how these are feasibly integrated within the provided function description. Specifically, the Line Sweep Algorithm's usage is ambiguous as the canonical solution instead uses traditional Computer Vision blob detection which contradicts or does not align with Line Sweep methods typically used for geometric computations rather than image processing tasks.", "5, Lack of Clear Problem Specifications: The problem does not clearly define what constitutes as a \"major artifact\" in images, nor how to quantify or qualify a connection between artifacts and location connectivity for the artifact collection mentioned. Without these critical definitions, implementing the function or understanding the requirements for successful artifact path clearing is vague and open-ended, leading to possible incorrect implementations.", "4, Inconsistent Implementation Details: The use of a Bloom Filter for checking if major artifacts are present is unusual and not typically suitable for this task. Bloom Filters are probabilistic and not typically used for definite data checks (where exact matches are critical) such as confirming the existence of major artifacts, which could lead to incorrect conclusions about artifact presence due to the inherent possibility of false positives in Bloom Filters.", "5, Unrealistic Application of Kosaraju's Algorithm: The task confusingly uses Kosaraju's Algorithm, which is specific for strongly connected components in directed graphs, but the problem context and the example given (using undirected edges) suggest an undirected graph (since each connection is bidirectional), making Kosaraju's application misleading and inappropriate."]}}
{"task_id": "hard/1", "prompt": "def enchanted_garden(grid, start, enchanted_trees):\n    \"\"\"\n    You are on a quest as a Captain sailing on an enchanted lake represented by a 2D grid. Each cell in the grid can be a patch of water (0), your boat (1), or an enchanted tree (2). The grid dimensions are M x N and the grid values are input as a list of lists, where each inner list represents a row.\n\n    Your goal is to plant magical seeds around each enchanted tree to protect your boat. For each enchanted tree, determine the amount of water cells (0) within a 1-cell radius (including diagonals). These spells are cumulative; for overlapping regions around multiple trees, each overlapping cell should count for each tree.\n\n    Furthermore, once the magical seeds are planted, the entire area becomes protected, and your boat should navigate a safe path, prioritizing the shortest path to explore further on the lake. You are to find the maximum flow of protected paths (where your boat can sail safely) from the starting point 'start' (given in (row, col) format) to all other reachable water cells in the grid.\n\n    - The grid is a rectangle, and you can navigate up, down, left, and right to adjacent water cells from your current position. Diagonal movement is not allowed.\n\n    Requirements:\n    - Firstly, compute how many spells need to be placed around each enchanted tree.\n    - Secondly, use this protected area to update the grid marking the maximum flow of protected paths that can be taken from the starting point.\n\n    - The enchanted trees are given in a list of tuples (row_index, col_index).\n\n    Example:\n    Grid: [[0,0,2],[1,0,0],[0,2,0]],\n    Start: (1,0),\n    Enchanted Trees: [(0,2), (2,1)]\n    - Around (0,2), there are 3 water cells.\n    - Around (2,1), there are 4 water cells.\n    - Resulting in a grid where some regions now allow for 7 water cells of maximum flow.\n    \"\"\"\n", "canonical_solution": "    def max_flow(grid, start, enchnted_trees):\n        def is_valid(i, j):\n            return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n        def neighbors(i, j):\n            for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                if is_valid(i+dy, j+dx):\n                    yield i+dy, j+dx\n\n        # Mark the protected area\n        for tree in enchanted_trees:\n            for dy in [-1, 0, 1]:\n                for dx in [-1, 0, 1]:\n                    ni, nj = tree[0]+dy, tree[1]+dx\n                    if is_valid(ni, nj) and grid[ni][nj] == 0:\n                        grid[ni][nj] += 1\n\n        # Implement Maximum Flow from the starting point with newly protected paths\n        # BFS with capacity tracking\n        import queue\n        q = queue.Queue()\n        q.put((start, float('inf')))\n        max_flow = 0\n        while not q.empty():\n            curr, flow = q.get()\n            max_flow = max(max_flow, flow)\n            for n in neighbors(*curr):\n                if grid[n[0]][n[1]] > 0:\n                    q.put((n, min(flow, grid[n[0]][n[1]])))\n        return max_flow", "test": "def check(candidate):\n    assert candidate([[0,0,2],[1,0,0],[0,2,0]], (1,0), [(0,2), (2,1)]) == 7\n    assert candidate([[0,2,0],[1,0,2],[0,0,0]], (0,0), [(0,1), (1,2)]) == 5\n    assert candidate([[2,0,0],[0,0,0],[0,0,2]], (2,1), [(0,0), (2,2)]) == 3\n    assert candidate([[0,2,2],[1,0,0],[0,0,0]], (1,1), [(0,1), (0,2)]) == 8\n    assert candidate([[0,0,0],[2,1,2],[0,0,0]], (1,1), [(1,0), (1,2)]) == 8", "entry_point": "enchanted_garden", "extra_info": {"cover_story_words": ["boat", "enchanted garden"], "topics": ["Memoization", "Maximum Flow Problem", "Kruskal's Algorithm"], "cleaned_prompt": "def enchanted_garden(grid, start, enchanted_trees):\n    \"\"\"\n    You're a Captain an enchanted lake, represented by a 2D grid where you must plant magical seeds around each enchanted tree to protect your boat. Use the grid to compute the number of spells needed around each tree and then calculate the maximum flow of protected paths from your starting point to all water cells. \n    - The grid cells can be water (0), the boat (1), or enchanted trees (2).\n    - The enchanted trees are given as a list of (row_index, col_index) tuples.\n    - You can only navigate up, down, left, and right to adjacent water cells.\n    \"\"\"\n", "warnings": ["Solution failed correctness check.", "5, Unclear Problem Definition: The problem description mixes two possibly unrelated tasks \u2013 calculating the number of spells around each tree and determining the maximum flow of protected paths for navigation. These tasks are not clearly linked in the problem statement, which can confuse participants about the exact requirements and how the tasks relate.", "5, Confusing Output Specification: The output or expected result after the computation is not clearly defined. While it mentions planting seeds around enchanted trees and navigating a boat using maximum protected paths, it does not specify what exactly needs to be returned by the function \u2013 whether it is the number of water cells counted around trees, the grid after marking, or the value of maximum flow of paths.", "4, Overlapping Regions Calculation Ambiguity: It is stated that overlapping regions around multiple trees should each count for cell overlaps. However, there is no clear explanation or formula on how these overlaps should impact the count or flow calculations, which might lead to differing implementations and results based on participant interpretation.", "4, Inconsistent Grid Update Mechanism: The problem suggests that after computing spells around trees, the grid is updated to reflect protected paths. The mechanism and rules for this update are not specified, specifically how spell counts or protected regions affect the allowed pathways for the boat, leading to potential confusion in implementation.", "5, Vague Start and Reachability Explanation: The starting point's role and how the boat\u2019s navigation is affected by the grid\u2019s state after placing spells are vaguely explained. The process or algorithmic requirement to determine the path and handle various grid conditions (e.g., obstructed paths, boundaries) are not clarified, which could lead to different understandings of pathfinding and reachability.", "5, Test Case and Expected Results Mismatch: The example results provided in the test case code section do not squarely align with the description in the problem statement. There seems to be an assumption about how results are derived (e.g., cumulative effects of overlapping spells), but these assumptions are not documented or explained within the prompt.", "5, Terms and Definitions Inconsistency: The canonical function and prompt mention a 'maximum flow' concept, typically a graph theory term, but then use it in a way that appears to equate it with simply the highest number of localized water cells around trees. This misuse or redefinition of established theoretical terms can lead to misunderstandings unless explicitly redefined in the context of the problem."]}}
{"task_id": "hard/4", "prompt": "def arctic_exploration_plans(wizard_schools, paths):\n    \"\"\"\n    In the land of Arctica, there exists a group of wizard schools separated by treacherous paths. The local wizard council needs help to plan for safe exploration among the schools. Each wizard school can be considered as a node and the paths between them as edges of a graph.\n\n    The function 'arctic_exploration_plans' needs to take two parameters:\n    1. wizard_schools: A list of school names (each unique and represented as string).\n    2. paths: A list of tuples (school1, school2) representing a bidirectional path between 'school1' and 'school2'.\n\n    The task is to detect any cycles within this graph and return as subsets the names of schools that are in cycles. For performance efficiency, schools in cycles should be reported as per the regions detected using Red-Black Tree structure for a clever arrangement.\n\n    Also, each subset or 'region' of wizard schools involved in cycles should have a structural hierarchical representation shown as a binary tree. Each tree should be visualized and returned in the form of a string graph.\n\n    Each school is ideally involved in one major cycle for simplicity. Additional output should include the number of unique cycles detected.\n\n    For example, if the input is:\n        wizard_schools = ['A', 'B', 'C', 'D'],\n        paths = [('A', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'D')]\n    The output should be a tuple: ('Region structured as Trees', 1)\n    Here 'Region structured as Trees' is a visual string representation of schools in cycles and '1' represents the number of unique cycles.\n\n    Note: Ensure the solution is efficient in handling the cycle detection and Red-Black tree creation and visualization.\n    \"\"\"\n", "canonical_solution": "import collections\n\n    def has_cycle_util(graph, v, visited, parent):\n        visited.add(v)\n        for neighbour in graph[v]:\n            if neighbour not in visited:\n                if has_cycle_util(graph, neighbour, visited, v):\n                    return True\n            elif parent != neighbour:\n                return True\n        return False\n\n\n    def create_graph(schools, paths):\n        graph = collections.defaultdict(list)\n        for s1, s2 in paths:\n            graph[s1].append(s2)\n            graph[s2].append(s1)\n        return graph\n\n    def detect_cycles(graph, schools):\n        visited = set()\n        cycle_members = set()\n        for school in schools:\n            if school not in visited:\n                if has_cycle_util(graph, school, visited, -1):\n                    cycle_members.add(school)\n        return cycle_members\n\n\n    def visualise_using_red_black_tree(cycle_members):\n        # Implementation Depends on an external library or concept\n        pass\n\n    def arctic_exploration_plans(wizard_schools, paths):\n        graph = create_graph(wizard_schools, paths)\n        cycles = detect_cycles(graph, wizard_schools)\n        tree_visualisation = visualise_using_red_black_tree(cycles)\n        return (tree_visualisation, len(cycles))", "test": "def check(candidate):\n    assert candidate(['A', 'B', 'C', 'D'], [('A', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'D')]) == ('Region structured as Trees', 1)\n    assert candidate(['A', 'B', 'C'], [('A', 'B'), ('B', 'C')]) == ('', 0)\n    assert candidate(['A', 'B', 'C', 'D', 'E'], [('A', 'B'), ('B', 'C'), ('C', 'A'), ('D', 'E'), ('E', 'D')]) == ('Region structured as Trees', 2)\n    assert candidate(['X', 'Y', 'Z'], []) == ('', 0)\n    assert candidate(['A', 'B'], [('A', 'B')]) == ('', 0)", "entry_point": "arctic_exploration_plans", "extra_info": {"cover_story_words": ["arctic", "wizard school"], "topics": ["Red-Black Tree", "Detect Cycle in Graph", "Subsets"], "cleaned_prompt": "Write a function 'arctic_exploration_plans' that takes a list of wizard schools (nodes) and paths (edges) between them and identifies cycles in the graph. The schools involved in these cycles need to be arranged and visualized using a Red-Black Tree, and the output should include a visual representation of these cycles alongside the count of unique cycles detected. \n\nExample: arctic_exploration_plans(['A', 'B', 'C', 'D'], [('A', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'D')]) should return a tuple containing a string representation of the cycles arranged in a Red-Black Tree format and the number of these cycles (1).", "warnings": ["Solution failed correctness check.", "5, Unclear Output Requirements: The problem statement specifies that the output should be a tuple containing a visual string representation of schools in cycles structured as binary trees and the number of unique cycles. However, it does not provide a clear and concise format or any examples for what this visual string representation should look like, which can lead to ambiguity in expected solutions.", "5, Implementation Complexity: The task requires integration of cycle detection in a graph, representation using a Red-Black Tree, and then visualization of this tree. Each of these alone is complex and integrating all can lead to overly complex solutions. Especially, visualizing a tree structure in string format can be inherently complex and is not commonly a practice in typical algorithmic problem-solving contexts.", "5, Unspecified Behavior for Non-Cycle Graph Components: The prompt focuses on detecting cycles and visualizing parts of the graph within cycles. It does not specify what should be done with graph components or schools that do not form part of a cycle. This omission could lead to incomplete or incorrect handling of data, affecting the correctness of implementations.", "4, No Clarification on Red-Black Tree Usage: The task mentions organizing schools in cycles using a Red-Black Tree for 'clever arrangement', but does not explain why this data structure is chosen over others, what properties of Red-Black Trees are being leveraged for this task, or how it specifically benefits the arrangement and visualization process. This lack of justification makes the choice seem arbitrary and confusing."]}}
{"task_id": "hard/2", "prompt": "def alien_laser_trap(matrix, operations):\n    \"\"\"\n    Aliens have taken over a haunted spaceship, and have set up a complex trap system that can only be disabled by correctly manipulating a grid of laser nodes represented by a 2D matrix of integers. Each element of the matrix can either be 0 (laser off) or 1 (laser on).\n\n    Your mission is to disable the maximum number of lasers using a series of operations. Each operation is a bitmask that can be applied to any row or column in the matrix using an XOR operation.\n\n    However, the manipulation must be strategic: to simulate this, you should implement rejection sampling criteria where operations are selectively applied based on a splay tree that stores the historical frequency of every operation's result.\n\n    - 'matrix' is a list of lists, where each sub-list represents a row of the matrix.\n    - 'operations' is a list of integers, representing the available bitmask operations.\n\n    Your job is to find the configuration with the maximum number of zeros after applying any of the available operations to any rows or columns in the best strategic manner.\n\n    For example, if matrix = [[0, 1], [1, 1]] and operations = [1, 2], potential configurations after operations include the original matrix as operations might be rejected based on past attempts logged in a splay tree.\n\n    Please ensure your solution adequately uses the concepts of splay trees, bitmask, and rejection sampling to strategically decide the application of operations to optimize the laser grid shutdown process.\n\n    \"\"\"\n    pass", "canonical_solution": "    class SplayTree:\n        def __init__(self):\n            self.root = None\n\n        class Node:\n            def __init__(self, key, count=1):\n                self.key = key\n                self.count = count\n                self.left = None\n                self.right = None\n                self.parent = None\n\n        def splay(self, node):\n            while node.parent:\n                if node.parent.parent is None:\n                    # Zig rotation\n                    if node.parent.right == node:\n                        self.left_rotate(node.parent)\n                    else:\n                        self.right_rotate(node.parent)\n                elif node.parent.right == node and node.parent.parent.right == node.parent:\n                    # Zig-zig rotation\n                    self.left_rotate(node.parent.parent)\n                    self.left_rotate(node.parent)\n                elif node.parent.left == node and node.parent.parent.left == node.parent:\n                    # Zig-zig rotation\n                    self.right_rotate(node.parent.parent)\n                    self.right_rotate(node.parent)\n                else:\n                    # Zig-zag rotation\n                    if node.parent.right == node:\n                        self.left_rotate(node.parent)\n                        self.right_rotate(node.parent)\n                    else:\n                        self.right_rotate(node.parent)\n                        self.left_rotate(node.parent)\n\n        def left_rotate(self, x):\n            y = x.right\n            x.right = y.left\n            if y.left:\n                y.left.parent = x\n            y.parent = x.parent\n            if not x.parent:\n                self.root = y\n            elif x == x.parent.left:\n                x.parent.left = y\n            else:\n                x.parent.right = y\n            y.left = x\n            x.parent = y\n\n        def right_rotate(self, x):\n            y = x.left\n            x.left = y.right\n            if y.right:\n                y.right.parent = x\n            y.parent = x.parent\n            if not x.parent:\n                self.root = y\n            elif x == x.parent.right:\n                x.parent.right = y\n            else:\n                x.parent.left = y\n            y.right = x\n            x.parent = y\n\n    import random\n\n    def apply_bitmask_to_row(matrix, row_index, bitmask):\n        for i in range(len(matrix[row_index])):\n            matrix[row_index][i] ^= bitmask\n\n    def apply_bitmask_to_column(matrix, col_index, bitmask):\n        for row in matrix:\n            row[col_index] ^= bitmask\n\n    def count_zeros(matrix):\n        return sum(row.count(0) for row in matrix)\n\n    def alien_laser_trap(matrix, operations):\n        history_tree = SplayTree()\n        current_config = [row[:] for row in matrix]\n        best_config = current_config\n        best_zeros = count_zeros(current_config)\n\n        for operation in operations:\n            # Try operation on each row\n            for row_index in range(len(matrix)):\n                new_config = [row[:] for row in current_config]\n                apply_bitmask_to_row(new_config, row_index, operation)\n                zeros = count_zeros(new_config)\n                # Use rejection sampling criterion based on history stored in splay tree\n                if random.random() < 0.5:  # This should be determined by a more complex criterion related to the splay tree\n                    continue\n                if zeros > best_zeros:\n                    best_config = new_config\n                    best_zeros = zeros\n            # Try operation on each column\n            for col_index in range(len(matrix[0])):\n                new_config = [row[:] for row in current_config]\n                apply_bitmask_to_column(new_config, col_index, operation)\n                zeros = count_zeros(new_config)\n                # Use same rejection sampling criterion\n                if random.random() < 0.5:\n                    continue\n                if zeros > best_zeros:\n                    best_config = new_config\n                    best_zeros = zeros\n\n        return best_zeros", "test": "def check(candidate):\n    # Base case with no operations\n    assert candidate([[0, 1], [1, 1]], []) == 2\n    # Single operation that could turn all elements off\n    assert candidate([[0, 1], [1, 1]], [1]) == 4\n    # Different operations changing the configuration differently\n    assert candidate([[1, 1], [1, 1]], [1, 2]) == 4\n    # Testing on larger matrix\n    assert candidate([[1, 0, 1], [0, 1, 0], [1, 1, 1]], [1, 2, 3]) == 5\n    assert candidate([[0, 1, 0], [1, 0, 1], [0, 1, 0]], [1, 2, 3]) == 9", "entry_point": "alien_laser_trap", "extra_info": {"cover_story_words": ["aliens", "haunted ship"], "topics": ["Splay Tree", "Bitmask", "Rejection Sampling"], "cleaned_prompt": "Given a matrix which represents a grid of laser nodes where each cell can be either 0 (laser off) or 1 (laser on), and a list of bitmask operations, compute the maximum number of laser nodes that can be turned off. You can apply each bitmask operation to any row or column using an XOR operation. The application of operations should be guided by a strategy that utilizes a splay tree to log the frequency of outcomes, and uses rejection sampling for decision-making on application of these operations.\n\nExamples:\n- For a given matrix [[0, 1], [1, 1]] and operations [1, 2], evaluate different configurations achievable by applying bitmasks and selecting operations based on the history of outcomes.", "warnings": ["Solution failed correctness check.", "5, Complexity and Clarity Issue: The problem combines multiple complex concepts (bitmask operations, splay trees, and rejection sampling) in a way that may be confusing, especially how these concepts interact and are supposed to be used together effectively. The description does not clearly explain how the splay tree is used in conjunction with the rejection sampling process, nor does it detail how outcomes are logged or decisions are made using the splay tree, potentially leading to a misunderstanding of the task and methods required to implement the solution effectively.", "4, Undefined Rejection Sampling Criteria: The problem states that operations should be selectively applied based on \"rejection sampling criteria\" related to the splay tree, but no specific criteria are described or outlined. This leaves too much room for interpretation about how these decisions should be made, which can lead to discrepancies in solutions and difficulties in validation.", "5, Performance Concern: Using a splay tree to record every operation result frequency and implementing an effective rejection sampling algorithm could both be computationally intensive. Especially without clear guidelines on optimizing or managing the potential size and operations on the splay tree, this could lead to inefficient solutions that may not perform well, especially on larger matrices or with many operations."]}}
