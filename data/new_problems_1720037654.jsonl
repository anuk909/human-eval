{"task_id": "hard/3", "prompt": "def optimal_energy_path(command_centers, connections):\n    \"\"\"\n    As the head engineer of a fleet's energy distribution system in a network of command centers, you are required to design an algorithm that determines the optimal paths for energy transfer between these command centers while ensuring no cycles are formed (the network should form a tree-like structure). Each center and their direct connections are given as unique integers and a list of tuples respectively.\n\n    Your function should accept two parameters: an array of integers representing command centers and a list of tuples representing the bidirectional connections between these command centers. The aim is to select connections that form a tree rooted at the command center with the smallest number appearing most frequently in the connections, optimizing for minimal path cost based on a predefined metric like latency.\n\n    Define a function to calculate the path cost and ensure that your tree minimizes this cost. The focus should be on solving the problem algorithmically without the need for visualization tools or external libraries.\n\n    Example:\n    Given the command centers [1, 2, 3, 4, 5] and the connections [(1, 2), (1, 3), (2, 3), (3, 4), (5, 1)], your function should return an optimal tree structure as a list of tuples representing the connections, like [(1, 2), (1, 3), (3, 4), (5, 1)].\n\n    Notes:\n    - Ensure there are no cycles in the output configuration.\n    - Handle the case where not all command centers are initially interconnected.\n    - Duplicate links might be present and should be managed accordingly.\n    \"\"\"\n", "canonical_solution": "    # Define key functions for handling tree operations and optimizing paths\n\n    class TreeNode:\n            def __init__(self, value):\n                self.value = value\n                self.connections = []\n\n        def min_cost_tree(command_centers, connections):\n            # Implement cycle detection, tree construction and optimization considering path costs\n\n        def calculate_path_cost(...):\n            # Defines how to calculate cost between nodes\n\n        # Process the command centers and connections to build an optimized tree\n    ", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 3), (3, 4), (5, 1)]) == [(1, 2), (1, 3), (3, 4), (5, 1)]\n    assert candidate([1, 2, 3, 4], [(1, 2), (2, 3), (3, 1), (4, 2)]) == [(1, 2), (2, 3), (4, 2)]\n    assert candidate([1, 2], [(1, 2), (2, 1)]) == [(1, 2)]\n    assert candidate([1, 2, 3, 4, 5], []) == []\n    assert candidate([1], []) == []\n", "entry_point": "optimal_energy_path", "extra_info": {"cover_story_words": ["spaceship", "energy vortex"], "topics": ["Treap", "Detect Cycle in Graph"], "cleaned_prompt": "Implement a system to manage and find optimal paths for energy transfer between command centers to form a non-cyclic structure, maintaining a tree-like property (treap) for minimizing a cost function. You should also be able to visualize the computed structure.", "warnings": ["Solution failed correctness check.", "5, Undefined Metric: The problem statement lacks a clear definition of the \"predefined metric like latency\" used for calculating the path costs, leading to ambiguity in understanding how to optimize the tree.", "5, No Clear Instructions on Handling Duplicates: Although the problem mentions that duplicate links might be present and should be managed accordingly, it provides no specific guidance or method on how duplicates should be handled, affecting the stability and predictability of the function's output.", "5, Ambiguous Root Selection Criteria: The problem specifies that the tree should be rooted at the command center with the smallest number appearing most frequently in the connections, yet no tie-breaking rules or further explanation is provided on how to select the root in scenarios where multiple centers meet this criterion equally.", "4, Incomplete Function Definition: The function signature and description do not specify the return type clearly. Although the examples imply the return should be a list of tuples representing connections, this is not explicitly stated in the function signature or description."]}}
{"task_id": "hard/2", "prompt": "def detect_farm_cams(image_data, camera_positions, permute_sequence):\n    \"\"\"\n    In a futuristic farming scenario, Mr. Roboto has automated cameras positioned at specific coordinates in the farm. Each camera sends its image data as a stream of integers. Additionally, a permutation sequence is applied directly to the 'image_data' based on the camera positions to encrypt the data before it is transmitted for processing.\n\n    Your task is to:\n    1. Permute the `image_data` according to `permute_sequence`.\n    2. Compute the pixel-average over bitwise AND of all permuted streams.\n\n    Parameters:\n    - image_data: A list of lists, where each sublist represents the pixel data from a camera.\n    - camera_positions: A list of integer tuples (x, y) for camera positions (Note: for contextual purposes only).\n    - permute_sequence: A list of indices that describes how to permute `image_data` based on `camera_positions`.\n\n    The function should return the average of the bitwise AND results across all pixel data of the streams after applying the permutation sequence.\n\n    Example:\n    image_data = [[0xFF, 0xEE], [0xCC, 0xDD]]\n    camera_positions = [(10, 20), (30, 40)]\n    permute_sequence = [1, 0]\n    Output should be 204 since:\n    After permutation of image_data = [[0xCC, 0xDD], [0xFF, 0xEE]]\n    Bitwise AND across the streams: [0xCC & 0xFF, 0xDD & 0xEE] = [0xCC, 0xCC]\n    Average of [0xCC, 0xCC] is 204.\n\n    Note:\n    - All lists will be non-empty and all sublists in image_data will be of the same length.\n    - Permute sequence will cover all indices of image_data exactly once.\n    \"\"\"", "canonical_solution": "    def detect_farm_cams(image_data, camera_positions, permute_sequence):\n        # Permute image_data according to the permute_sequence\n        permuted_data = [image_data[i] for i in permute_sequence]\n\n        # Initialize the result for bitwise AND operations\n        if permuted_data:\n            bitwise_result = [0xFFFFFFFF] * len(permuted_data[0])\n            for data in permuted_data:\n                bitwise_result = [x & y for x, y in zip(bitwise_result, data)]\n\n        # Calculate average of bitwise results\n        average_result = sum(bitwise_result) // len(bitwise_result)\n        return average_result", "test": "def check(candidate):\n    assert candidate([[0xFF, 0xEE], [0xCC, 0xDD]], [(10, 20), (30, 40)], [1, 0]) == 204\n    assert candidate([[0xF0, 0x0F], [0x0F, 0xF0]], [(5, 5), (10, 10)], [1, 0]) == 15\n    assert candidate([[0xAA, 0xBB], [0xCC, 0xDD]], [(7, 7), (8, 8)], [0, 1]) == 170\n   assert candidate([[0xFF], [0xEF], [0xDF]], [(1, 2), (2, 3), (3, 4)], [2, 1, 0]) == 223\n    assert candidate([[0x123, 0x234], [0x345, 0x456]], [(15, 25), (35, 45)], [0, 1]) == 837", "entry_point": "detect_farm_cams", "extra_info": {"cover_story_words": ["farm", "cyber cafe"], "topics": ["Permutations", "Bitwise AND Operations"], "cleaned_prompt": "Write a function `detect_farm_cams` that takes three parameters `image_data`, `camera_positions`, and `permute_sequence`. The function should permute the camera_positions according to `permute_sequence`, compute the bitwise AND across all streams according to the new order and then return the average of results.\n\nExamples:\n- For `image_data = [[0xFF, 0xEE], [0xCC, 0xDD]]`, `camera_positions = [(10, 20), (30, 40)]`, and `permute_sequence = [1, 0]`, this returns 204.\n- All input lists will be non-empty and permute sequence will cover all indices of camera_positions once. Assume all sublists in image_data are of the same length.", "warnings": ["Solution failed correctness check.", "5, Logic Error in Canonical Solution: The problem description specifies that the cameras' pixel data should be permuted in the order given by `permute_sequence` before computing the bitwise AND. However, the canonical solution permutes the camera positions instead and does not permute the `image_data`, which leads to using the pixel data in the wrong order for bitwise AND operations, resulting in incorrect output.", "4, Unclear Parameters Role: The problem statement and canonical solution use the `camera_positions` for permuting the order but do not utilize the actual coordinates (x, y) in any computation, making it unclear why these coordinates are needed or how they contribute to the solution, potentially causing confusion."]}}
{"task_id": "hard/1", "prompt": "def haunted_exploration(grid, operations):\n    \"\"\"\n    Imagine you're aboard a haunted ship surrounded by a mystical forest. The ship is equipped with an old system that can execute certain operations based on a grid of surveillance data collected by mystical sensors. The grid is a 2D list where each cell can be 'S' (Ship), 'F' (Forest), or 'D' (Detected Anomaly). Operations are scheduled as tasks that need to be executed in a specific order to clear anomalies using ship resources.\n\n    Your function takes two inputs:\n    - grid: a 2-dimensional list representing the initial state of the area surrounding the ship.\n    - operations: a list of operations where each operation is a string of up to four directional commands: 'U' (Up), 'D' (Down), 'L' (Left), 'R' (Right).\n\n    Operations aim to navigate through the grid to clear 'D' elements turning them into 'S', signifying that anomalies have been addressed. Importantly, each operation starts from where the last one ended, not resetting to the top-left corner unless specifically stated at the end of an operation. Navigating into 'F' regions extends the time required to execute subsequent operations by 1 unit time each. Starting position is always the top-left of the grid unless stated otherwise by an operation.\n\n    The goal is to return how much time in total will it take to execute all the operations. Each move within an operation takes 1 unit time, and if an operation passes through 'F', then *all* subsequent operations increase in duration by 1 unit time per 'F' encounter during that operation.\n\n    Examples:\n    Input: ([['S', 'D', 'F'], ['F', 'S', 'D']], ['R', 'D', 'R'])\n    Output: 7 (Movement RDR takes 3 units, R takes 2 units due to 1 'F' from RDR, R takes 2 units due to 1 'F' from RDR)\n\n    Note:\n    - If an attempt is made to move outside the grid boundaries, the move is ignored and no extra time is consumed (this means the move command is effectively skipped).\n    - Only anomaly 'D' can be turned into 'S' by directly stepping on it during an operation.\n    \"\"\"\n", "canonical_solution": "def haunted_exploration(grid, operations):\n    def in_bounds(x, y):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0])\n\n    time = 0\n    additional_time = 0\n    x, y = 0, 0\n    for op in operations:\n        local_f_count = 0\n        for move in op:\n            next_x, next_y = x, y\n            if move == 'U':\n                next_x -= 1\n            elif move == 'D':\n                next_x += 1\n            elif move == 'L':\n                next_y -= 1\n            elif move == 'R':\n                next_y += 1\n\n            if in_bounds(next_x, next_y):\n                x, y = next_x, next_y\n                if grid[x][y] == 'D':\n                    grid[x][y] = 'S'\n                elif grid[x][y] == 'F':\n                    local_f_count += 1\n        time += len(op) + additional_time\n        additional_time += local_f_count\n\n    return time", "test": "def check(candidate):\n    assert candidate([['S', 'D', 'F'], ['F', 'S', 'D']], ['R', 'D', 'R']) == 7\n    assert candidate([['S', 'D', 'S'], ['F', 'D', 'S']], ['D', 'RR', 'UU']) == 11\n    assert candidate([['F', 'D', 'S'], ['S', 'S', 'D']], ['R', 'L', 'DD', 'RR']) == 13\n    assert candidate([['S', 'S', 'S'], ['S', 'S', 'S']], ['RR', 'LL', 'DD']) == 9\n    assert candidate([['D', 'D', 'D'], ['D', 'D', 'D']], ['RRR', 'DD', 'LLL', 'UUU']) == 17", "entry_point": "haunted_exploration", "extra_info": {"cover_story_words": ["haunted ship", "forest"], "topics": ["Shell", "Task Scheduling"], "cleaned_prompt": "Write a function to process operations in a 2D grid either marked as 'S' (Ship), 'F' (Forest), or 'D' (Detected Anomaly). Given initial grid state and a list of operations consisting of 'U', 'D', 'L', 'R' directional commands, manipulate the grid by turning 'D' into 'S'. Each move within an operation takes 1 unit of time and moving into 'F' increases all subsequent operations' time by 1 unit per 'F'. Determine the total time required to execute all operations. Note that each operation's direction navigates from the current grid point and anomalies cleared are modified in the grid.", "warnings": ["Solution failed correctness check.", "5, Ambiguity in Operation Sequence: The problem statement does not clearly specify whether each operation starts from the termination point of the previous operation or is reset to the starting top-left corner each time. This ambiguity can cause confusion and incorrect implementations, making the problem challenging to solve correctly.", "4, Edge Case Handling for Grid Navigation: The problem description lacks detailed guidance for scenarios where multiple moves in an operation attempt to navigate outside the grid boundaries (such as consecutive 'L' or 'U' commands when already at an edge). This absence of information could result in inconsistent behavior and implementations, affecting the solution's correctness."]}}
{"task_id": "hard/5", "prompt": "def max_treasure_value(maps, distances):\n    \"\"\"\n    A treasure hunter uses a car to traverse through a matrix map where each cell contains either a treasure value (as an integer) or is blocked (denoted by -1). Each individual map in the 'maps' list has its unique movement constraints defined in the 'distances' list, which denotes how far in terms of steps the hunter can move starting from the top-left corner of each respective map. The task is to calculate the maximum treasure value the hunter can collect from each map considering the movement restrictions.\n\n    The hunter can move up, down, left, or right, but cannot pass through blocked cells and cannot move outside the boundaries of the map. If a distance in 'distances' is 0, this represents a scenario where the hunter cannot move from the initial position, and the treasure calculation for that map should return 0, even if the initial cell contains some treasure. Also, if the starting cell (top-left corner) is blocked (value of -1), the resulting treasure for that map should be 0 since no movement is possible.\n\n    The solution must handle and return a list of maximum possible treasure values for each map considering the given constraints, without modifying the original map structure or values during computation.\n\n    Each map in 'maps' will have the same size but they're not necessarily square. A sample map with a distance limit might look like this:\n    Map Example: [[0,1,-1,3], [2,3,-1,1], [0,-1,-1,4]]\n    Distance Limit: 5\n    Expected Output: the maximum treasure found by traversing at most 5 cells starting from the non-blocked top left corner and considering blocked paths.\n\n    Note:\n    - -1 indicates a blockage in the map and is impassible.\n    - Return 0 in cases where the start is blocked or no movement is allowed.\n    - Each unique path up to the given distance limit should be considered to compute the maximum possible treasure from starting position without modifying the map.\n    \"\"\"\n", "canonical_solution": "def max_treasure_value(maps, distances):\n    def dfs(map, x, y, remaining_steps, current_value):\n        if x < 0 or y < 0 or x >= len(map) or y >= len(map[0]) or map[x][y] == -1 or remaining_steps < 0:\n            return current_value\n        result = max(dfs(map, x+1, y, remaining_steps - 1, current_value + map[x][y]),\n                     dfs(map, x-1, y, remaining_steps - 1, current_value + map[x][y]),\n                     dfs(map, x, y+1, remaining_steps - 1, current_value + map[x][y]),\n                     dfs(map, x, y-1, remaining_steps - 1, current_value + map[x][y]))\n        return result\n\n    results = []\n    for idx, map in enumerate(maps):\n        if map[0][0] == -1 or distances[idx] == 0:\n            results.append(0)\n        else:\n            results.append(dfs(map, 0, 0, distances[idx], 0))\n    return results", "test": "def check(candidate):\n    assert candidate([[[0,1,-1,3], [2,3,-1,1], [0,-1,-1,4]]], [5]) == [6]\n    assert candidate([[[0,1,-1], [-1,3,1]]], [3]) == [4]  # can move right and then down\n    assert candidate([[[0]]], [0]) == [0]  # no steps allowed, should return 0 even though it starts at a treasure\n    assert candidate([[[0,-1,5], [2,3,-1], [4,-1,-1]]], [10]) == [9]  # can explore all non-blocked cells\n    assert candidate([[[5, -1, 0], [-1, 2, 1], [-1, -1, 3]], [[1, -1, 4], [0, 3, -1], [2, -1, 0]]], [7, 3]) == [5, 0]  # Second case must return 0 due to a blocked start", "entry_point": "max_treasure_value", "extra_info": {"cover_story_words": ["car", "treasure"], "topics": ["Matrix Chain Multiplication", "Combinatorics"], "cleaned_prompt": "Write a function that, given a list of 2D matrix maps where each cell contains a treasure value or is blocked, and a corresponding list of maximum distances the treasure hunter can move from the top-left corner, returns the maximum treasure the hunter can gather from each map considering the movement limitations. A cell value of -1 indicates a blockage, and treasure collection starts with zero. If the start position is blocked, return zero treasure for that map.", "warnings": ["Solution failed correctness check.", "5, Start position assumption: The problem assumes that the treasure hunter always starts from the top-left corner without checking if it is blocked. This assumption can make certain maps unusable and the corresponding test ineffective. For these cases, if the starting cell is blocked, it should directly return a treasure value of 0 without trying to explore the map.", "4, Output for no movement allowed: The problem states that if no movement is allowed (distance limit is 0), the function appears to return the value of the treasure at the starting position if not blocked, rather than 0. This could lead to confusion, as no movement implies no treasure should be collected. The function needs to account for this, ensuring that a distance limit of 0 always returns 0 irrespective of the starting cell's treasure value.", "4, Array boundary checks in solution: The provided candidate solution might modify the map matrix during exploration by setting the cell value to -1 temporarily. This alters the input matrix, which is generally undesirable as it might affect subsequent operations or tests. Additionally, this strategy could lead potentially to incorrect paths if calls overlap in recursive depth-first search due to altered cell values."]}}
{"task_id": "hard/4", "prompt": "def shortest_safe_path(grid, start, end):\n    \"\"\"\n    Imagine a cyclist who wants to traverse through a mysterious cave. The cave is represented as a grid where each cell has a light intensity value. Darker cells (with lower values) are considered more dangerous than brighter ones due to their greater likelihood of hiding obstacles or hazards.\n\n    The task is to find the shortest path from the `start` to the `end` point on this grid while ensuring the path avoids highly dangerous areas. For this, you are required to ignore the darkest 10% of the cells during path calculation. The grid cells are 0-indexed and contain integers where a higher value represents a brighter (safer) area.\n\n    You will use a modified Bellman-Ford Algorithm that incorporates rejection sampling to repeatedly discard paths that include the darkest 10% of cells, until a viable path is found or it is determined that no such path exists. There should be checks to ensure the algorithm does not loop endlessly in case no path is possible, terminating if all paths through permissible cells have been exhausted.\n\n    Use the following movement directions: UP, DOWN, LEFT, and RIGHT. Diagonal movements are not allowed.\n\n    The function should handle complex test cases efficiently and should explicitly avoid paths through highly dangerous zones determined by pixel intensity.\n\n    Example:\n    grid = [\n      [1, 10, 10],\n      [1, 20, 10],\n      [1, 50, 30]\n    ]\n    start = (0, 0)\n    end = (2, 2)\n    # The output should be a path represented as a list of coordinates from start to end, avoiding the darkest 10% of cells if a path is available. If no safe path is found, return None.\n    \"\"\"\n", "canonical_solution": "def is_within_bounds(point, grid):\n    x, y = point\n    return 0 <= x < len(grid) and 0 <= y < len(grid[0])\n\ndef get_neighbors(point):\n    x, y = point\n    return [(x + dx, y + dy) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)] if is_within_bounds((x + dx, y + dy), grid)]\n\ndef is_dark(cell, threshold):\n    return grid[cell[0]][cell[1]] < threshold\n\ndef calculate_intensity_threshold(grid):\n    values = [cell for row in grid for cell in row]\n    values.sort()\n    return values[len(values) // 10]\n\ndef bellman_ford(grid, start, end):\n    threshold = calculate_intensity_threshold(grid)\n    queue = [start]\n    visited = set()\n    parents = {start: None}\n    while queue:\n        current = queue.pop(0)\n        if current in visited:\n            continue\n        if current == end:\n            path = []\n            while current:\n                path.append(current)\n                current = parents[current]\n            return path[::-1]\n        for neighbor in get_neighbors(current):\n            if not is_dark(neighbor, threshold) and neighbor not in visited:\n                queue.append(neighbor)\n                parents[neighbor] = current\n        visited.add(current)\n    if start in visited and not end in visited:\n        return None\n\nreturn bellman_ford(grid, start, end)", "test": "def check(candidate):\n    grid = [\n        [1, 10, 10],\n        [1, 20, 10],\n        [1, 50, 30]\n    ]\n    assert candidate(grid, (0, 0), (2, 2)) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n    grid2 = [\n        [1, 0, 100],\n        [1, 1, 100],\n        [0, 0, 100]\n    ]\n    assert candidate(grid2, (0, 0), (2, 2)) == [(0, 0), (1, 0), (1, 1), (1, 2), (2, 2)]\n    grid3 = [\n        [10, 1, 1],\n        [100, 1, 1],\n        [100, 100, 10]\n    ]\n    assert candidate(grid3, (0, 0), (2, 2)) == None\n    grid4 = [\n        [30, 20, 24],\n        [18, 19, 17],\n        [15, 16, 14]\n    ]\n    assert candidate(grid4, (0, 0), (0, 2)) == [(0, 0), (0, 1), (0, 2)]\n    grid5 = [[1]]\n    assert candidate(grid5, (0, 0), (0, 0)) == [(0, 0)]", "entry_point": "shortest_safe_path", "extra_info": {"cover_story_words": ["bicycle", "mysterious cave"], "topics": ["Bellman-Ford Algorithm", "Rejection Sampling"], "cleaned_prompt": "Create a function that finds the shortest path in a grid from a start point to an end point while avoiding the dimmest 10% of grid cells (measured by their values). Use only vertical and horizontal movements, and employ a modified Bellman-Ford algorithm including rejection sampling to exclude unwanted paths. The grid cells' values represent the light intensity, with higher values indicating brighter and safer areas.", "warnings": ["Solution failed correctness check.", "5, Inconsistent algorithm application: The problem statement mentions the use of a modified Bellman-Ford Algorithm with rejection sampling, but the provided canonical solution implements a straightforward pathfinding approach without including any rejection sampling steps. This lack of consistency between the problem description and the solution can lead to confusion and incorrect implementations.", "5, Endless looping potential: The task setup and the canonical solution lack mechanisms to effectively handle scenarios where no path is possible due to the constraints of avoiding the darkest 10% of cells. Without proper termination checks, this can lead to endless loops or excessive computation times, making the problem unsolvable for some inputs without a definite or correct stopping condition.", "4, Ambiguous problem constraints: The description to avoid the \"darkest 10% of cells\" is ambiguous without specifying the method of calculation for determining these cells. It is unclear whether this refers to the 10% of distinct value types or the overall distribution of all cell values. This ambiguity can result in different interpretations and solutions, affecting the consistency of solution implementations.", "4, Incorrect or incomplete test cases: The provided test cases in the prompt fail to cover boundary conditions such as very small grids or grids where the light intensity distribution might significantly affect path availability (e.g., all cells being in the darkest 10%). These cases are essential for thoroughly testing the robustness and correctness of the solution implementation."]}}
