{"reason": "Solution failed correctness check. correctness_check_result: {correctness_result['result']}", "problem": "{\"task_id\": \"hard/1\", \"prompt\": \"def count_triplets(arr, r):\\n    \\\"\\\"\\\"\\n    Write a function that takes a list of integers and a positive integer r, and returns the number of triplets (a, b, c) that satisfy the condition a * r = b and b * r = c. The triplets should have indices i < j < k such that arr[i] * r == arr[j] and arr[j] * r == arr[k].\\n\\n    For example, if the input is [1, 3, 3, 9, 9, 27] and r is 3, the output should be 6 because there are 6 triplets that satisfy the condition: (1, 3, 9), (3, 9, 27), (3, 9, 27), (1, 3, 9), (3, 9, 27), (1, 3, 9).\\n    \\n    Note:\\n    - The input list may contain duplicate numbers, but you should only consider each unique number once.\\n    - The triplets should have indices i < j < k and arr[i] * r == arr[j] and arr[j] * r == arr[k].\\n    \\\"\\\"\\\"\\n\", \"canonical_solution\": \"    count = 0\\n    potential_start = {}\\n    potential_end = {}\\n    for i in arr:\\n        if i in potential_end:\\n            count += potential_end[i]\\n        if i in potential_start:\\n            if i*r in potential_end:\\n                potential_end[i*r] += potential_start[i]\\n            else:\\n                potential_end[i*r] = potential_start[i]\\n        if i*r in potential_start:\\n            potential_start[i*r] += 1\\n        else:\\n            potential_start[i*r] = 1\\n\\n    return count\", \"test\": \"def check(candidate):\\n    assert candidate([1, 3, 3, 9, 9, 27], 3) == 6\\n    assert candidate([1, 2, 2, 4, 4, 8], 2) == 5\\n    assert candidate([5, 5, 5, 5], 1) == 4\\n    assert candidate([1, 2, 3, 6, 9, 18], 2) == 10\\n    assert candidate([1, 2, 3, 4, 5, 6], 2) == 0\", \"entry_point\": \"count_triplets\"}"}
{"reason": "Solution failed correctness check. correctness_check_result: {correctness_result['result']}", "problem": "{\"task_id\": \"hard/1\", \"prompt\": \"def max_contiguous_subarray_sum(arr):\\n    \\\"\\\"\\\"\\n    Write a function that takes a list of integers and returns the sum of the maximum subarray within the input list. A subarray is a continuous section of an array. The maximum subarray sum is the largest possible sum of a sequence of consecutive values from the input list.\\n\\n    For example, if the input is [-2,1,-3,4,-1,2,1,-5,4], the output should be 6, as the subarray [4, -1, 2, 1] has the largest sum of 6.\\n\\n    Note:\\n    - If the input list is empty, return 0.\\n    - All numbers in the input list may be negative.\\n    \\\"\\\"\\\"\\n\", \"canonical_solution\": \"    max_sum = 0\\n    current_sum = 0\\n    for num in arr:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    return max_sum\", \"test\": \"def check(candidate):\\n    assert candidate([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\\n    assert candidate([]) == 0\\n    assert candidate([1, 2, 3, 4, 5]) == 15\\n    assert candidate([-1, -2, -3, -4, -5]) == -1\\n    assert candidate([5, -2, 3, 1, 2]) == 9\", \"entry_point\": \"max_contiguous_subarray_sum\"}"}
{"reason": "Solution failed correctness check. correctness_check_result: {correctness_result['result']}", "problem": "{\"task_id\": \"hard/1\", \"prompt\": \"def common_prefix(s1, s2):\\n    \\\"\\\"\\\"\\n    Write a function to find the longest common prefix string amongst an array of strings.\\n\\n    If there is no common prefix, return an empty string \\\"\\\".\\n\\n    For example, given the strings [\\\"flower\\\",\\\"flow\\\",\\\"flight\\\"], the common prefix is \\\"fl\\\".\\n    \\n    Note:\\n    - All given inputs are in lowercase letters a-z.\\n    \\\"\\\"\\\"\\n\", \"canonical_solution\": \"    if not strs:\\n        return \\\"\\\"\\n\\n    min_len = min(len(s) for s in strs)\\n    end = 0\\n    for i in range(min_len):\\n        for j in range(1, len(strs)):\\n            if strs[j][i] != strs[0][i]:\\n                return strs[0][:end]\\n        end += 1\\n    return strs[0][:end]\", \"test\": \"def check(candidate):\\n    assert candidate([\\\"flower\\\",\\\"flow\\\",\\\"flight\\\"]) == \\\"fl\\\"\\n    assert candidate([\\\"dog\\\",\\\"racecar\\\",\\\"car\\\"]) == \\\"\\\"\\n    assert candidate([\\\"apple\\\",\\\"ape\\\",\\\"april\\\"]) == \\\"ap\\\"\\n    assert candidate([\\\"a\\\",\\\"b\\\"]) == \\\"\\\"\\n    assert candidate([]) == \\\"\\\"\", \"entry_point\": \"common_prefix\"}"}
{"reason": "Solution failed correctness check. correctness_check_result: {correctness_result['result']}", "problem": "{\"task_id\": \"hard/1\", \"prompt\": \"def nearest_larger_square(numbers, n):\\n    \\\"\\\"\\\"\\n    Write a function that takes a list of integers and a number n, and returns the square of the nearest larger number in the list relative to n. If there are multiple numbers with the same distance to n, choose the larger one.\\n\\n    For example, if the input list is [1, 3, 5, 7, 9] and n is 4, the output should be 9 because 5 is the nearest larger number to 4, and 5 squared is 25.\\n\\n    Note:\\n    - If there are no larger numbers in the list relative to n, return -1.\\n    - The input list may contain negative numbers and may not be sorted.\\n    \\\"\\\"\\\"\\n\", \"canonical_solution\": \"    nearest_larger = [num for num in numbers if num > n]\\n    if not nearest_larger:\\n        return -1\\n    nearest_larger.sort()\\n    nearest = nearest_larger[0]\\n    for num in nearest_larger:\\n        if abs(num - n) < abs(nearest - n):\\n            nearest = num\\n    return nearest ** 2\", \"test\": \"def check(candidate):\\n    assert candidate([1, 3, 5, 7, 9], 4) == 25\\n    assert candidate([3, 6, 9, 12, 15], 10) == 144\\n    assert candidate([1, 4, 16, 25, 36], 5) == 16\\n    assert candidate([10, 20, 30, 40, 50], 35) == 40\\n    assert candidate([2, 4, 6, 8, 10], 11) == -1\", \"entry_point\": \"nearest_larger_square\"}"}
