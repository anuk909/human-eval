{"task_id": "hard/4", "prompt": "def optimal_navigation_plans(n, connections, rocket_routes, carpet_routes):\n    \"\"\"\n    You are given a fantastic world with `n` cities numbered from 0 to n-1. These cities are connected by various one-way routes (directed edges). Furthermore, each city has two special travel options: a rocket route and a flying carpet route, which can instantly transport you to another city using magic.\n\n    The task is to compute the minimum number of unique 'bitwise OR' operations performed on the city numbers you visit during the travel (including start and end cities), that allows you to navigate from city 0 to city n-1 using any combination of normal routes, rocket routes, and carpet routes. If it's not possible to travel from city 0 to city n-1, return -1.\n\n    Parameters:\n    - n: an integer representing the total number of cities (2 <= n <= 100)\n    - connections: a list of tuples (u, v) representing a directed edge from city u to city v.\n    - rocket_routes: a list of integers representing, for each city i, the destination city rocket can take you to instantly.\n    - carpet_routes: a list of integers representing, for each city i, the destination city carpet can take you to instantly.\n\n    Example:\n    Input: n = 4, connections = [(0, 1), (1, 2), (2, 3)], rocket_routes = [1, 2, 3, 0], carpet_routes = [2, 3, 0, 1]\n    Output: 1 (Direct traversal via city numbers 0 -> 1 -> 2 -> 3 results in bitwise OR operations that always give 3 (111 in binary), so 1 unique operation.)\n    \"\"\"", "canonical_solution": "from collections import deque\n\ndef optimal_navigation_plans(n, connections, rocket_routes, carpet_routes):\n    graph = {i: [] for i in range(n)}\n    for u, v in connections:\n        graph[u].append(v)\n\n    def bfs(start):\n        queue = deque([(start, 0)])\n        visited = set()\n\n        while queue:\n            current, or_value = queue.popleft()\n            if current == n - 1:\n                return or_value\n\n            next_or = or_value | current\n            if current not in visited:\n                visited.add(current)\n                for neighbor in graph[current]:\n                    queue.append((neighbor, next_or))\n                rocket_target = rocket_routes[current]\n                carpet_target = carpet_routes[current]\n                queue.append((rocket_target, next_or))\n                queue.append((carpet_target, next_or))\n\n        return -1\n\n    return bfs(0)", "test": "def check(candidate):\n    assert candidate(4, [(0, 1), (1, 2), (2, 3)], [1, 2, 3, 0], [2, 3, 0, 1]) == 1\n    assert candidate(5, [(0, 1), (1, 2), (2, 4), (4, 3)], [2, 3, 4, 0, 1], [3, 4, 0, 1, 2]) == 0\n    assert candidate(3, [(0, 1)], [2, 2, 0], [2, 0, 1]) == -1\n    assert candidate(4, [(0, 1), (1, 2)], [3, 3, 0, 1], [2, 0, 1, 3]) == 1\n    assert candidate(6, [(0, 1), (1, 4), (4, 5)], [1, 2, 3, 4, 2, 0], [2, 3, 4, 0, 1, 2]) == 1", "entry_point": "optimal_navigation_plans", "extra_info": {"cover_story_words": ["rocket", "flying carpet"], "topics": ["Graph", "Bitwise OR Operations", "Bitwise XOR Operations"], "cleaned_prompt": "You need to determine the minimum number of unique 'bitwise OR' operations required to travel from city 0 to city n-1 in a network of cities using various means including direct routes, rockets, and carpets. The connections, rocket routes, and carpet routes for the cities are provided. If no such path exists, return -1.\n\nExample usage: optimal_navigation_plans(4, [(0, 1), (1, 2), (2, 3)], [1, 2, 3, 0], [2, 3, 0, 1]) returns 1.", "warnings": ["Solution failed correctness check.", "5, Unclear Objective: The problem statement aims to minimize 'bitwise OR' operations, but the requirement is to count the minimum number of unique 'bitwise OR' results. This critical aspect could confuse participants as typically minimizing operations would refer to minimizing the times an operation is executed, not the uniqueness of its outcomes.", "4, Ambiguity in Transportation Definition: The role of rocket_routes and carpet_routes is not consistently logical or practical in the given examples. The example implies any city can be directly reached from any other by these routes, creating an unusual and unclear graph traversal scenario where traditional pathfinding logic may not apply as directly or simply."]}}
{"task_id": "hard/3", "prompt": "def haunted_ship_vision(tree, darkness_val, target_val):\n    \"\"\"\n    At the World's End Wizarding School, there's a legend about a haunted ship that appears on full moon nights. This ship is visible only through enchanted trees that grow in the school's courtyard. These trees are no ordinary trees but are represented as binary trees where each node holds a visibility value.\n\n    The visibility of the ship through these trees depends on two main factors:\n    - 'darkness_val': a certain darkness value which represents how dark the night is when observing the ship; the darker, the easier to observe if nodes' values are higher.\n    - 'target_val': the illumination value required to actually spot the ship.\n\n    Your task is to:\n    1. Perform a level order traversal on the binary tree and retrieve the visibility values.\n    2. Adjust these visibility values based on the 'darkness_val' by applying a ternary search to optimize and find an 'adjusted_visibility_factor' which maximizes the visibility values in a way that as many nodes as possible are equal or exceed the 'target_val'.\n    3. Determine if there are any two unique nodes at the same level of the tree whose visibility values sum up to exactly 'target_val' (similar to two-sum problem).\n\n    The function should return a tuple (is_spot_possible, list_levels) where:\n    - 'is_spot_possible': is a boolean that indicates if it's possible to spot the ship by finding two nodes at any level whose adjusted values sum up to 'target_val'.\n    - 'list_levels': is a list of lists, with each sublist representing visibility values of nodes at each level after adjusting with the 'optimal_visibility_factor'.\n\n    Example:\n    # Binary Tree Structure\n    #        5\n    #       / \\ \n    #      3   8\n    #     /|   |\n    #    2 4   7\n    # Binary tree represented as a simple example. The actual tree will be more complex.\n    \n    The output for a case where darkness_val = 2, target_val=15 would typically involve an optimal adjustment of visibility values and checking pairs for the two-sum problem.\n\n    \"\"\"\n", "canonical_solution": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nfrom collections import deque\n\ndef is_possible_to_sum_to_target(values, target):\n    needed = set()\n    for value in values:\n        if (target - value) in needed:\n            return True\n        needed.add(value)\n    return False\n\ndef haunted_ship_vision(tree, darkness_val, target_val):\n    if not tree:\n        return (False, [])\n\n    queue = deque([tree])\n    list_levels = []\n    is_spot_possible = False\n\n    while queue:\n        level_size = len(queue)\n        level_nodes = []\n        for _ in range(level_size):\n            node = queue.popleft()\n            adjusted_value = ternary_search_optimization(node.val, darkness_val, target_val) # Placeholder for the ternary search implementation\n            level_nodes.append(adjusted_value)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        list_levels.append(level_nodes)\n        if not is_spot_possible:\n            is_spot_possible = is_possible_to_sum_to_target(level_nodes, target_val)\n\n    return (is_spot_possible, list_levels)", "test": "def check(candidate):\n    # Define the tree as per the earlier example\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(7)\n\n    # Assume ternary_search_optimization is a correct implementation\n    is_spot_possible, levels = candidate(root, 2, 15)\n    assert is_spot_possible == False  # Dependent on ternary search optimization working and tree setup\n    assert levels == [[10], [6, 16], [4, 8, 14]]  # The expected adjusted levels\n\n    # Test with different darkness_val\n    is_spot_possible, levels = candidate(root, 1, 9)\n    assert is_spot_possible == True  # Should find pairs now after adjustment\n    assert levels == [[5], [3, 8], [2, 4, 7]]  # Based on darkness_val\n\n    # Test with empty tree\n    is_spot_possible, levels = candidate(None, 2, 5)\n    assert is_spot_possible == False\n    assert levels == []", "entry_point": "haunted_ship_vision", "extra_info": {"cover_story_words": ["haunted ship", "wizard school"], "topics": ["Binary Tree Level Order Traversal", "Ternary Search", "Two-Sum Problem"], "cleaned_prompt": "Define a function that takes a binary tree and two integers, darkness_val and target_val as inputs. Perform a level order traversal on the binary tree and iteratively adjust the node values using a ternary search to maximize the number of nodes exceeding target_val. Afterwards, check at each level if two unique node values summed equal target_val. Return a tuple, with the first element indicating if a sum matching target_val was found, and the second element listing the adjusted node values for each level.", "warnings": ["Solution failed correctness check.", "5, Undefined functionality: The problem statement mentions the use of \"ternary search to optimize and find an 'adjusted_visibility_factor' which maximizes the visibility values\", but it doesn't define how to perform this ternary search in relation to the provided tree values, darkness_val, and target_val. This leaves a critical part of the task undefined, making the problem unsolvable as specified.", "4, Complexity of multiple tasks: The problem simultaneously requires a level-order traversal, an application of an undefined ternary search technique, and a check for two unique nodes whose values sum to a specific target. Combining these distinct tasks into a single function makes the problem overly complex and potentially confusing."]}}
{"task_id": "hard/1", "prompt": "def song_segmentation(frequencies, timestamps, threshold):\n    \"\"\"\n    Imagine a court case where the authenticity of various musical recordings is in dispute. The challenge is to develop a software that detects changes in the music's tonality within a recording, which may indicate splicing or editing.\n\n    Each recording is represented by two lists: frequencies and timestamps. The 'frequencies' list contains the dominant frequency (in Hz) at each sampled time point, and the 'timestamps' list contains the corresponding times (in seconds) of these samples. Additionally, you are given a 'threshold' which is the frequency deviation above which a change in the song segment is considered significant.\n\n    Your task is to write a function that returns a list of tuples. Each tuple represents a continuous segment of the song where the frequency stays consistent (within the given threshold). Each tuple should contain the starting and ending time of that segment.\n\n    Example:\n    - If `frequencies` = [440.5, 442.1, 441.0, 600.3, 602.2, 800.0, 799.1, 600.4],\n    - And `timestamps` = [0, 1, 2, 5, 6, 10, 11, 15],\n    - And `threshold` = 2.0, (meaning we allow frequency deviation up to 2 Hz as consistent)\n    - The output should be [(0, 2), (5, 6), (10, 11), (15, 15)] since these intervals show consistent frequencies within the threshold.\n\n    Constraints:\n    - The lengths of the 'frequencies' and 'timestamps' lists are the same.\n    - All entries in 'frequencies' are non-negative floats.\n    - All entries in 'timestamps' are non-negative integers and are strictly increasing.\n\n    Note: If a segment consists of a single sample, it should be represented with the start and end time being the same.\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n\n    def song_segmentation(frequencies, timestamps, threshold):\n        if not frequencies or not timestamps:\n            return []\n\n        # Initialize\n        current_freq = frequencies[0]\n        start_time = timestamps[0]\n        end_time = timestamps[0]\n        result = []\n\n        for i in range(1, len(frequencies)):\n            if abs(frequencies[i] - current_freq) <= threshold:\n                end_time = timestamps[i]\n            else:\n                result.append((start_time, end_time))\n                current_freq = frequencies[i]\n                start_time = timestamps[i]\n                end_time = timestamps[i]\n\n        result.append((start_time, end_time))\n        return result", "test": "def check(candidate):\n    assert candidate([440.5, 442.1, 441.0, 600.3, 602.2, 800.0, 799.1, 600.4], [0, 1, 2, 5, 6, 10, 11, 15], 2.0) == [(0, 2), (5, 6), (10, 11), (15, 15)]\n    assert candidate([], [], 1.0) == []\n    assert candidate([400], [0], 3.0) == [(0, 0)]\n    assert candidate([300, 304.5, 310], [0, 5, 10], 5.0) == [(0, 5)]\n    assert candidate([100, 150, 400, 850], [0, 2, 5, 7], 50) == [(0, 2), (5, 5), (7, 7)]", "entry_point": "song_segmentation", "extra_info": {"cover_story_words": ["music", "courtroom"], "topics": ["Meeting Rooms", "Line Sweep", "Quadtree"], "cleaned_prompt": "Write a function that takes two lists 'frequencies' and 'timestamps' and a 'threshold', and returns a list of tuples representing continuous segments in a musical recording where the frequency remains consistent within the given threshold. Each tuple should represent the start and end time of each segment where the frequency deviation is within the threshold.\n\nExample:\nGiven the input lists of frequencies [440.5, 442.1, 441.0, 600.3, 602.2, 800.0, 799.1, 600.4], timestamps [0, 1, 2, 5, 6, 10, 11, 15], and threshold 2.0, the output should be [(0, 2), (5, 6), (10, 11), (15, 15)].", "warnings": ["Solution failed correctness check.", "4, Edge Case Ambiguity: The problem statement does not specify how to handle edge cases where the input lists are empty. An explicit definition of expected behavior for edge cases like empty input lists would avoid ambiguity in the function implementation. For example, if both `frequencies` and `timestamps` are empty, should the function return an empty list or should it raise an error?"]}}
{"task_id": "hard/5", "prompt": "def soccer_team_division(players):\n    \"\"\"\n    The animals in the kingdom decided to have a soccer league. Given a list of animals where each animal is represented by a string that indicates its species and its skill level (e.g., 'rabbit_5', 'lion_10'), devise a function to split the animals into two teams such that:\n\n    - Each team has the same cumulative skill level.\n    - The missing numbers from the sequence of skill levels are excluded from consideration. E.g., if '3' and '6' are not present in the skill levels, players with these skill levels are not considered.\n    - Each species can only appear in one team.\n\n    Your function should return a list of two lists: the first list for team one, and the second list for the other. If it's impossible to partition the animals according to the given conditions, return an empty list.\n\n    Example:\n    Input: ['rabbit_5', 'hare_7', 'lion_10', 'tiger_9', 'fox_2']\n    Output: [['rabbit_5', 'hare_7'], ['lion_10', 'tiger_9']] # because 2 is the missing number from 1-10\n\n    Note:\n    An intriguing aspect is that the problem combines the care of missing number handling, ensuring the sum partition is feasible, and distributing the unique species across two competitive teams.\n    \"\"\"\n", "canonical_solution": "    def soccer_team_division(players):\n        import re\n        from collections import defaultdict\n        from itertools import combinations\n\n        def can_partition(nums):\n            total = sum(nums)\n            if total % 2 != 0:\n                return False\n            target = total // 2\n            dp = [False] * (target + 1)\n            dp[0] = True\n            for num in nums:\n                for i in range(target, num - 1, -1):\n if dp[i - num]:\n                        dp[i] = True\n            return dp[target]\n\n          \n        species_skill = defaultdict(list)\n        for player in players:\n            species, skill = re.match(r'(.*?)_([0-9]+)', player).groups()\n            species_skill[species].append(int(skill))\n\n        unique_skills = {skill for skills in species_skill.values() for skill in skills}\n        all_possible_skills = set(range(1, max(unique_skills) + 1))\n        missing_skills = all_possible_skills - unique_skills\n\n        valid_skills = [s for s in unique_skills if s not in missing_skills]\n        if not can_partition(valid_skills):\n            return []\n\n        def find_teams(skills, species_skill):\n            dp = {(0, frozenset()): ([], [])}\n            for skill in skills:\n                new_dp = dp.copy()\n                for (current_sum, species_set), (team1, team2) in dp.items():\n                    for species, species_skills in species_skill.items():\n                        if species not in species_set:\n                            next_sum = current_sum + skill\n                            if skill in species_skills:\n                                if next_sum <= sum(skills) // 2:\n                                    new_team1 = team1 + [f'{species}_{skill}']\n                                    new_team2 = team2[:]\n                                    new_species_set = species_set | {species}\n                                    new_dp[(next_sum, new_species_set)] = (new_team1, new_team2)\n                                else:\n                                    new_team1 = team1[:]\n                                    new_team2 = team2 + [f'{species}_{skill}']\n                                    new_species_set = species_set | {species}\n                                    new_dp[(sum(skills) - next_sum, new_species_set)] = (new_team1, new_team2)\n                dp = new_dp\n            return dp[(sum(skills) // 2, frozenset(species_skill.keys()))]\n\n        result = find_teams(valid_skills, species_skill)\n        return result\n", "test": "def check(candidate):\n    assert candidate(['rabbit_5', 'hare_7', 'lion_10', 'tiger_9', 'fox_2']) == [['rabbit_5', 'hare_7'], ['lion_10', 'tiger_9']]\n    assert candidate(['rabbit_5', 'lion_10', 'fox_2']) == []\n    assert candidate(['rabbit_5', 'hare_7', 'lion_10', 'tiger_9', 'wolf_8', 'fox_4', 'bear_3', 'deer_12', 'tiger_10', 'wolf_9']) == []\n    assert candidate(['rabbit_5', 'hare_5', 'lion_10', 'tiger_10', 'wolf_3', 'fox_3', 'rabbit_4', 'hare_4', ]) == [['rabbit_5', 'hare_5', 'wolf_3', 'fox_3'], ['lion_10', 'tiger_10', 'rabbit_4', 'hare_4']]\n    assert candidate(['rabbit_5', 'hare_5', 'lion_15', 'tiger_15', 'wolf_10', 'fox_10']) == []\n", "entry_point": "soccer_team_division", "extra_info": {"cover_story_words": ["talking animals", "sports"], "topics": ["Find Missing Number", "Partition Equal Subset Sum", "String Matching"], "cleaned_prompt": "def soccer_team_division(players):\n    \"\"\"\n    Write a function to divide animals into two teams with conditions:\n    1. Each team has the same cumulative skill level.\n    2. The missing numbers from the skill levels are excluded from consideration.\n    3. Each species can only appear in one team.\n\n    Return a list of two lists: one for each team. If division isn't possible, return an empty list.\n    Example\n    Input: ['rabbit_5', 'hare_7', 'lion_10', 'tiger_9', 'fox_2']\n    Output: [['rabbit_5', 'hare_7'],['lion_10', 'tiger_9']] because 2 is the missing number from 1-10.\n    \"\"\"\n", "warnings": ["Solution failed correctness check.", "5, Ambiguous Problem Specification: The problem statement indicates that players should only be considered if their skill levels create a contiguous range from 1 to some number n, excluding any missing numbers. However, it does not clearly establish how to handle scenarios where multiple contiguous ranges exist or where the highest-level numbers lead to ambiguous team splits, especially when constructing skill-balanced teams.", "4, Constraint on Skill Level Continuity: The stipulation that 'missing numbers from the sequence of skill levels are excluded from consideration' can result in logical inconsistencies or unresolvable problems. If certain players' skill levels are missing in sequential order (e.g., skill levels are 1, 2, 4, 5, 6 and 3 is missing, making player with skill level 3 invalid), determining valid sets becomes computationally complex or impossible, especially for larger datasets.", "4, Species Uniqueness Across Teams: The rule that each species can only appear in one team adds a significant complication. This complexity, combined with skill-level matching, significantly increases computational challenges and can make it impossible to find a valid solution even when one may exist theoretically, if only based on skill levels.", "5, Lack of Clear Definition for Input Size Limits: The problem does not outline bounds for the input size (number of players and range of skill levels). This lack of information can result in inefficiencies or failures when scaling to a large input size due to computational limits, especially with the complex calculations required as specified."]}}
{"task_id": "hard/2", "prompt": "def map_floating_islands(rocks):\n    \"\"\"\n    In an ancient world, there is a sky with floating islands made up of sentient rocks. Each rock on an island can only recognize and communicate with rocks on the same island. These rocks form polygonal islands when connected with the shortest line possible without intersecting with any other island. You are a part of a research team that wants to map out how these rocks cluster to form islands in a 2D plane.\n\n    Given a list of rocks represented as tuples of x and y coordinates, implement the Graham's scan algorithm to compute the convex hull for each cluster of rocks forming these floating islands. You will also need to ensure that these convex hulls do not intersect with one another. Once convex hulls are formed, find a maximum matching of these islands with a minimum distance metric using the Hopcroft-Karp Algorithm.\n\n    Example Input: [(0, 0), (3, 0), (0, 3), (3, 3), (1, 1), (2, 2), (4, 4)]\n    Example Output: [[[0, 0], [3, 0], [3, 3], [0, 3]], [[1, 1], [2, 2], [4, 4]]]\n\n    Notes:\n    - Assume the input list may have duplicate coordinates.\n    - You must prevent the convex hulls from intersecting with each other.\n    - Apply the Graham's scan algorithm to find the convex hull for each cluster of rocks.\n    - Then, use the Hopcroft-Karp algorithm to find effective matchings of the islands based on minimum distances.\n    \"\"\"\n", "canonical_solution": "    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    def graham_scan(points):\n        points = sorted(set(points))\n        if len(points) <= 1:\n            return points\n\n        lower = []\n        for p in points:\n            while len(lower) >= 2 and orientation(lower[-2], lower[-1], p) != 2:\n                lower.pop()\n            lower.append(p)\n\n        upper = []\n        for p in reversed(points):\n            while len(upper) >= 2 and orientation(upper[-2], upper[-1], p) != 2:\n                upper.pop()\n            upper.append(p)\n\n        return lower[:-1] + upper[:-1]\n\n    # Further code for Hopcroft-Karp and constraint handling goes here", "test": "def check(candidate):\n    assert candidate([(0, 0), (3, 0), (0, 3), (3, 3), (1, 1), (2, 2), (4, 4)]) == [[[0, 0], [3, 0], [3, 3], [0, 3]], [[1, 1], [2, 2], [4, 4]]]\n    assert candidate([(1, 1), (3, 3), (5, 5)]) == [[[1, 1], [3, 3], [5, 5]]]\n    assert candidate([(0, 0), (2, 0), (1, 3), (2, 2), (5, 1), (3, 4), (5, 0)]) == [[[0, 0], [5, 0], [2, 0], [5, 1], [3, 4], [1, 3]]]\n    assert candidate([(1, 0), (0, 1), (2, 2), (3, 3), (4, 5), (1, 5), (0, 4)]) == [[[0, 1], [2, 2], [0, 4], [1, 5], [4, 5], [3, 3], [1, 0]]]\n    assert candidate([(0, 0), (1, 1), (2, 1), (1, 0)]) == [[[0, 0], [2, 1], [1, 1], [1, 0]]]", "entry_point": "map_floating_islands", "extra_info": {"cover_story_words": ["floating island", "sentient rocks"], "topics": ["Brainteaser", "Graham's Scan", "Hopcroft-Karp Algorithm"], "cleaned_prompt": "Given a list of coordinates, use the Graham's scan algorithm to calculate the convex hulls for clusters forming separate polygons. Ensure these polygons don't intersect. Then use the Hopcroft-Karp algorithm to determine a maximum matching between these polygons considering the minimum distance. Sample Input: [(0, 0), (3, 0), (0, 3), (3, 3), (1, 1), (2, 2), (4, 4)]. Sample Output: [[[0, 0], [3, 0], [3, 3], [0, 3]], [[1, 1], [2, 2], [4, 4]]]", "warnings": ["Solution failed correctness check.", "4, Undefined_clusters: The problem statement does not clearly define how to cluster the rocks into separate islands, which is critical for forming the convex hulls. Without this information, implementing the Graham's scan algorithm becomes problematic as we cannot determine which points belong to which cluster.", "5, Algorithm_intersection_handling: The prompt instructs to ensure that convex hulls do not intersect with each other, but does not provide a method or criteria for doing so. This is a significant omission because without it, forming non-intersecting convex hulls according to the problem's requirements is infeasible."]}}
