{"task_id": "hard/3", "prompt": "def train_schedule_optimization(arrival_times, departure_times):\n    \"\"\"\n    In the world of Anachronia, a mysterious cave near the train station has been found to oscillate geological stability every hour causing different train platforms to be safe or unsafe.\n    Every hour, the safety of the platforms switches, which necessitates optimization of train schedules.\n\n    You are given two lists 'arrival_times' and 'departure_times' where each index corresponds to a particular train.\n    The 'arrival_times' list gives the timestamp (in hours) each train arrives and the 'departure_times' gives the timestamp each train departs.\n\n    To maximize safety and minimize the change on platforms, figure out the minimum number of platforms needed at the station such that no train needs to change its allocated platform due to the oscillating safety.\n\n    The function should implement a greedy approach utilizing a monotonic queue to efficiently track the platforms and provide the minimum number needed based on the provided times.\n\n    Example:\n    - arrival_times = [2, 2, 3]\n    - departure_times = [3, 4, 5]\n    If these are the arrival and departure times for 3 different trains, the minimum number of platforms needed would be 2 (one train arrives at 2 and leaves at 3, the second arrives at 2 and leaves at 4, and the third arrives at 3 and leaves at 5).\n\n    Note:\n    - The timestamps in 'arrival_times' and 'departure_times' are integers representing the hours.\n    - Both lists will have the same length and will be sorted in non-decreasing order.\n    - The returned value should be an integer representing the number of platforms needed.\n    \"\"\"\n", "canonical_solution": "    from sortedcontainers import SortedList\n\n    def train_schedule_optimization(arrival_times, departure_times):\n        if not arrival_times:\n            return 0\n        platforms = SortedList()\n\n        for i in range(len(arrival_times)):\n            if platforms and platforms[0] < arrival_times[i]:\n                platforms.pop(0)\n            platforms.add(departure_times[i])\n        return len(platforms)", "test": "def check(candidate):\n    assert candidate([2, 2, 3], [3, 4, 5]) == 2\n    assert candidate([1, 3, 5], [2, 4, 6]) == 1\n    assert candidate([1, 1, 1], [2, 3, 4]) == 3\n    assert candidate([], []) == 0\n    assert candidate([5, 7, 9, 15, 18], [8, 10, 12, 20, 24]) == 3\n    assert candidate([1, 2, 3, 4, 5], [10, 10, 10, 10, 10]) == 5", "entry_point": "train_schedule_optimization", "extra_info": {"cover_story_words": ["mysterious cave", "train station"], "topics": ["Greedy", "Monotonic Queue", "Binary Search"], "cleaned_prompt": "Write a function `train_schedule_optimization` that takes two sorted lists 'arrival_times' and 'departure_times' where each index corresponds to a particular train which tells the time each train arrives and departures respectively. The function should return the minimum number of platforms needed at the station using a greedy approach and a monotonic queue to ensure that no train needs to change its allocated platform amid oscillating safety of platforms.\nExample:\nWith arrival_times = [2, 2, 3] and departure_times = [3, 4, 5], the minimum number of platforms needed would be 2.", "warnings": ["Solution failed correctness check.", "5, Undefined Behavior with Oscillating Platform Safety: The problem statement introduces the concept of 'oscillating geological stability' affecting platform safety but fails to specify how this oscillation impacts the minimum platform calculation or how often it switches in relation to train schedules. This leaves a critical aspect of the task ambiguous and could lead to various interpretations that do not align, making the problem unusable without further clarification.", "5, Misleading Example: The example provided does not take into account the described oscillating safety of platforms, making it difficult to understand how exactly this should influence the algorithm or the logical considerations in minimizing platform changes. This inconsistency between the problem's narrative and the practical example poses a significant flaw as it fails to illustrate the complexity introduced by the 'oscillating safety' concept.", "4, Unclear Algorithm Requirement: While the prompt suggests using a 'greedy approach utilizing a monotonic queue,' it doesn't clearly define how this structure should be effectively used within the context of the problem, especially considering the undefined impact of the oscillating safety. The lack of clear guidance on implementing the specified data structure in relation to the problem scenario may leave participants guessing and result in a variety of unintended solution approaches."]}}
{"task_id": "hard/2", "prompt": "def plan_fairy_meetings(meetings):\n    \"\"\"\n    In the enchanted forest, fairies need to attend a series of meetings to stabilize the energy vortexes. Each meeting is scheduled at a specific time and takes place in different parts of the forest. The meeting times are provided as a list of tuples, where each tuple consists of two integers representing the start and end times of a meeting (inclusive). However, the spatial-temporal constraints of the forest mean not all meetings can be attended consecutively due to overlapping times. \n\n    Your task is to write a function that returns the maximum number of non-overlapping meetings a single fairy can attend.\n\n    For example:\n    - If input is [(1, 3), (2, 5), (4, 6)], fairies can only attend the first and last meetings [1, 3] and [4, 6], so you should return 2.\n    - For input [(1, 2), (3, 4), (5, 6)], fairies can attend all since there's no overlap, hence you should return 3.\n    \"\"\"\n", "canonical_solution": "def plan_fairy_meetings(meetings):\n    if not meetings:\n        return 0\n    # Sort meetings by their end times\n    meetings.sort(key=lambda x: x[1])\n    # Initialize with the first meeting\n    last_end_time = meetings[0][1]\n    count = 1\n    for start, end in meetings[1:]:\n        if start > last_end_time:\n            last_end_time = end\n            count += 1\n    return count", "test": "def check(candidate):\n    assert candidate([(1, 3), (2, 5), (4, 6)]) == 2\n    assert candidate([(1, 2), (3, 4), (5, 6)]) == 3\n    assert candidate([(0, 1), (2, 3), (1, 2)]) == 3\n    assert candidate([(10, 15), (16, 20), (21, 25)]) == 3\n    assert candidate([(5, 10), (10, 15), (15, 20)]) == 3\n    assert candidate([]) == 0\n    assert candidate([(1, 3), (3, 5), (4, 6), (7, 10), (9, 11)]) == 3\n    assert candidate([(5, 7), (6, 8), (9, 12)]) == 2", "entry_point": "plan_fairy_meetings", "extra_info": {"cover_story_words": ["fairy tale", "energy vortex"], "topics": ["Meeting Rooms", "Counting Sort", "Longest Palindromic Substring"], "cleaned_prompt": "Write a function that returns the maximum number of non-overlapping meetings a single fairy can attend. The meeting times are provided as a list of tuples, where each tuple consists of two integers representing the start and end times of a meeting. Return the maximum number of meetings a single fairy can attend consecutively without overlapping.\n\nExamples:\n- For input [(1, 3), (2, 5), (4, 6)], output should be 2.\n- For input [(1, 2), (3, 4), (5, 6)], output should be 3.", "warnings": ["Solution failed correctness check.", "5, Ambiguous Definition: The problem statement is inconsistent about the inclusiveness of the meeting end times in the description versus the tests provided. The prompt states that the meeting times are inclusive, which would imply that a meeting ending at time t and another starting at time t should be considered overlapping. However, the given test cases and the solution example treat these as non-overlapping (e.g., [(5, 10), (10, 15)]) which should have been counted as overlapping as per the inclusive definition but counts as non-overlapping and returns 3.", "4, Unclear Edge Cases: There's a lack of explicit handling or mention of what should be considered when there's contradictory meeting data such as negative time, zero or negative duration meetings, or extremely large values for start and end times. This may lead to incorrect implementations if edge cases are not considered."]}}
{"task_id": "hard/4", "prompt": "def teleporter_magic(matrix, operations):\n    \"\"\"\n    In a mystical land, a teleporter is represented as an NxM matrix where some cells contain enchanted stones ('S') and others contain mundane rocks ('R'). You have a magic wand that can perform a series of magical operations to manipulate this teleporter in order to optimize energy flow.\n\n    The magic wand can perform the following operations represented in the list of strings 'operations':\n    - 'row X': convert all stones ('S') in row X to rocks ('R').\n    - 'col Y': convert all stones ('S') in column Y to rocks ('R').\n    - 'orient magic': switch the matrix orientation from rows to columns, meaning transposing the matrix.\n\n    After each operation, if any row or column contains only rocks ('R'), it should be filled entirely with stones ('S'). This process can reverse effects of earlier operations in certain cases and is essential to maintain the teleporter's balance.\n\n    Return the matrix state after applying all the operations.\n\n    Example:\n    Input: matrix = [['S', 'S', 'R'], ['R', 'S', 'S']], operations = ['col 2', 'orient magic']\n    Output: [['S', 'S'], ['S', 'R'], ['S', 'S']]\n\n    Example:\n    Input: matrix = [['S', 'R'], ['R', 'S']], operations = ['row 0', 'col 1', 'orient magic', 'row 1']\n    Output: [['S', 'S'], ['S', 'R']]\n\n    Note:\n    Each 'row X' or 'col Y' operation is 0-indexed. The operations list can be empty, meaning the matrix should be returned as is. \n    \"\"\"\n", "canonical_solution": "def teleporter_magic(matrix, operations):\n    def transpose(mat):\n        return [list(row) for row in zip(*mat)]\n\n    def flip_row(mat, r):\n        for c in range(len(mat[0])):\n            if mat[r][c] == 'S':\n                mat[r][c] = 'R'\n        if mat[r].count('R') == len(mat[0]):\n            mat[r] = ['S'] * len(mat[0])\n\n    def flip_col(mat, col):\n        for r in range(len(mat)):\n            if mat[r][col] == 'S':\n                mat[r][col] = 'R'\n        if all(mat[r][col] == 'R' for r in range(len(mat))):\n            for r in range(len(mat)):\n                mat[r][col] = 'S'\n\n    for op in operations:\n        parts = op.split()\n        if parts[0] == 'row':\n            flip_row(matrix, int(parts[1]))\n        elif parts[0] == 'col':\n            flip_col(matrix, int(parts[1]))\n        elif parts[0] == 'orient magic':\n            matrix = transpose(matrix)\n\n    return matrix", "test": "def check(candidate):\n    assert candidate([['S', 'S', 'R'], ['R', 'S', 'S']], ['col 2', 'orient magic']) == [['S', 'S'], ['S', 'R'], ['S', 'S']]\n    assert candidate([['S', 'R'], ['R', 'S']], ['row 0', 'col 1', 'orient magic', 'row 1']) == [['S', 'S'], ['S', 'R']]\n    assert candidate([['S', 'S'], ['S', 'S']], []) == [['S', 'S'], ['S', 'S']]\n    assert candidate([['R', 'S'], ['R', 'R']], ['row 0', 'row 1', 'col 0']) == [['S', 'S'], ['S', 'R']]\n    assert candidate([['S', 'R'], ['S', 'R']], ['orient magic', 'col 1']) == [['S', 'S'], ['R', 'S']]\n    assert candidate([['S', 'S'], ['R', 'R']], ['row 1', 'col 0', 'orient magic', 'col 0']) == [['S', 'R'], ['S', 'S']]", "entry_point": "teleporter_magic", "extra_info": {"cover_story_words": ["teleporter", "magic wand"], "topics": ["Stack", "Set Matrix Zeroes", "Sliding Window"], "cleaned_prompt": "Write a function that manipulates a matrix (NxM) depicting a teleporter with different operations. If a matrix row or column turns entirely into 'R' after an operation, it should be inverted to all 'S'. The operations include setting entire rows or columns to 'R', or transposing the matrix. Return the final state of the matrix after all operations.", "warnings": ["Solution failed correctness check.", "4, Ambiguous operation description: The operation \"orient magic\" described as \"switch the matrix orientation from rows to columns\" implies a matrix transpose, but the term \"orientation\" could be confusing. It should be clarified that \"orient magic\" specifically means to transpose the matrix."]}}
{"task_id": "hard/5", "prompt": "def enchanted_classroom(seating, whispers):\n    \"\"\"\n    In a classroom at a magic school, students are seated in a line with varying magical powers. Each student is represented by an integer in the list `seating` where the integer represents the student's power level. However, due to some mischievous fairies, some students start whispering spells to their neighbors.\n\n    The `whispers` list consists of tuples (i, j), indicating that student i is whispering a spell to student j. This whisper increases the power of student j by the power of student i.\n\n    The goal of this function is to determine the final power levels of each student after all the spells from their neighbors have been applied. Note that whispers can have a cumulative effect (a student can receive power from multiple peers), and the spells are instantaneous meaning they all happen at the same time.\n\n    Example:\n    seating = [10, 20, 30]\n    whispers = [(0, 1), (1, 2), (0, 2)]\n\n    The output should be [10, 30, 60] because:\n    - Student 0 (with power 10) whispers to Student 1, making Student 1's power 20 + 10 = 30\n    - Student 1 (with power 20) whispers to Student 2, making Student 2's power 30 + 20 = 50\n    - Student 0 also whispers directly to Student 2, adding another 10, making Student 2's power 50 + 10 = 60\n\n    Constraints:\n    - `seating` has at least 2 and at most 1000 students.\n    - `whispers` list size will be at most 10000.\n\n    Employ a method using graph theory and ensure each student has their final calculated power effectively.\n    \"\"\"", "canonical_solution": "def enchanted_classroom(seating, whispers):\n    n = len(seating)\n    final_powers = seating[:]\n    # Initialize graph with number of students\n    graph = [[] for _ in range(n)]\n    # Graph creation\n    for src, dest in whispers:\n        graph[src].append(dest)\n\n    # Distribute the powers from each student to the others\n    for i in range(n):\n        for neighbor in graph[i]:\n            final_powers[neighbor] += seating[i]\n\n    return final_powers", "test": "def check(candidate):\n    assert candidate([10, 20, 30], [(0, 1), (1, 2), (0, 2)]) == [10, 30, 60]\n    assert candidate([40, 50, 20], [(1, 0), (2, 1)]) == [90, 70, 20]\n    assert candidate([100, 200], [(0, 1)]) == [100, 300]\n    assert candidate([1, 2, 3, 4, 5], [(0, 1), (1, 2), (2, 3), (3, 4)]) == [1, 3, 5, 7, 9]\n    assert candidate([10, 5, 25, 40, 10], [(0, 1), (1, 2), (2, 3), (3, 4), (0, 4), (4, 0)]) == [20, 15, 30, 65, 50]", "entry_point": "enchanted_classroom", "extra_info": {"cover_story_words": ["school", "mischievous fairies"], "topics": ["Dynamic Programming", "Line Sweep", "Finding Articulation Points in Graphs"], "cleaned_prompt": "Write a function that adjusts the power level of students based on the given whispers. The input includes two lists: `seating`, representing students' initial powers, and `whispers`, where each whisper (i, j) means student i adds their power to student j's power. All whispers are simultaneous.", "warnings": ["Solution failed correctness check.", "5, Missing Input Validation: The problem statement does not specify what should happen if the indexes in the 'whispers' tuples are out of the bounds of the 'seating' list. This could lead to runtime errors if the function tries to access an index that does not exist in the 'seating' list.", "4, Ambiguity in Problem Definition: There's no clarification provided on whether the interactions (whispers) can cycle (e.g., student A whispers to student B, student B to student C, and student C back to student A). The presence of cycles can significantly affect the logic required to solve the problem, especially in relation to maintaining the simultaneity of effects. The example test case involving a cycle does not detail if additional complexity should be handled or if such cases might be omitted.", "4, Unclear Error Handling: The problem does not specify how to handle invalid input, such as negative indices in 'whispers', non-integer values in 'seating' or 'whispers', or empty lists. Making assumptions about these can lead to varying implementations, potentially affecting the robustness and reliability of the solution.", "4, Inadequate Explanation of Example: While the example output explanation adds the values correctly, it contradicts the given output. The walkthrough adds up to [10, 30, 60], but the calculation described adds up to [10, 30, 70] by adding 50 (current power of 2) + 20 (power of 1 after the initial whisper from 0 to 1). This inaccuracy can confuse readers about how the whispers propagate and in which order, impacting their understanding of the problem logic."]}}
{"task_id": "hard/1", "prompt": "def find_min_risk_path(grid, start, finish):\n    \"\"\"\n    Imagine a hidden lagoon filled with treasures varying on its danger level represented as a grid. Each cell in the grid contains a number representing the risk of passing through that cell. The task is to find the minimum risk path from the start to the finish point using a combination of a Monotonic Queue and Convex Hull design.\n\n    The grid is a list of lists of integers where each integer represents the risk level. The goal is to go from the start (top-left, grid[0][0]) to the finish (bottom-right, grid[-1][-1]) position in the grid. You may only move right or down at any step.\n\n    For instance, consider the following grid:\n    [[1, 2, 3],\n     [4, 5, 1],\n     [1, 5, 1]]\n    A good candidate path might be: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) with a risk level sum of 8.\n\n    Note:\n    - Use the concepts of a Monotonic Queue and Convex Hull to find the optimal path efficiently.\n    - Enforce that your solution utilizes these data structures in your pathfinding algorithm to manage complexity.\n    \"\"\"\n", "canonical_solution": "from collections import deque\n\ndef is_valid_point(x, y, grid):\n    return 0 <= x < len(grid) and 0 <= y < len(grid[0])\n\ndef find_min_risk_path(grid, start, finish):\n    if not grid or not grid[0]:\n        return float('inf')\n    m, n = len(grid), len(grid[0])\n    risk = [[float('inf')] * n for _ in range(m)]\n    risk[start[0]][start[1]] = grid[start[0]][start[1]]\n    queue = deque([(start[0], start[1])])\n    directions = [(0, 1), (1, 0)]\n    while queue:\n        x, y = queue.popleft()\n        current_risk = risk[x][y]\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid_point(nx, ny, grid) and current_risk + grid[nx][ny] < risk[nx][ny]:\n                risk[nx][ny] = current_risk + grid[nx][ny]\n                if (dx, dy) == (0, 1):\n                    # Monotonically increase the queue for horizontal move\n                    while queue and risk[queue[-1][0]][queue[-1][1]] > risk[nx][ny]:\n                        queue.pop()\n                queue.append((nx, ny))\n    return risk[finish[0]][finish[1]]", "test": "def check(candidate):\n    # Test case for a simple risk grid\n    assert candidate([[1, 2, 3], [4, 5, 1], [1, 5, 1]], (0, 0), (2, 2)) == 8\n    # Test cases with increasing grid sizes and complexities\n    assert candidate([[1, 100, 1, 100], [100, 1, 100, 1], [1, 100, 1, 100], [100, 1, 100, 1]], (0, 0), (3, 3)) == 4\n    assert candidate([[1]], (0, 0), (0, 0)) == 1\n    assert candidate([[10, 4, 3], [2, 1000, 6], [8, 9, 1]], (0, 0), (2, 2)) == 14\n    # Edge case: large grid to test efficiency\n    large_grid = [[1]*1000 for _ in range(1000)]\n    assert candidate(large_grid, (0, 0), (999, 999)) == 1998", "entry_point": "find_min_risk_path", "extra_info": {"cover_story_words": ["hidden lagoon", "treasure"], "topics": ["Monotonic Queue", "Convex Hull", "Design"], "cleaned_prompt": "Write a function that finds the minimum risk path in a grid from the start position (top-left) to the finish position (bottom-right). You can only move right or down. Utilize the concepts of a Monotonic Queue and Convex Hull to efficiently determine the path.", "warnings": ["Solution failed correctness check.", "5, Misleading Algorithm Requirement: The problem prompt requires the use of a \"Monotonic Queue and Convex Hull\" design, yet the essence and application of a Convex Hull are not applicable to this grid-based pathfinding context. Convex Hulls are predominantly used in computational geometry to solve problems related to the shape or structure of a dataset, not path minimization in grids where dynamic programming or Dijkstra's algorithm would suffice. This usage can confuse participants or lead to incorrect implementations.", "4, Unclear Implementation Details: The prompt mentions using a Monotonic Queue which is relatively clear in its application for keeping minimum or maximum values in order. However, it does not provide any detailed reasoning or example on how the Convex Hull should be utilized in this grid pathfinding task, which might leave participants puzzled about the actual expectations."]}}
