{"task_id": "hard/2", "prompt": "def decode_enchanted_mirror_instructions(instructions):\n    \"\"\"\n    Inside a haunted house, there's an enchanted mirror that only accepts a string of commands that match a particular pattern.\n    The commands are encoded as a string composed of digits from '1' to '9', each mapping uniquely to one of the behaviors the mirror can manifest.\n\n    The mapping from digits to behaviors is:\n    '1' -> 'Open', '2' -> 'Close', '3' -> 'Lock', '4' -> 'Unlock', '5' -> 'Smile',\n    '6' -> 'Frown', '7' -> 'Glow', '8' -> 'Dim', '9' -> 'Fog up'\n\n    The enchanted mirror will only activate if the sequence of commands can decode to a series of actions which alternate exactly between \"manipulate state\" (including Open, Close, Lock, Unlock) and \"alter appearance\" (including Smile, Frown, Glow, Dim, Fog up).\n\n    The additional twist involves the capability of 'double-digit' commands, where patterns like '34' could be interpreted as 'Lock' followed by 'Unlock', or as 'Unlock' (a hypothetical behavior mapped by '34').\n    For simplicity, we'll assume no '10'-'99' mappings are valid except those which directly follow a pattern in the basic one-digit set.\n\n    The function should return the number of ways to decode the string such that the resultant behaviors alternate correctly between the two types.\n\n    Example:\n    - If instructions = '151', the decoded behaviors could be: ['Smile', 'Open'] or ['Smile', 'Frown', 'Open'], but only the first follows the correct alternation. Thus, the result would be 1.\n\n    - If instructions = '3482', potential decodings are: ['Lock', 'Unlock', 'Dim'] and ['Unlock', 'Dim'], both of which correctly alternate, hence the result should be 2.\n\n    Note:\n    - If no valid interpretation exists that fits the alternation, return 0.\n\n    \"\"\"", "canonical_solution": "    def is_manipulate_state(behavior):\n        return behavior in ['Open', 'Close', 'Lock', 'Unlock']\n\n    def is_alter_appearance(behavior):\n        return behavior in ['Smile', 'Frown', 'Glow', 'Dim', 'Fog up']\n\n    behavior_map = {\n        '1': 'Open', '2': 'Close', '3': 'Lock', '4': 'Unlock', '5': 'Smile',\n        '6': 'Frown', '7': 'Glow', '8': 'Dim', '9': 'Fog up'\n    }\n\n    def decode(s, index, last_type, memo):\n        if index == len(s):\n            return 1\n        if index in memo:\n            return memo[index]\n\n        total = 0\n        for length in [1, 2]:\n            if index + length <= len(s):\n                substring = s[index : index + length]\n                if substring in behavior_map:\n                    current_behavior = behavior_map[substring]\n                    current_type = 'manipulate' if is_manipulate_state(current_behavior) else 'alter'\n                    if last_type != current_type:\n                        total += decode(s, index + length, current_type, memo)\n\n        memo[index] = total\n        return total\n\n    return decode(instructions, 0, None, {})", "test": "def check(candidate):\n    assert candidate('151') == 1\n    assert candidate('3482') == 2\n    assert candidate('926') == 0\n    assert candidate('569141') == 2\n    assert candidate('99181') == 1\n    assert candidate('123459') == 4", "entry_point": "decode_enchanted_mirror_instructions", "extra_info": {"cover_story_words": ["haunted house", "enchanted mirror"], "topics": ["Game Theory", "Decode Ways", "String Matching"], "cleaned_prompt": "Write a function that takes a string of numbers representing commands and maps it to behaviors (specifically alternating between state manipulation and appearance alteration). The function should return the number of valid ways to decode the string according to the provided mappings, considering both single-digit and certain double-digit combinations. Each decoded sequence must strictly alternate between the two types of behaviors.", "warnings": ["Solution failed correctness check.", "5, Ambiguity in double-digit mapping: The prompt mentions the possible use of 'double-digit' commands but does not provide clear mapping details for two-digit combinations other than those that follow a pattern in the basic one-digit set. This presents a significant issue as it leaves the behavior for double-digit commands (except those implied like '34' described) undefined, potentially leading to multiple interpretations or errors in implementing the solution.", "5, Alternation rule clarity: The requirement that the sequence must alternate between \"manipulate state\" and \"alter appearance\" behaviors is clear, but the prompt does not specify what should happen if a valid double-digit command breaks this alternation. It is unclear whether such sequences should be considered invalid or if there's an implicit rule that must be deduced by the implementer.", "4, Test case coverage: The test cases provided might not adequately check all edge cases, especially around boundaries of behaviors like sequences that do not allow for any alternation, single-digit versus double-digit boundary conditions, or consecutive identical digits (e.g., '777' or '33'). This may result in incomplete validation of the solution's correctness."]}}
{"task_id": "hard/5", "prompt": "def overlapping_reservations(reservations):\n    \"\"\"\n    Imagine you are designing a system for a restaurant on a boat. The restaurant has limited capacity, and it is crucial to keep track of reservations to avoid overbooking.\n    Given a list of reservation entries, each entry is a string formatted as '<name>-<start>-<end>', where:\n\n    - <name> is the customer's name,\n    - <start> is the start time in 24-hour format (HHMM, e.g., '1845' for 6:45 PM),\n    - <end> is the end time in 24-hour format (HHMM).\n\n    You need to determine if there are any overlapping reservations. Return True if there are overlaps, else False.\n    Reservation times are inclusive, meaning from start to the start of the end time (exclusive).\n\n    Note:\n    - If <start> is equal to or later than <end>, the reservation is invalid and should be ignored.\n    - You need to process potentially large numbers of reservation entries, so your solution should be efficient.\n\n    Examples:\n    - overlapping_reservations(['Alice-1200-1300', 'Bob-1230-1330']) should return True because Bob's reservation starts before Alice's ends.\n    - overlapping_reservations(['Charlie-0700-0800', 'Delta-0800-0900']) should return False as Delta's reservation starts exactly when Charlie's ends.\n\n    \"\"\"", "canonical_solution": "    def overlapping_reservations(reservations):\n        cleaned_reservations = []\n        for entry in reservations:\n            name, start, end = entry.split('-')\n            start, end = int(start), int(end)\n            if start < end:\n                cleaned_reservations.append((start, end))\n        cleaned_reservations.sort()\n        previous_end = 0\n        for start, end in cleaned_reservations:\n            if start < previous_end:\n                return True\n            previous_end = end\n        return False", "test": "def check(candidate):\n    assert candidate(['Alice-1200-1300', 'Bob-1230-1330']) == True\n    assert candidate([]) == False\n    assert candidate(['Charlie-0700-0800', 'Delta-0800-0900']) == False\n    assert candidate(['Eve-1100-1200', 'Frank-1200-1300', 'Gina-1150-1210']) == True\n    assert candidate(['Henry-2100-2200', 'Ivy-2000-2100']) == False\n    assert candidate(['Jack-1300-1400', 'Jack-1400-1500', 'Kate-1330-1430']) == True\n    assert candidate(['Larry-0930-1015', 'Mona-1015-1100']) == False\n    assert candidate(['Nate-1500-1600', 'Olivia-1600-1700', 'Pat-1500-1700']) == True\n    assert candidate(['Quinn-0845-0915', 'Rosa-0910-1000']) == True", "entry_point": "overlapping_reservations", "extra_info": {"cover_story_words": ["restaurant", "boat"], "topics": ["Concurrency", "Hash Table", "String"], "cleaned_prompt": "Given a list of reservation entries formatted as '<name>-<start>-<end>', determine if there are any overlapping reservations. If a time range overlaps with any other, return True; otherwise return False. Ignore invalid reservations where <start> is not less than <end>. Example: overlapping_reservations(['Alice-1200-1300', 'Bob-1230-1330']) should return True because there is an overlap.", "warnings": ["Solution failed correctness check.", "4, Ambiguous Input Formatting: The problem expects the input in '<name>-<start>-<end>' format but does not specify how strictly formatted the inputs will be, creating potential issues in parsing inputs. For instance, there could be names with dashes or malformed input strings which can result in runtime errors or incorrect processing.", "4, Efficiency Concerns Not Benchmarked: While the prompt hints at needing an efficient solution due to potentially large numbers of reservation entries, there is no specifics provided on the expected limits (e.g., maximum number of entries), which makes it difficult to assess whether the provided solution meets necessary performance criteria for all edge cases."]}}
{"task_id": "hard/4", "prompt": "def haunted_ship_signals(n_signals, strike_times, energy_levels):\n    \"\"\"\n    The legendary haunted ship 'Ghostly Galleon' emerges every century. Legends say it harnesses the power of energetic lightning strikes, generating signals in a mysterious pattern. Being a part of a research team, you're tasked to analyze these signals in order to predict the next emergence.\n\n    The ship's signals can be described as a sequence of n_signals unique natural numbers. Each signal corresponds to a particular lightning strike, marked by its time since the beginning of the storm and its energy level.\n\n    Every subset of these signals can potentially form a pattern. Your task is to determine the product of the most powerful subset-pattern.\n    A subset is considered powerful based on the product of the unique energy levels within it, multiplied by the product of the unique times within it, modulo 1_000_000_007.\n\n    Given this, you must find:\n    - the maximal product of any subset of signals using the described criteria.\n\n    Example:\n    - n_signals=3\n    - strike_times=[1, 10, 100]\n    - energy_levels=[5, 10, 5]\n    The possible subset-pattern products are computed for each subset. The subset [1, 10, 100] with energies [5, 10, 5] results in a pattern-product of 5 (unique energies) * 110 (unique times) = 550, which would be modulated as 550 % 1_000_000_007.\n\n    Note:\n    - Strike times and energy levels are provided as lists of the same length, corresponding to n_signals.\n    - There might be overlapping times or energies in different signals, therefore, consider the unique elements when calculating the pattern product.\n\n    Constraints:\n    - 1 <= n_signals <= 50\n    - 1 <= strike_times[i], energy_levels[i] <= 10^9\n    \"\"\"", "canonical_solution": "def haunted_ship_signals(n_signals, strike_times, energy_levels):\n    from itertools import combinations\n    mod = 1_000_000_007\n\n    def prod(items):\n        result = 1\n        for item in items:\n            result = (result * item) % mod\n        return result\n\n    max_product = 0\n    indices = list(range(n_signals))\n\n    for subset_size in range(1, n_signals + 1):\n        for subset_indices in combinations(indices, subset_size):\n            unique_times = set(strike_times[i] for i in subset_indices)\n            unique_energies = set(energy_levels[i] for i in subset_indices)\n            subset_product = prod(unique_times) * prod(unique_energies) % mod\n            max_product = max(max_product, subset_product)\n\n    return max_product", "test": "def check(candidate):\n    assert candidate(3, [1, 10, 100], [5, 10, 5]) == 550\n    assert candidate(3, [50, 50, 100], [20, 20, 30]) == 3000\n    assert candidate(4, [1, 2, 3, 4], [1, 2, 3, 4]) == 288\n    assert candidate(5, [100, 200, 300, 400, 500], [1, 2, 3, 4, 5]) == 12000000\n    assert candidate(6, [1, 1, 1, 2, 2, 2], [2, 3, 4, 5, 6, 7]) == 56", "entry_point": "haunted_ship_signals", "extra_info": {"cover_story_words": ["haunted ship", "energetic lightning"], "topics": ["Subsets", "Rolling Hash", "Shell"], "cleaned_prompt": "Write a function to determine the maximal product of subsets from lists of strike times and energy levels of signals. The product of a subset is defined as the product of unique strike times multiplied by the product of unique energy levels, mod 1,000,000,007.", "warnings": ["Solution failed correctness check.", "5, Problem Inconsistency with Modulus: The example provided in the prompt states the maximum product subset result modulo 1_000_000_007, yet the test case results do not align with this convention. The test cases do not apply the modulus operation to the results, which contradicts the specification outlined in the prompt. This inaccuracy might lead to incorrect implementation or testing.", "5, Misleading Test Case: The test case assertion `assert candidate(3, [1, 10, 100], [5, 10, 5]) == 550` explicitly provides a result of 550, which should be incorrect if the modulus operation as per the problem statement were correctly applied. This could confuse participants about the expected output format and the operational definition, leading to failed implementations despite following prompt guidelines.", "4, Complexity and Performance Issue: The proposed solution's methodology of computing powersets using combinations from the `itertools` module without any optimizations can lead to severe efficiency issues as the number of signals increases. The potential size of the powerset grows exponentially with `n_signals`, which can severely degrade performance especially since `n_signals` can go up to 50, making the approach practically unusable."]}}
{"task_id": "hard/3", "prompt": "def future_city_events(inputs):\n    \"\"\"\n    In the futuristic city of Chronopolis, there are critical events (represented as integers) that can happen over time, with some events dependent on the occurrence of previous ones. Your task is to determine the number of valid orders of these events in which they can occur, constrained by certain pairs of events that must not happen consecutively.\n\n    You are given an array 'inputs' where the first element is a list of integers representing events and the second element is an array of pairs (tuples) where each pair (a, b) indicates that events 'a' and 'b' cannot happen consecutively.\n\n    Your function should implement an efficient strategy (Hint: Merge Sort based operations for counting while adhering to Game Theory to optimize orderings) to calculate the total number of valid event orders.\n\n    Example:\n    If inputs = [[1, 2, 3], [(1, 2), (2, 3)]]\n    The output should be 1. Here only one valid order exists: [1, 3, 2] or [3, 1, 2] as neither 1 can directly follow or precede 2 nor can 2 follow or precede 3.\n\n    Note:\n    - The list of events will always have at least one element.\n    - The list of forbidden pairs may be empty, in which case all permutations are valid.\n    \"\"\"\n", "canonical_solution": "    def count_valid_orders(events, constraints):\n        def is_valid_sequence(sequence):\n            for i in range(len(sequence) - 1):\n                if (sequence[i], sequence[i+1]) in constraints_set or (sequence[i+1], sequence[i]) in constraints_set:\n                    return False\n            return True\n\n        def merge_count(arr):\n            if len(arr) < 2:\n                return arr, 1\n            mid = len(arr) // 2\n            left_sorted, left_count = merge_count(arr[:mid])\n            right_sorted, right_count = merge_count(arr[mid:])\n\n            sorted_arr = []\n            i = j = 0\n            total_count = left_count * right_count\n\n            while i < len(left_sorted) and j < len(right_sorted):\n                if is_valid_sequence([left_sorted[i], right_sorted[j]]):\n                    sorted_arr.append(left_sorted[i])\n                    i += 1\n                else:\n                    sorted_arr.append(right_sorted[j])\n                    j += 1\n\n            sorted_arr.extend(left_sorted[i:])\n            sorted_arr.extend(right_sorted[j:])\n            return sorted_arr, total_count\n\n        constraints_set = set(constraints)\n        _, total_orders = merge_count(events)\n        return total_orders", "test": "def check(candidate):\n    assert candidate([[2, 3, 4], [(2, 4)]] == 5)\n    assert candidate([[1, 2, 3], []]) == 6\n    assert candidate([[1, 2, 3], [(1, 2), (2, 3)]]) == 1\n    assert candidate([[1, 2, 3, 4], [(1, 2), (2, 4)]] == 11)\n    assert candidate([[1], []]) == 1\n    assert candidate([[5, 3, 9, 6], [(9, 6)]]) == 20", "entry_point": "future_city_events", "extra_info": {"cover_story_words": ["future city", "time travel"], "topics": ["Game Theory", "Counting", "Merge Sort"], "cleaned_prompt": "def future_city_events(inputs):\n    \"\"\"\n    Given a list of events and pairs of events that cannot be consecutive, calculate the total number of valid sequences of event occurrences.\n\n    Args:\n    inputs (list): The first element is a list of integers (events), and the second element is a list of tuples where each tuple (a, b) denotes that event 'a' cannot be followed by event 'b' (and vice-versa).\n\n    Returns:\n    int: Total number of valid sequences.\n    \"\"\"\n", "warnings": ["Solution failed correctness check.", "4, Mismatching problem description and solution complexity: The task description suggests a relatively complex approach involving \"Merge Sort based operations\" and \"Game Theory\" without detailing how these are hypothetically applied to generating valid event orderings. This level of complexity may not be necessary and the provided canonical solution does not appear to strictly follow the hinted approaches, leading to potential confusion or mismatches in expected solution strategies."]}}
{"task_id": "hard/1", "prompt": "def museum_security(grid):\n    \"\"\"\n    In a cyberpunk future, museums have implemented a high-tech grid-based security system. Each room in the grid receives a security rating. You are given a matrix 'grid' that represents the museum's layout where each cell corresponds to a room and contains the security rating (an integer) of that room.\n\n    However, the user interface only displays the median security rating of all rooms currently visible. The visibility of rooms changes dynamically based on certain conditions, and the guard needs to see the updated median quickly.\n\n    Write a program that provides an efficient way to compute the median of the security ratings in the matrix dynamically if the matrix could be updated repeatedly. Assume that initially, the whole matrix is visible, but over time updates to individual room's ratings may happen.\n\n    - When the rating of a particular room changes, the matrix should be updated, and the median should be recalculated.\n    - Assume the matrix can be as large as 100x100 and updates often.\n    - The matrix 'grid' contains integers representing security ratings.\n    \"\"\"\n", "entry_point": "museum_security", "canonical_solution": "    import bisect\n    class MedianFinder:\n        def __init__(self):\n            self.data = []\n\n        def add_num(self, num):\n            bisect.insort_left(self.data, num)\n\n        def find_median(self):\n            n = len(self.data)\n            if n % 2 == 0:\n                return (self.data[n//2-1] + self.data[n//2]) / 2.0\n            else:\n                return self.data[n//2]\n\n    def museum_security(grid):\n        finder = MedianFinder()\n        for row in grid:\n            for value in row:\n                finder.add_num(value)\n        median = finder.find_median()\n\n        # For updates to grid, the following code should be used:\n        # Example of update: grid[x][y] = new_value; finder.add_num(new_value); median = finder.find_median()\n\n        return median\n", "test": "def check(candidate):\n    initial_grid = [\n        [1, 3, 2],\n        [8, 7, 6],\n        [5, 9, 4]\n    ]\n    assert candidate(initial_grid) == 5.0, 'Initial median wrong'\n\n    # Update room at position (2, 2) to 10\n    initial_grid[2][2] = 10\n    assert candidate(initial_grid) == 5.5, 'Median after first update wrong'\n\n    # Update room at position (0, 0) to 5\n    initial_grid[0][0] = 5\n    assert candidate(initial_grid) == 5.5, 'Median after second update wrong'\n\n    # Update one more time\n    initial_grid[1][0] = 5\n    assert candidate(initial_grid) == 5.5, 'Median after third update wrong'\n\n    # Large uniform matrix\n    large_grid = [[5]*100 for _ in range(100)]\n    assert candidate(large_grid) == 5.0, 'Large uniform matrix median incorrect'\n    \n    large_grid[0][0] = 100\n    assert candidate(large_grid) == 5.0, 'Median after change in large grid incorrect'\n", "extra_info": {"cover_story_words": ["cyberpunk", "museum"], "topics": ["Matrix", "Find Median from Data Stream", "Hash Function"], "cleaned_prompt": "Write a function that provides an efficient way to compute the median of the security ratings in a matrix dynamically as the matrix gets updated repeatedly. Initially, the whole matrix is visible, and the median of all its ratings is needed. Subsequent updates to individual room ratings should be handled, with the median recalculated efficiently", "warnings": ["Solution failed correctness check.", "5, IncompleteUpdateMechanism: The proposed solution does not correctly handle updates to the matrix in a way that maintains accurate information for median calculation. While the canonical solution suggests adding new values with `finder.add_num(new_value)`, it does not remove or adjust the old values that are being replaced in the grid by these updates. This will lead to incorrect median values since the data structure will contain outdated or irrelevant numbers.", "4, UndefinedBehaviorForUpdates: The problem statement and test descriptions mention that the matrix can be updated, but the pseudocode and canonical implementation do not clearly demonstrate how these updates should be processed beyond simply adding a new number to the data structure. This lack of clarity and explicit handling for updating the Grid's actual entries before recalculating the median could lead to ambiguity and incorrect implementation in a real-world scenario."]}}
