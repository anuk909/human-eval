{"task_id": "hard/2", "prompt": "def minimum_light_spanning_tree(points, connections, light_intensity):\n    \"\"\"\n    There exists an enchanted bioluminescent ocean where mischievous fairies have placed luminous orbs to light their nighttime revels. Each orb has a distinct light intensity and can connect to certain other orbs. You need to ensure that all orbs are connected using the minimum number of connections while maximizing the overall light intensity.\n\n    Each connection between two orbs, also has a 'cost' associated with it which represents the amount of magic needed to keep that connection active. The lower the cost, the better.\n\n    Write a function that, given a list of points representing orbs, a list corresponding matrix of connections representing the cost to connect each pair of points (or float('inf') if they cannot be connected directly), and a list of light intensities of each orb, returns the maximum light intensity of the minimum spanning tree that connects all orbs using Prim's Algorithm.\n\n    Constraints:\n    - The number of orbs will be at least 1 and at most 1000.\n    - Each entry in connections will be either a positive integer or float('inf').\n    - Light intensity is represented as an integer.\n\n    Example:\n    points = ['A', 'B', 'C', 'D']\n    connections = [\n        [0, 10, float('inf'), 30],\n        [10, 0, 50, float('inf')],\n        [float('inf'), 50, 0, 20],\n        [30, float('inf'), 20, 0]\n    ]\n    light_intensity = [5, 20, 15, 10]\n\n    The required function would return 45 as the maximum light intensity of the minimum spanning tree which would consist of connections A-B, A-D, D-C with corresponding orbs of intensities 20, 10, and 15 respectively.\n    \"\"\"\n", "canonical_solution": "    import heapq\n\n    def maximum_intensity_orb_prims(connections, light_intensity):\n        n = len(connections)\n        max_intensity = [0] * n\n        in_mst = [False] * n\n        heap = [(0, 0)]  # Use light intensity instead of costs for Prim's to prioritize high light\n\n        while heap:\n            intensity, node = heapq.heappop(heap)\n            if in_mst[node]:\n                continue\n\n            max_intensity[node] = intensity\n            in_mst[node] = True\n\n            for adj_node, cost in enumerate(connections[node]):\n                if not in_mst[adj_node] and connections[node][adj_node] != float('inf'):\n                    heapq.heappush(heap, (-light_intensity[adj_node], adj_node))\n\n        return sum(light_intensity[i] for i, included in enumerate(in_mst) if included)\n", "test": "def check(candidate):\n    assert candidate(['A', 'B', 'C', 'D'], [[0, 10, float('inf'), 30],[10, 0, 50, float('inf')],[float('inf'), 50, 0, 20], [30, float('inf'), 20, 0]], [5, 20, 15, 10]) == 45\n    assert candidate(['W', 'X', 'Y', 'Z'], [[0, 1, float('inf'), float('inf')], [1, 0, 1, float('inf')], [float('inf'), 1, 0, 2], [float('inf'), float('inf'), 2, 0]], [3, 2, 8, 10]) == 18\n    assert candidate(['A'], [[0]], [7]) == 7\n    assert candidate(['A', 'B'], [[0, float('inf')], [float('inf'), 0]], [20, 10]) == 20\n    assert candidate(['R', 'S'], [[0, 2], [2, 0]], [10, 15]) == 15", "entry_point": "minimum_light_spanning_tree", "extra_info": {"cover_story_words": ["mischievous fairies", "bioluminescent ocean"], "topics": ["Prim's Algorithm", "Math"], "cleaned_prompt": "Given a list of points (orbs), a corresponding matrix of connections representing the cost to connect each pair of points, and a list of light intensities of each orb, implement a function to return the maximum light intensity of the minimum spanning tree that connects all orbs using Prim's Algorithm.", "warnings": ["Solution failed correctness check.", "4, Incorrect Algorithm Description: The problem requirement is to find a spanning tree that minimizes the number of connections (i.e., uses the minimum spanning tree approach) while simultaneously maximizing the overall light intensity. However, Prim's algorithm as described in the problem statement and as it's typically used, focuses on minimizing the connection costs, not maximizing the attributes of the nodes (orbs in this case). The canonical solution provided applies Prim\u2019s algorithm prioritizing high light intensity directly which doesn't ensure a minimum spanning tree based on connection costs. There needs to be a balance or a method to account both connection costs and light intensities to satisfy both conditions, which this setup fails to address clearly."]}}
{"task_id": "hard/4", "prompt": "def optimal_path(visits, connections):\n    \"\"\"\n    In a city, there is a network of interconnected cyber cafes and libraries. Each node is either a library or a cyber cafe, represented as {'type': 'library', 'name': '...'} or {'type': 'cafe', 'name': '...'} respectively. A person plans to visit certain nodes but needs to do so in an optimal way.\n\n    The function `optimal_path` should determine the order of visits to minimize travel time, while ensuring that visits to cyber cafes and libraries are interleaved as closely as possible. The function should employ a technique resembling alpha-beta pruning to prioritize high-value paths.\n\n    Parameters:\n    - `visits`: a list of nodes the person plans to visit, each represented as {'type': 'library/cafe', 'name': '...'}. The person wants to visit all nodes at least once.\n    - `connections`: a dictionary where keys are node names and values are lists of tuples (connected_node_name, time_to_travel).\n\n    The function returns the order of nodes to be visited that minimizes total travel time with the interleaving condition.\n\n    Example usage:\n    visits = [{'type': 'library', 'name': 'Liberty'}, {'type': 'cafe', 'name': 'Coffee Corner'}]\n    connections = {\n        'Liberty': [('Coffee Corner', 10)],\n        'Coffee Corner': [('Liberty', 10)]\n    }\n    assert optimal_path(visits, connections) == ['Liberty', 'Coffee Corner'] with total time of 10 minutes.\n    \"\"\"\n", "canonical_solution": "    def optimal_path(visits, connections):\n        import heapq\n\n        def alternating_path(current_type):\n            opposite_type = 'cafe' if current_type == 'library' else 'library'\n            available_nodes = [name for node in visits if node['type'] == opposite_type]\n            if not available_nodes:\n                return [current_node['name']]\n\n            paths = []\n            for node in available_nodes:\n                for connected_node, travel_time in connections.get(current_node['name'], []):\n                    if connected_node in available_nodes:\n                        new_path = [current_node['name']] + alternating_path(visited + [(connected_node, travel_time)], travel_time + current_total_time)\n                        heapq.heappush(paths, (current_total_time + travel_time, new_path))\n            optimal_time, optimal_route = heapq.heappop(paths)\n            return optimal_route\n\n        start_type = visits[0]['type']\n        return alternating_path(start_type)\n", "test": "def check(candidate):\n    # Simple setup with one library and one cafe directly connected.\n    visits = [{'type': 'library', 'name': 'Liberty'}, {'type': 'cafe', 'name': 'Coffee Corner'}]\n    connections = {'Liberty': [('Coffee Corner', 10)], 'Coffee Corner': [('Liberty', 10)]}\n    assert candidate(visits, connections) == ['Liberty', 'Coffee Corner']\n\n    # More complex setup with multiple cafes and libraries\n    visits = [\n        {'type': 'library', 'name': 'Liberty'},\n        {'type': 'cafe', 'name': 'Coffee Corner'},\n        {'type': 'cafe', 'name': 'Java Joes'},\n        {'type': 'library', 'name': 'Book Bindings'}\n    ]\n    connections = {\n        'Liberty': [('Coffee Corner', 15), ('Book Bindings', 20)],\n        'Coffee Corner': [('Liberty', 15), ('Java Joes', 5), ('Book Bindings', 10)],\n        'Java Joes': [('Coffee Corner', 5)],\n        'Book Bindings': [('Liberty', 20), ('Coffee Corner', 10)]\n    }\n    assert candidate(visits, connections) in [['Liberty', 'Coffee Corner', 'Java Joes', 'Book Bindings'], ['Liberty', 'Book Bindings', 'Coffee Corner', 'Java Joes']]\n\n    candidate = optimal_path\n    check(candidate)\n", "entry_point": "optimal_path", "extra_info": {"cover_story_words": ["cyber cafe", "library"], "topics": ["Alpha-Beta Pruning", "Shortest Path"], "cleaned_prompt": "Write a function that calculates the optimal order to visit given nodes to minimize the travel time, ensuring that if one visit is a cyber cafe the next should be a library and vice versa when possible. You are given a list of nodes each represented with its type ('library' or 'cafe') and its name, and a dictionary of connections between these nodes with corresponding travel times.", "warnings": ["Only 2 test cases found. Minimum recommended is 5.", "Solution failed correctness check.", "4, Ambiguous Requirements: The problem prompt mentions that the nodes (visits to libraries and cafes) should be visited in an interleaved manner \"as closely as possible\" but does not define what should happen when there is an uneven number of each type or no direct path to continue the pattern. This can make implementing a solution that handles all corner cases correctly challenging, as the criteria for interleaving and fallback scenarios are not clearly defined.", "5, Potential Infinite Recursion: The provided 'canonical_solution' function has a recursive call within the 'alternating_path' function without a clear base case that prevents infinite recursion. There isn't a system to ensure that nodes are not revisited indefinitely, especially when there are circular paths between nodes or when a suitable interleaved path isn't available, leading potentially to a scenario where the function runs indefinitely.", "4, Logic Error in Canonical Solution: The canonical solution reflects an attempt to use a recursive function with heap operations for finding an optimal path, yet it has logic flaws where the 'visited' and 'current_total_time' parameters are referenced before being defined, and it fails to adequately manage state between recursive calls. This could lead to incorrect behavior or runtime errors when attempting to execute the function."]}}
{"task_id": "hard/3", "prompt": "def find_components(graph):\n    \"\"\"\n    In the ancient land of Graphonia, a mythical laboratory in the once-lost city of Nodar is intricately connected through a magical network of one-way transporters. Each room in the lab corresponds to a 'node', and each transporter corresponds to a 'directed edge' connecting a pair of rooms (nodes). The historical texts suggest that the transporters were enchanted to form mystical components where any room within a component can be reached from any other room within the same component.\n\n    Your quest is to uncover these mystical components using Kosaraju's Algorithm for strongly connected components. Given the layout of the lab as a directed graph represented by an adjacency list, where the keys are nodes and each value list contains the nodes that can be reached directly from the key node, you should return a list of components. Each component should be a list of nodes, sorted and then components should be sorted by their first element. \n\n    Note:\n    - Nodes are represented as positive integers.\n    - Resulting component lists should be sorted internally, and the list of components should be sorted by the smallest element in each component.\n    \"\"\",\n    ", "canonical_solution": "def find_components(graph):\n    def dfs(stack, node, visited, visit_order):\n        visited[node] = True\n        for neighbor in graph.get(node, []):\n            if not visited.get(neighbor, False):\n                dfs(stack, neighbor, visited, visit_order)\n        visit_order.append(node)\n\n    def reverse_graph(graph):\n        reversed_graph = {}\n        for src in graph:\n            for dest in graph[src]:\n                if dest not in reversed_graph:\n                    reversed_graph[dest] = []\n                reversed_graph[dest].append(src)\n        return reversed_graph\n\n    def fill(stack, node, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in reversed_g.get(node, []):\n            if not visited.get(neighbor, False):\n                fill(stack, neighbor, visited, component)\n\n    visited = {}\n    stack = []\n    for node in graph:\n        if not visited.get(node, False):\n            dfs(stack, node, visited, stack)\n\n    reversed_g = reverse_graph(graph)\n    visited = {}\n    components = []\n    while stack:\n        node = stack.pop()\n        if not visited.get(node, False):\n            component = []\n            fill(stack, node, visited, component)\n            components.append(sorted(component))\n    components.sort(key=lambda x: x[0])\n    return components", "test": "def check(candidate):\n    assert candidate({1: [2], 2: [3], 3: [1], 4: [5], 5: [], 6: [7], 7: [8], 8: [6]}) == [[1, 2, 3], [4], [5], [6, 7, 8]]\n    assert candidate({1: [2], 2: [3], 3: [1]}) == [[1, 2, 3]]\n    assert candidate({}) == []\n    assert candidate({1: [], 2: [], 3: []}) == [[1], [2], [3]]\n    assert candidate({1: [2], 2: [3], 3: [4], 4: [1], 5: [6], 6: [7], 7: [5], 8: [9], 9: [8], 10: [11], 11: [12], 12: [10]}) == [[1, 2, 3, 4], [5, 6, 7], [8, 9], [10, 11, 12]]", "entry_point": "find_components", "extra_info": {"cover_story_words": ["lost city", "enchanted lab"], "topics": ["Enumeration", "Kosaraju's Algorithm"], "cleaned_prompt": "def find_components(graph):\n    Return a list of strongly connected components of the directed graph using Kosaraju's Algorithm. Nodes are represented as integers. Components should be lists of nodes, sorted internally, and the list of components sorted by the smallest element in each component.", "warnings": ["Solution failed correctness check.", "4, Algorithm explanation: The problem assumes knowledge of Kosaraju's algorithm. However, it does not provide any explanation or reference for participants who might not be familiar with it. Since the algorithm is central to solving the problem, a brief explanation or external reference to study the algorithm could greatly aid understanding.", "5, Inefficiency in canonical solution logic: The use of a stack is repeated (`stack` variable is unnecessarily passed to the `fill` function, though it is not used in that function). This indicates possible inefficiencies or redundancies in how components are handled or in the overall design of the algorithm solution, which could be streamlined for better performance and clarity."]}}
{"task_id": "hard/1", "prompt": "def tree_music_sessions(paths, sessions):\n    \"\"\"\n    In a mythical forest, there is a wise old tree named Eldergrove. Eldergrove loves bonding with the forest's creatures through music. Around Eldergrove, there are various meeting spots connected by pathways in a somewhat cyclical pattern. Occasionally, Eldergrove conducts music sessions at these spots, and creatures from all around the forest attend. However, not all pathways are available all the time due to seasonal changes.\n\n    You are given a list of bidirectional paths connecting meeting spots, represented by tuples in the form `(start, end, available)`, where `start` and `end` are IDs of meeting spots and `available` is a boolean indicating if that path is usable. Additionally, you are provided with a list of music sessions denoted by tuples `(spot_id, require_availability)` where `spot_id` is the meeting spot ID, and `require_availability` is a list of other spots that must be accessible from `spot_id` for the session to proceed.\n\n    Implement a function that determines which music sessions can proceed. Use Tarjan's Algorithm to find strongly connected components to determine reachability of required spots, then use Floyd-Warshall to calculate the shortest path to ensure all required spots are accessible if the paths are available.\n\n    The function should return a list of boolean values corresponding to the input list of sessions, where `True` indicates the session can proceed and `False` otherwise.\n    \"\"\"\n", "canonical_solution": "def tree_music_sessions(paths, sessions):\n    from collections import defaultdict\n\n    def floyd_warshall(n, graph):\n        dist = [[float('inf')] * n for _ in range(n)]\n        for i in range(n):\n            dist[i][i] = 0\n        for u, v in graph.items():\n            for w in v:\n                dist[u][w] = 1\n\n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    if dist[i][j] > dist[i][k] + dist[k][j]:\n                        dist[i][j] = dist[i][k] + dist[k][j]\n\n        return dist\n\n    n = max(max(start, end) for start, end, _ in paths) + 1\n    graph = defaultdict(list)\n    for start, end, available in paths:\n        if available:\n            graph[start].append(end)\n            graph[end].append(start)\n\n    reachability = floyd_warshall(n, graph)\n\n    result = []\n    for spot_id, require_availability in sessions:\n        if all(reachability[spot_id][req] < float('inf') for req in require_availability):\n            result.append(True)\n        else:\n            result.append(False)\n\n    return result", "test": "def check(candidate):\n    assert candidate([(1, 2, True), (2, 3, True), (3, 4, True), (4, 1, True)], [(1, [2, 3])]) == [True]\n    assert candidate([(1, 2, True), (2, 3, True), (1, 3, False)], [(3, [1])]) == [False]\n    assert candidate([(1, 2, False), (2, 3, False), (3, 4, False), (4, 1, False)], [(1, [2, 3, 4])]) == [False]\n    assert candidate([(1, 2, True), (2, 3, True), (3, 1, True)], [(1, [])]) == [True]\n    assert candidate([(1, 2, True), (2, 3, False), (3, 4, True), (4, 2, True)], [(2, [3, 4])]) == [False]", "entry_point": "tree_music_sessions", "extra_info": {"cover_story_words": ["wise old tree", "music"], "topics": ["Tarjan's Algorithm", "Floyd-Warshall Algorithm"], "cleaned_prompt": "Implement a function that takes a list of bidirectional paths and a list of music sessions, and determines which music sessions can proceed. Paths are tuples (start, end, available) and sessions are tuples (spot_id, require_availability). Use Tarjan's Algorithm for finding connected components and then Floyd-Warshall for shortest path. Return a list of booleans indicating the viability of each session.", "warnings": ["Solution failed correctness check.", "5, Mismatched algorithms: The prompt suggests using Tarjan's Algorithm to find strongly connected components and Floyd-Warshall algorithm for shortest paths to assess the accessibility of the required spots. However, no implementation of Tarjan's Algorithm is present in the provided solution. Instead, it solely relies on Floyd-Warshall for reachability, which does not necessarily ensure strong connectivity or deal with directionality and unavailability issues appropriately for the described problem. This mismatch leads to potentially incorrect outputs or inefficiency."]}}
{"task_id": "hard/5", "prompt": "def enchanted_merge_sort(b_tree_values):\n    \"\"\"\n    An archaeological team has stumbled upon an enchanted laboratory containing numerous ancient artefacts labeled with values.\n    These values are arranged in an enchanted B-Tree. Your task as the team's head coder is to collect these values in a list and perform a classic merge sort on them.\n    The twist: the sorting should preserve a property where the sum of any two adjacent values in the sorted list should never be a power of two.\n\n    Given a B-Tree, return the values in a list sorted according to the rules above, or return False if no such arrangement can exist.\n\n    For example, if after getting values from the B-Tree, the sorted list could be [2, 3, 5, 10] or [10, 5, 3, 2], since neighboring sums [5, 8, 15] or [15, 8, 5] are not powers of two.\n    But [2, 3, 10, 5] would return False as 3 + 10 = 13, which is not a power of two, but 10 + 5 = 15, also not a power of two, fail to provide a valid arrangement for all.\n\n    Note: The B-tree retrieval is not the focus, assume helper functions are provided to retrieve values in sorted order.\n\n    Constraints:\n    - Values in the B-Tree will be unique positive integers.\n    \"\"\"\n", "canonical_solution": "    def is_power_of_two(x):\n        return (x & (x - 1)) == 0 and x > 0\n\n    def merge_sort(arr):\n        if len(arr) < 2:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\n    def check_adjacent_no_power_of_two(arr):\n        for i in range(len(arr) - 1):\n            if is_power_of_two(arr[i] + arr[i+1]):\n                return False\n        return True\n\n    sorted_vals = merge_sort(b_tree_values)\n    if check_adjacent_no_power_of_two(sorted_vals):\n        return sorted_vals\n    return False", "test": "def check(candidate):\n    assert candidate([2, 3, 5, 10]) in [[2, 3, 5, 10], [10, 5, 3, 2]]\n    assert candidate([5, 9, 16]) == False # 9 + 16 = 25, 5 + 16 = 21 - but no valid ordering exists\n    assert candidate([17, 14, 6, 23]) == False # no valid ordering\n    assert candidate([8, 2, 18, 32]) in [[2, 18, 8, 32], [32, 8, 18, 2]] # 20, 26, 40 are not powers of two\n    assert candidate([1, 31, 7]) in [[1, 7, 31], [31, 7, 1]] # 8 and 38 are not powers of two", "entry_point": "enchanted_merge_sort", "extra_info": {"cover_story_words": ["archaeological dig", "enchanted lab"], "topics": ["B-Tree", "Merge Sort"], "cleaned_prompt": "Given a B-Tree represented as a list of unique positive integers, return these values sorted according to a custom rule:\n    The sum of any two adjacent values in the sorted list should not be a power of two. Return the sorted list if such an arrangement is possible; otherwise, return False.", "warnings": ["Solution failed correctness check.", "5, Inconsistent Output: The problem definition and examples imply that there can be multiple correct answers (e.g., two valid sorted lists), but the canonical solution and tests sometimes expect a unique output (using 'in' for multiple options). This inconsistency could lead to ambiguous results and potential errors during evaluation.", "5, Invalid Algorithm Logic: The canonical solution attempts to sort the array first using a straightforward merge sort and then checks if any adjacent sum is a power of two. However, it doesn't attempt to reorder or find a valid permutation post sorting if the sorted list is not valid according to the given conditions, but immediately returns False. This is often not ideal, as there may exist valid configurations that are not explored by the algorithm.", "4, Unclear Constraints: The problem does not clearly specify the limits on the size of the B-tree or the range of integer values it might contain. Without this information, it's unclear how to effectively manage the performance of the solution, especially considering the complexity of checking every possible permutation in case the immediate sorted list is invalid.", "5, Test Cases Issue: The test cases provided do not cover scenarios where the list size is less than two, edge cases at the minimum and maximum integer values, or lists where there might be valid multiple configurations. These tests are crucial to ensure that the solution is robust and performs correctly across all potential inputs."]}}
