{"reason": "Solution failed correctness check.", "problem": {"task_id": "hard/1", "prompt": "def survival_grundy(n, k, moves):\n    \"\"\"\n    In a post-apocalyptic cyberpunk world, cities are represented as nodes in a graph (with n nodes). Two players are engaged in a survival game where they can choose a city to perform critical operations to ensure survival. Each player alternates turns, and on their turn, they can select up to k ruins (where k is a specific number of nodes they can operate at once).\n\n    The operation initiative is assigned a Grundy number using the Sprague-Grundy theorem which helps in determining which player has a winning strategy given the current state of the game.\n\n    Given the number of cities (n), the maximum number of operations one can perform in a turn (k), and an array moves that specify the permissible number of cities a player can operate on in their turn (up to k), you need to return the Grundy number for the game state starting with all n cities operational.\n\n    Note:\n    - moves array contains at least one element.\n    - All elements in moves are distinct and between 1 and k inclusive.\n    - The Grundy number for a game state where no operations can be performed (no available moves) is 0.\n    \"\"\"", "canonical_solution": "def mex(s):\n        m = 0\n        while m in s:\n            m += 1\n        return m\n\n    def grundy(n, k, moves):\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            reachable_grundies = set()\n            for move in moves:\n                if i >= move:\n                    reachable_grundies.add(dp[i - move])\n            dp[i] = mex(reachable_grundies)\n        return dp[n]\n\n    return grundy(n, k, moves)", "entry_point": "survival_grundy", "test": "def check(candidate):\n    assert candidate(10, 3, [1, 3]) == 2\n    assert candidate(5, 5, [1, 2, 3, 4, 5]) == 0\n    assert candidate(7, 2, [1, 2]) == 2\n    assert candidate(12, 4, [1, 4]) == 4\n    assert candidate(75, 5, [1, 2, 3, 4, 5]) == 1", "extra_info": {"cover_story_words": ["post-apocalyptic world", "cyberpunk"], "topics": ["Enumeration", "Sprague-Grundy Theorem"], "cleaned_prompt": "def survival_grundy(n, k, moves):\n    \"\"\"\n    Given a number of cities (n), a maximum number of operations in a turn (k), and permissible moves in a turn, return the Grundy number for a game state starting with all cities operational using the Sprague-Grundy theorem.\n    \"\"\""}}}
{"reason": "Fewer than 5 test cases.", "problem": {"task_id": "hard/1", "prompt": "def count_magic_fruits(forest_map, queries):\n    \"\"\"\n    Once upon a time in an enchanted forest, there existed a wise old tree at the center. This tree was capable of producing different types of magical fruits each characterized by unique positive integer IDs. However, the tree only gifted those fruits under certain conditions based on the forest structure.\n\n    The forest's structure is represented as an undirected tree where each node is a tree/ledge and edges represent paths. For each type of fruit, there is a special characteristic - the 'magic strength', and each node has a list of fruit types it has. The forest map is thus depicted as a list where each index represents a node, and each node contains sublists of the fruits it can have.\n\n    The problem is to answer a series of queries where each query consists of a path from node A to node B in the tree structure, calculating the count of unique fruit types whose total appearance is greater than a given threshold K along the node path inclusive of A and B.\n\n    You must use Heavy-Light Decomposition to preprocess the tree for efficient path queries, and for sampling fruit presence efficiently, you should implement a Rejection Sampling approach.\n\n    Parameters:\n        forest_map (List[List[int]]): This is a list of lists, where each sublist at index i represents the fruits present at node i.\n        queries (List[Tuple[int, int, int]]): Each query is a tuple (A, B, K) where A and B represent the nodes between which the fruits are queried, and K is the appearance threshold.\n\n    Return:\n        List[int]: A list containing the count of fruit types for each query which satisfies the condition based on the mentioned path and threshold.\n    \"\"\"\n", "canonical_solution": "    class HLDecomposition:\n        def __init__(self, tree_structure, node_fruits):\n            self.tree = tree_structure\n            self.node_fruits = node_fruits\n            self.decompose()\n\n        def decompose(self):\n            # Heavy light decomposition logic here\n            pass\n\n    def count_magic_fruits(forest_map, queries):\n        def build_tree_from_map(forest_map):\n            tree_structure = {} # logic to build tree\n            return tree_structure\n\n        tree = build_tree_from_map(forest_map)\n        hld = HLDecomposition(tree, forest_map)\n        results = []\n        for A, B, K in queries:\n            fruits_count = hld.query_path(A, B, K)\n            results.append(fruits_count)\n        return results", "test": "def check(candidate):\n    map_input = [[1, 2], [2, 3], [3], [1, 4], []]\n    queries_input = [(0, 2, 1), (1, 3, 2), (0, 4, 0)]\n    assert candidate(map_input, queries_input) == [1, 0, 2]\n    map_input = [[7, 7, 8], [9], [], [8, 7], [9]]\n    queries_input = [(0, 3, 2), (0, 4, 1), (1, 3, 0)]\n    assert candidate(map_input, queries_input) == [1, 2, 1]\n    map_input = [[], [], [], [], []]\n    queries_input = [(0, 1, 0), (2, 3, 1), (0, 4, 0)]\n    assert candidate(map_input, queries_input) == [0, 0, 0]", "entry_point": "count_magic_fruits", "extra_info": {"cover_story_words": ["enchanted forest", "wise old tree"], "topics": ["Rejection Sampling", "Heavy-Light Decomposition"], "cleaned_prompt": ""}}}
{"reason": "Fewer than 5 test cases.", "problem": {"task_id": "hard/1", "prompt": "def wise_tree_crystal_ball(people, preferences, relationships):\n    \"\"\"\n    In a mystical forest, there's a wise old tree that has seen the ages pass. Near its roots, there is a magical crystal ball that can answer any question about relationships.\n\n    The forest is inhabited by 'n' people. Each person has a list of all other people ranked by their preference for marriage. Likewise, each person is listed in various other people's preferences. The wise old tree uses these preferences to help these people find a stable marriage setup.\n\n    A marriage is considered 'stable' if there are no two people who prefer each other over their current partners.\n\n    Every person wants to know their optimal match according to the 'Stable Marriage Problem'. You need to return a dictionary where keys are people's names and values are the names of their partners.\n\n    However, there's a complication. The crystal ball shows the max-flow of possible engagements ('relationships') between any two individuals using the Edmonds-Karp algorithm to guarantee stability constraints.\n\n    Your task:\n    - Use the list of 'people', their 'preferences', and the 'relationships' matrix to determine the most stable marriage setup.\n\n    Constraints:\n    - Number of people 'n' is guaranteed to be even and within 2 to 40.\n    - 'preferences' is a dictionary where each key is a person's name and value is a list of all people sorted by preference.\n    - 'relationships' is a 2-dimensional array representing the max-flow capacities of engagements between individuals.\n\n    Note that the solution must account for optimal max flow in the relationship matrix when considering possible marriages.\n    \"\"\"\n", "canonical_solution": "from collections import deque\n\ndef wise_tree_crystal_ball(people, preferences, relationships):\n    def bfs(source, sink, parent):\n        visited = [False] * len(people)\n        queue = deque([source])\n        visited[source] = True\n\n        while queue:\n            u = queue.popleft()\n\n            for ind, val in enumerate(capacity[u]):\n                if not visited[ind] and val > 0: # If not yet visited and there's available capacity\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n                    if ind == sink:\n                        return True\n\n        return False\n\n    def edmonds_karp(source, sink):\n        parent = [-1] * len(people) # Array to store the path\n        max_flow = 0\n\n        while bfs(source, sink, parent):\n            path_flow = float('Inf')\n            s = sink\n\n            while s != source:\n                path_flow = min(path_flow, capacity[parent[s]][s])\n                s = parent[s]\n\n            max_flow += path_flow\n\n            v = sink\n            while v != source:\n                u = parent[v]\n                capacity[u][v] -= path_flow\n                capacity[v][u] += path_flow\n                v = parent[v]\n\n        return max_flow\n\n    # Initialize capacity matrix for Edmonds-Karp\n    n = len(people)\n    capacity = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            capacity[i][j] = relationships[i][j]\n\n    # Applying Edmonds-Karp to find the maximum engagement flow\n    source = 0 # Assuming source is the first person\n    sink = n - 1 # Assuming sink is the last person\n    max_engagement_flow = edmonds_karp(source, sink)\n\n    # Deriving marriages from the maximum flow\n    # (Placeholder for stable marriage setup calculation, using actual preferences and resulting flows)\n\n    return {'solution': 'pending'} # This should be replaced by actual stable pairing logic\n", "test": "def check(candidate):\n    people = ['Alice', 'Bob', 'Cara', 'Dan']\n    preferences = {'Alice': ['Bob', 'Dan', 'Cara'], 'Bob': ['Cara', 'Alice', 'Dan'], 'Cara': ['Bob', 'Dan', 'Alice'], 'Dan': ['Alice', 'Cara', 'Bob']}\n    relationships = [[0, 3, 1, 2], [3, 0, 2, 1], [1, 2, 0, 3], [2, 1, 3, 0]]\n\n    candidate_result = candidate(people, preferences, relationships)\n\n    # This is just a dummy check as the actual implementation of matching has been omitted in the canonical solution,\n    # the implementation should correctly calculate stable marriages according to both preferences and relationships.\n    assert isinstance(candidate_result, dict), 'Result must be a dictionary.'\n\n", "entry_point": "wise_tree_crystal_ball", "extra_info": {"cover_story_words": ["wise old tree", "crystal ball"], "topics": ["Stable Marriage Problem", "Edmonds-Karp Algorithm"], "cleaned_prompt": "Write a function that determines the most stable marriage setup by utilizing given preferences and max-flow engagement capacities between individuals."}}}
{"reason": "Solution failed correctness check.", "problem": {"task_id": "hard/1", "prompt": "def dragon_shopping_encryption(events, queries):\n    \"\"\"\n    At the Magical Mall, dragons use a special method to encrypt their shopping events using a shell algorithm. An event can combine a series of words to form a long string. The query system at the mall uses a modified Z-algorithm to help the dragons find out how many times a pattern appears in the event string exactly.\n\n    The function receives two parameters:\n    - events: a list of tuples, where each tuple contains a string (shop activity description) and an integer (how many times the description should repeat as a shell).\n    - queries: a list of strings, where each string is a pattern for which the dragon wants to find exact matches in the built event string.\n\n    It should return a list of integers, where each integer corresponds to the respective query and represents the number of exact matches found in the completed event string.\n\n    Example:\n    events = [('fire', 2), ('ice', 1)]   # This would form the string 'firefireice'\n    queries = ['fire', 'ice', 'icefire']\n\n    The function should return [2, 1, 0] because:\n    - 'fire' appears exactly 2 times\n    - 'ice' appears exactly 1 time\n    - 'icefire' does not appear\n\n    Note:\n    - The events are repeated to form the event string using each tuple's integer as the repetition count.\n    - The queries should match exactly and should not overlap.\n    \"\"\"", "entry_point": "dragon_shopping_encryption", "canonical_solution": "def dragon_shopping_encryption(events, queries):\n    def generate_event_string(events):\n        return ''.join([desc * mult for desc, mult in events])\n\n    def z_algorithm(s, pattern):\n        combined = pattern + '$' + s\n        Z = [0] * len(combined)\n        l, r, K = 0, 0, 0\n        for i in range(1, len(combined)):\n            if i > r:\n                l, r = i, i\n                while r < len(combined) and combined[r] == combined[r - l]:\n                    r += 1\n                Z[i] = r - l\n                r -= 1\n            else:\n                K = i - l\n                if Z[K] < r - i + 1:\n                    Z[i] = Z[K]\n                else:\n                    l = i\n                    while r < len(combined) and combined[r] == combined[r - l]:\n                        r += 1\n                    Z[i] = r - l\n                    r -= 1\n        return [Z[i] for i in range(len(pattern) + 1, len(combined)) if Z[i] == len(pattern)]\n\n    result = []\n    event_string = generate_event_string(events)\n    for query in queries:\n        matches = z_algorithm(event_string, query)\n        result.append(len(matches))\n    return result", "test": "def check(candidate):\n    assert candidate([('fire', 2), ('ice', 1)], ['fire', 'ice', 'icefire']) == [2, 1, 0]\n    assert candidate([('flight', 3), ('fight', 2)], ['flight', 'fight']) == [3, 2]\n    assert candidate([('dragon', 1), ('magic', 4)], ['gonma', 'magic']) == [0, 4]\n    assert candidate([], ['anything']) == [0]\n    assert candidate([('imagination', 1)], ['magi', 'nation', 'imagination']) == [1, 1, 1]\n    assert candidate([('aa', 2)], ['aaa', 'a']) == [0, 4]\n    assert candidate([('xy', 5), ('zxy', 4)], ['xy', 'zxy']) == [5, 4]", "extra_info": {"cover_story_words": ["dragons", "shopping mall"], "topics": ["Shell", "Z-Algorithm"], "cleaned_prompt": "Write a function 'dragon_shopping_encryption' that takes a list of tuples representing event descriptions and their repetition counts, and a list of strings representing queries. The function should return how many times each query string exactly appears in the event description after building it from the repetitions."}}}
{"reason": "Solution failed correctness check.", "problem": {"task_id": "hard/1", "prompt": "def reconstruct_forest(stolen_segments, operations):\n    \"\"\"\n    In the enchanted forest, fairies have a mischievous behavior of cloning trees using their magical device. Each tree is represented by a collection of vertical segments (ropes) in a 2D plane.\n\n    Unfortunately, a group of fairies stole some segments and went away to clone them. The forest manager needs help to reconstruct a possible configuration of the forest by connecting these ropes using the minimum number of operations.\n\n    The 'stolen_segments' are a list of tuples where each tuple (x, y1, y2) represents a vertical segment starting at y1 and ending at y2 at x coordinate. 'operations' represent potential connections between the end of one segment and the start of another, modeled as a list of tuples (cost, (segment1, segment2)). The cost represents the energy required to connect the two segments end-to-start.\n\n    Your task is to help the manager reconnect these pieces in a way that minimizes the total energy using a modified Boruvka's Algorithm to create a minimum spanning tree.\n\n    Constraints:\n    - Segments will always have distinct x coordinates and will not overlap vertically.\n    - Each element in operations will have a unique cost.\n\n    Output should be the minimum total energy used.\n    \"\"\"\n", "canonical_solution": "    def find(parent, i):\n        if parent[i] == i:\n            return i\n        else:\n            return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else :\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    n = len(stolen_segments)\n    parent = list(range(n))\n    rank = [0] * n\n\n    operations.sort()\n    result = 0\n    e = 0\n    while e < n-1:\n        cost, (segment1, segment2) = operations.pop(0)\n        x = find(parent, segment1)\n        y = find(parent, segment2)\n\n        if x != y:\n            result += cost\n            e += 1\n            union(parent, rank, x, y)\n\n    return result", "test": "def check(candidate):\n    assert candidate([(1, 0, 5), (2, 6, 10), (3, 11, 15)], [(1, (0, 1)), (2, (1, 2))]) == 3\n    assert candidate([(1, 0, 2), (2, 3, 5), (3, 6, 8)], [(1, (0, 1)), (10, (1, 2)), (5, (0, 2))]) == 6\n    assert candidate([(1, 0, 1), (2, 2, 3)], [(3, (0, 1))]) == 3\n    assert candidate([(1, 0, 1), (2, 3, 4), (3, 5, 6), (4, 7, 8)], [(2, (0, 1)), (2, (2, 3)), (5, (1, 2))]) == 4\n    assert candidate([(1, 0, 4), (2, 5, 9), (3, 10, 14), (4, 15, 19)], [(3, (0, 1)), (2, (1, 2)), (1, (2, 3))]) == 6\n    assert candidate([(1, 0, 3), (2, 4, 7)], [(5, (0, 1))]) == 5", "entry_point": "reconstruct_forest", "extra_info": {"cover_story_words": ["mischievous fairies", "cloning device"], "topics": ["Rope Data Structure", "Boruvka's Algorithm"], "cleaned_prompt": "Define a function that takes a list of vertical segments and a list of connection operations. Each operation connects two segments with an associated cost. Use Boruvka's Algorithm to compute the minimal cost to connect all segments into a single structure. Segments are represented as tuples (x, y1, y2) and do not overlap vertically or share x coordinates. Operations are represented as tuples of cost and segment pair indices."}}}
