{"task_id": "hard/5", "prompt": "def sneaky_shadows(cars, shadows):\n    \"\"\"\n    In a sophisticated surveillance system, we need to track cars moving through an area that sometimes gets covered in shadows, making parts of the cars invisible to cameras.\n\n    Each car is represented as a convex polygon (in the form of a list of 2D points defining the polygon vertices). Shadows are also represented as convex polygons.\n\n    Your task is to implement a function that calculates the visible area of each car after accounting for all the shadows. Compute intersections between cars and shadows using an appropriate polygon intersection algorithm and ensure the result is a convex polygon if applicable.\n\n    For each car, output the final visible area after all shadows are taken into account while handling polygon intersections and areas accurately.\n\n    Example:\n    If a car is represented as [(1,1), (1,3), (3,3), (3,1)] and there is a shadow [(2,2), (2,4), (4,4), (4,2)], the function should calculate the new visible area of the car considering the overlap.\n\n    Note:\n    - When providing polygon vertices, ensure they are provided in order and all polygons are convex.\n    - The coordinates for cars and shadows are given as tuples of integers.\n    \"\"\"\n", "canonical_solution": "def sneaky_shadows(cars, shadows):\n    def visible_area(car, shadows):\n        # Intersection of polygons to compute reduced visible areas\n        pass\n\n    return [visible_area(car, shadows) for car in cars]", "test": "def check(candidate):\n    # Assume area function and intersection functions already given in hidden setup\n    assert candidate([[(1,1), (1,3), (3,3), (3,1)]], [[(2,2), (2,4), (4,4), (4,2)]]) == [4]\n    assert candidate([[(0,0), (0,5), (5,5), (5,0)]], [[(1,1), (1,2), (2,2), (2,1)]]) == [24]\n    assert candidate([[(1,1), (1,4), (4,4), (4,1)]], [[(2,2), (2,3), (3,3), (3,2)], [(1,1), (1,2), (2,2), (2,1)]]) == [12]\n    assert candidate([[(1,1), (1,3), (3,3), (3,1)]], []) == [8]\n    assert candidate([], [[(1,1), (1,3), (3,3), (3,1)]]) == []", "entry_point": "sneaky_shadows", "extra_info": {"cover_story_words": ["sneaky shadows", "car"], "topics": ["Polygon Intersection", "Geometric Calculations"], "cleaned_prompt": "Define a function 'sneaky_shadows(cars, shadows)' calculating the visible area of each car after considering the overlapping areas from shadows. Use appropriate algorithms for polygon intersections to compute the visible and obscured areas. Cars and shadows are represented as lists of tuples representing convex polygon vertices.", "warnings": ["Solution failed correctness check.", "5, Incomplete Solution Logic: The problem statement provides an incomplete implementation in the \"canonical_solution\" section. The function 'visible_area' is defined but not implemented. This makes it impossible to use this as a reference solution for judging correctness of submissions.", "4, Ambiguity in Polygon Intersections: The problem statement requires computing intersections and resulting areas of convex polygons but does not specify the algorithm or provide an implementation. There are multiple methods for polygon intersection, and leaving this open can lead to variations in the submissions that might or might not align with the expected outcomes defined in the tests."]}}
{"task_id": "hard/3", "prompt": "def assign_animals_to_monks(animals, monks):\n    \"\"\"\n    In a mystical monastery closely attached to nature, monks take care of special animals that live in their adjoining sacred zoo. Each animal or monk is represented as an image in the format of a list of lists of integers, where each inner list represents a row of pixels. Monks and animals can only communicate well if their images are highly correlated.\n\n    We are given two lists: 'animals' and 'monks', each containing images of animals and monks respectively. An image correlation function 'image_correlation()' is already predefined, and it returns a score on how much two images are correlated.\n\n    Your task is to assign each animal to a monk such that the sum of image correlations for all pairs is maximized. Note that each monk can only take care of one animal, and the number of available monks and animals can be different.\n\n    Use the concept of a Binary Indexed Tree (BIT) to keep track of dynamic choices and efficiently update the best available monk's correlation score for each animal. This involves using the BIT to manage mapping scores and underlying data during monk-animal assignment calculation.\n\n    Implement the stable matching between animals and monks based on the highest correlation ensuring efficient updates and searches.\n\n    Constraints:\n    - The images are N x M where N could vary between 28 and 256, and M could vary between 28 and 256.\n    - Animals and monk lists could have different lengths (but each will have at least one element).\n\n    Example:\n    Assume image_correlation returns 100 when two images are the same and 0 otherwise.\n    If 'animals' and 'monks' both have just one element, and both images are the same, the output should be [0], since the only monk (index 0) should take care of the only animal (index 0).\n    \"\"\"", "canonical_solution": "    def image_correlation(img1, img2):\n        # Assume this function is already defined\n        pass\n\n    def assign_animals_to_monks(animals, monks):\n        from sortedcontainers import SortedList\n        from bisect import bisect_left\n\n        # BIT or an equivalent data structure like SortedList from the sortedcontainers could be utilized here\n        scores = SortedList()\n        assignments = [-1] * len(animals)\n        for ai, animal in enumerate(animals):\n            monk_scores = [(image_correlation(animal, monk), mi) for mi, monk in enumerate(monks)]\n            monk_scores.sort(reverse=True)\n            for score, mi in monk_scores:\n                if mi not already assigned and binary search logic to decide the insertion point in BIT:\n                    assignments[ai] = mi\n                    # update BIT logic here\n                    break\n\n        return assignments", "test": "def check(candidate):\n    assert candidate([[255]], [[255]]) == [0]\n    assert candidate([[0]], [[255]]) == [-1]\n    monks = [[1,1,1],[1,1,1],[1,1,1]]\n    animals = [[1,1,1],[1,0,1],[1,1,1]]\n    assert set(candidate(animals, monks)) == {0, 2, -1}\n    assert candidate([[0, 0, 0]], [[0, 0, 0], [1, 1, 1]]) == [0]\n    # Additional case for increased coverage\n    large_monk = [[x%256 for x in range(300)] for _ in range(300)]\n    large_animal = [[x%256 for x in range(300)] for _ in range(4)]\n    assert candidate(large_animal, [large_monk]) == [0, -1, -1, -1]", "entry_point": "assign_animals_to_monks", "extra_info": {"cover_story_words": ["mystic monastery", "zoo"], "topics": ["Binary Indexed Tree", "Stable Matching Problem"], "cleaned_prompt": "Given two lists of images 'animals' and 'monks', create a function that assigns each animal to a monk such that the sum of the image correlations is maximized using a Binary Indexed Tree to manage dynamic allocations efficiently. Ensure each assignment is stable based on the highest correlation. Consider different sizes of images and list lengths.", "warnings": ["Solution failed correctness check.", "5, Clarity on Matrix Size Limitation: The provided constraints mention typical sizes for the images, but do not define a clear maximum for either the number of images (for both animals and monks) or their dimension sizes. This oversight could lead to inefficient algorithm design or inadequate testing, impacting both performance and functionality in unpredicted cases.", "4, BIT Utilization Explanation: The task description mentions utilizing a Binary Indexed Tree (BIT) for managing mapping scores and dynamic data updates, but lacks a detailed explanation or an appropriate example of how BIT should be effectively implemented in this specific context. This lack of clarity might lead to confusion about the requirements and usage of BITs in the solution.", "4, Missing or Undefined Function: The function `image_correlation`, vital for computing correlations and thereby critical for the core logic of the task, is described as predefined but is not actually provided or further detailed. This omission can lead to discrepancies in implementation, as participants must assume its behavior which could vary significantly."]}}
{"task_id": "hard/1", "prompt": "def detect_patient_health_status(reports, vocabulary):\n    \"\"\"\n    Imagine a hospital facing odd technical glitches where some of the patient health reports are getting mixed up with sneaky, irrelevant shadows, i.e., characters or substrings not relevant to their health condition. The hospital's system needs to parse these reports to extract meaningful health status descriptions using a known vocabulary of medical terms.\n\n    Your task is to design a function using advanced data structures (like Splay Trees for efficient searches and modifications) and algorithms to process these corrupted health reports and determine if these reports can be broken down entirely using the medical vocabulary provided.\n\n    Specifically, the function should:\n        - Use a Splay Tree to dynamically handle insertions and updates of words in the vocabulary.\n        - Utilize the Word Break Problem technique to decide if the report can be segmented completely into words from the vocabulary.\n        - If a report can be segmented into valid words, return True. Otherwise, return False.\n\n    Example:\n    if vocabulary contains ['diabetes', 'high', 'blood', 'pressure', 'patient'] and\n    the report is 'highdiabetespatient', the function should return True because the report can be broken down into 'high', 'diabetes', 'patient'.\n\n    Another example, for 'hyperpatientactivity' with the same vocabulary should return False since 'hyper' and 'activity' are not in the vocabulary.\n    \"\"\"\n", "canonical_solution": "class SplayTree:\n    class Node:\n        def __init__(self, value):\n            self.value = value\n            self.left = None\n            self.right = None\n\n    def __init__(self):\n        self.root = None\n\n    def splay(self, value):\n        # Splaying logic to balance the tree around the value\n        if not self.root:\n            return None\n        # Placeholder for splay logic\n        return None\n\n    def insert(self, value):\n        # Insert logic which after insertion splays the tree\n        if not self.root:\n            self.root = SplayTree.Node(value)\n        else:\n            # Placeholder for insertion logic with splay\n            pass\n\n    def search(self, value):\n        # Search logic that should splay the node with value to root\n        return False  # Placeholder for actual search implementation\n\ndef can_segment_string(s, words):\n    t = SplayTree()\n    for word in words:\n        t.insert(word)\n\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(max(0, i-len(max(words, key=len))), i):\n            if dp[j] and t.search(s[j:i]):\n                dp[i] = True\n                break\n    return dp[-1]\n\ndef detect_patient_health_status(reports, vocabulary):\n    return can_segment_string(reports, vocabulary)\n", "test": "def check(candidate):\n    assert candidate('highdiabetespatient', ['diabetes', 'high', 'blood', 'pressure', 'patient']) == True\n    assert candidate('hyperpatientactivity', ['diabetes', 'high', 'blood', 'pressure', 'patient']) == False\n    assert candidate('', ['any']) == True\n    assert candidate('persistentcough', ['persistent', 'cough']) == True\n    assert candidate('unexpectedfailure', ['unexpected', 'fail']) == False\n    assert candidate('heartattack', ['heart', 'attack']) == True\n    assert candidate('coronavirus', ['corona', 'virus', 'coronavirus']) == True", "entry_point": "detect_patient_health_status", "extra_info": {"cover_story_words": ["hospital", "sneaky shadows"], "topics": ["Splay Tree", "Word Break"], "cleaned_prompt": "Design a function that determines if a given health report can be entirely segmented using a given medical vocabulary. Use a Splay Tree for dynamic operations on the vocabulary, and apply the Word Break Problem technique to assess report segmentability.\n\nExamples:\n- Given vocabulary: ['diabetes', 'high', 'blood', 'pressure', 'patient'], and report: 'highdiabetespatient', return True.\n- Given the same vocabulary and report: 'hyperpatientactivity', return False.", "warnings": ["Solution failed correctness check.", "5, Missing Implementations: The task requires the implementation of a Splay Tree including insertion, search, and splaying functionalities. However, these are either mentioned with placeholders or insufficiently described to fulfill the requirements of dynamically handling insertions, updates, and efficient searching needed for solving the Word Break Problem. This lack of implementation makes the problem statement unsolvable as described.", "4, Inefficiency in Problem Constraints: The requirement to use a Splay Tree does not inherently align with the needs of the Word Break Problem, which primarily concerns string segmentation and dynamic programming. The problem does not justify why a Splay Tree is necessary or advantageous for this task, potentially leading to unnecessary complexity without clear benefits."]}}
{"task_id": "hard/2", "prompt": "def max_profit(photos, prices, attention_span):\n    \"\"\"\n    As a photography enthusiast visiting a unique exhibition featuring picturesque hot air balloons from around the globe, your goal is to maximize profit by buying and selling photo prints. Each photo has a designated time window during which it can be bought at a fluctuating price, influenced by demand. You need to optimize buy and sell periods according to the changing focus span of your collector friend.\n\n    Parameters:\n    photos: List of tuples depicting (start_time, end_time) for each photo display period.\n    prices: List of lists containing the price history of each photo from its start to end time, updated per minute.\n    attention_span: List of tuples representing each shift in focus (start_time, duration) when your friend commits to a new photo.\n\n    Return:\n    The maximum profit achievable during the visit, managing purchases and sales under the constraints of attention span switching and photo availability.\n\n    Constraints:\n    - The attention spans are non-overlapping segments, each within the timeline of relevant photo displays.\n    - Price history matches the exact timespan of each photo, i.e., each sublist in prices corresponds directly to the minutes a photo is displayed.\n    - For profit calculations, one must only consider buy and sell actions within each attention span on photos that are viewable in their entirety during that span.\n\n    Example:\n    photos = [(1, 5), (4, 8)]\n    prices = [[10, 12, 11, 14, 15], [15, 18, 20, 17, 18]]\n    attention_span = [(2, 1), (4, 4)]\n    The output should be 3, as your friend could buy the second photo at minute 4 for 15 and sell at minute 8 for 18 (profit 3).\n    Note: Only actions fully occurring within given attention spans should be considered for profit calculation.\n    \"\"\"\n", "canonical_solution": "def max_profit(photos, prices, attention_span):\n    def can_view_photo(photo, period):\n        photo_start, photo_end = photo\n        period_start, period_duration = period\n        period_end = period_start + period_duration\n        return photo_start <= period_start and photo_end >= period_end\n\n    total_profit = 0\n    for focus_period in attention_span:\n        period_start, period_duration = focus_period\n        period_end = period_start + period_duration\n        for index, photo in enumerate(photos):\n            if can_view_photo(photo, focus_period):\n                start_index = max(0, period_start - photo[0])\n                end_index = min(photo[1] - photo[0], period_end - photo[0])\n                photo_prices = prices[index][start_index : end_index + 1]\n                if photo_prices:\n                    min_price = min(photo_prices)\n                    max_price = max(photo_prices)\n                    total_profit += max_price - min_price\n    return total_profit", "test": "def check(candidate):\n    assert candidate([(1, 5), (4, 8)], [[10, 12, 11, 14, 15], [15, 18, 20, 17, 18]], [(2, 1), (4, 4)]) == 3\n    assert candidate([(0, 6)], [[3, 3, 5, 0, 5, 5, 3]], [(1, 5)]) == 5\n    assert candidate([(3, 7), (2, 4), (6, 10)], [[4, 10, 8, 6, 10], [2, 2, 4, 6], [1, 0, 0, 0, 4]], [(3, 2), (7, 3)]) == 12\n    assert candidate([(0, 10)], [[1, 3, 3, 7, 2, 2, 9, 11, 6, 5, 9]], [(2, 6)]) == 9\n    assert candidate([(2, 5), (3, 8)], [[6, 5, 7, 8], [4, 2, 3, 5, 6, 8]], [(4, 1), (3, 4)]) == 6", "entry_point": "max_profit", "extra_info": {"cover_story_words": ["hot air balloon", "shopping mall", "photo exhibit"], "topics": ["Best Time to Buy and Sell Stock", "Meeting Rooms", "Simulation", "Optimization"], "cleaned_prompt": "Develop a function to calculate optimal profits from buying and selling photographs based on varying attention spans. The function receives periods indicating when photos can be focused on and their corresponding price changes over time. An attention span dictates when a different photo can be focused on. Compute the profit for each attention span by making the best buying and selling decisions, considering the exact minutes each photo can be viewed and bought during those attention periods. The solution should account for overlaps and calculate profit using the prices available during the attention spans.", "warnings": ["Solution failed correctness check.", "5, Incomplete Function Implementation: The example in the prompt suggests that the function calculates the profit by considering only the photos that can be viewed in their entirety during each attention span. However, the description of the canonical implementation, which slices the price array based on the overlap between the photo availability period and the attention span, does not ensure that a photo can be entirely viewed within the attention span. This discrepancy can lead to incorrect profit calculations if the photo cannot be completely viewed within the span.", "4, Incorrect Index Calculation: In the canonical solution, the end index for slicing the price list may incorrectly exclude the last price in some scenarios due to the calculation `min(photo[1] - photo[0], period_end - photo[0])`. This should correctly be `min(photo[1] - photo[0], period_end - photo[0] + 1)` to ensure the slicing includes the price at the `period_end` when it exactly aligns with the photo's end time."]}}
