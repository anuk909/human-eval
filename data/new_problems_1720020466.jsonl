{"task_id": "hard/2", "prompt": "def arrange_trip_schedule(courses, prerequisites, museums, k):\n    \"\"\"\n    You are planning a trip that includes both beach seminars and museum visits. You have a list of courses (seminars) you want to attend at the beach, but they have prerequisites that must be completed in a specific order before attending them. Similarly, there are museums you would like to visit. For an optimal experience, you must visit the k-th most popular museum based on visitor reviews (popularity rankings).\n\n    The 'courses' list represents seminars where each seminar is identified by a unique integer. The courses have prerequisites given in 'prerequisites' list, where each element is a pair [a, b] meaning to attend course a, you must first complete course b.\n\n    The 'museums' list contains integers representing the popularity of each museum. The task is to determine if it is possible to finish all the seminars based on the given prerequisites, and to identify the k-th most popular museum to plan your visit.\n\n    Assumptions:\n    - All courses and prerequisites are represented with unique positive integers.\n    - You need to return a tuple: (canFinishAllCourses: bool, kthMuseum: int).\n    - If k is out of bounds for the list, return -1 for kthMuseum.\n\n    This problem is a combination of Course Schedule (from graph theory) and finding the k-th largest element in an array.\n\n    Examples:\n    arrange_trip_schedule([1, 2, 3], [[1, 2], [2, 3]], [5, 3, 9, 2], 2) should return (True, 5) because you can finish all the courses and the second most popular museum is with popularity 5.\n    \"\"\"\n", "canonical_solution": "    def can_finish(num_courses, prerequisites):\n        from collections import defaultdict, deque\n        indegree = [0] * num_courses\n        adj_list = defaultdict(list)\n        for dest, src in prerequisites:\n            adj_list[src].append(dest)\n            indegree[dest] += 1\n        queue = deque([i for i in range(num_courses) if indegree[i] == 0])\n        while queue:\n            vertex = queue.popleft()\n            for neighbor in adj_list[vertex]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        return all(x == 0 for x in indegree)\n\n    def kth_largest(numbers, k):\n        import heapq\n        return heapq.nlargest(k, numbers)[-1] if k <= len(numbers) else -1\n\n    course_count = len(courses)\n    can_finish_courses = can_finish(course_count, prerequisites)\n    kth_popular_museum = kth_largest(museums, k)\n    return (can_finish_courses, kth_popular_museum)", "test": "def check(candidate):\n    assert candidate([1, 2, 3], [[1, 2], [2, 3]], [5, 3, 9, 2], 2) == (True, 5)\n    assert candidate([], [], [10], 1) == (True, 10)\n    assert candidate([1, 2], [[1, 2], [2, 1]], [2, 7, 3], 3) == (False, 2)\n    assert candidate([1, 2, 3], [[1, 2], [3, 1]], [11, 5, 3], 1) == (True, 11)\n    assert candidate([1, 2, 3, 4], [[1, 2], [2, 3], [3, 4]], [8, 5, 7, 1], 4) == (True, 1)", "entry_point": "arrange_trip_schedule", "extra_info": {"cover_story_words": ["beach", "museum"], "topics": ["Course Schedule", "Kth Largest Element in an Array", "Linked List"], "cleaned_prompt": "Define the function arrange_trip_schedule(courses, prerequisites, museums, k) to determine if it's possible to finish all seminars based on given prerequisites, and to find the k-th most popular museum.", "warnings": ["Solution failed correctness check.", "4, Ambiguity in Problem Statement: The problem statement incorrectly assumes that all 'courses' are represented by unique integers, but does not clarify if they start from zero or one or if they can be any series of increasing integers. This can lead to confusion in mapping courses to 'indegree' and adjacency list indices in the 'can_finish' function."]}}
{"task_id": "hard/1", "prompt": "def cloud_city_escape(paintings, connections):\n    \"\"\"\n    In the future, there exists a unique floating city in the clouds named Aeropolis, known for its extensive art galleries. Every art gallery houses multiple famous paintings. Each gallery, however, can only be visited if the path to it respects a set of conditions based on parentheses matching. The city is structured in a way that every gallery has connections in the form of strings composed of parentheses '()'. To traverse from one gallery to another, the string forming the path must be a valid sequence.\n\n    Write a function that, given a list of 'paintings' (each painting is in a specific gallery) and a graph 'connections' where keys are gallery names and values are dicts pointing to other galleries associated by valid or invalid parentheses strings, returns all unique paths that allow collecting all the paintings in valid sequence only.\n\n    For example:\n    paintings = ['Monalisa', 'Starry Night', 'The Scream']\n    connections = {\n        'Gallery1': {'Gallery2': '()'},\n        'Gallery3': {'Gallery4': ')('},\n        'Gallery2': {'Gallery3': '()'},\n        'Gallery4': {'Gallery1': '(()'}\n    }\n\n    If 'Monalisa' is in Gallery1, 'Starry Night' is in Gallery2, and 'The Scream' is in Gallery4, one possible path could be: ['Gallery1', 'Gallery2', 'Gallery3', 'Gallery4'].\n\n    Remember:\n    - You should only consider paths where the parentheses strings between galleries are valid.\n    - You must visit all galleries containing the target paintings exactly once in any order.\n    - The graph may not be fully connected and may have cycles.\n    - Assume all input strings are non-empty and contain only '(' and ')'.\n    \"\"\"\n", "canonical_solution": "    def is_valid(s):\n        stack = []\n        for char in s:\n            if char == '(': stack.append(char)\n            else:  # char == ')'\n                if not stack or stack.pop() != '(': return False\n        return len(stack) == 0\n\n    def dfs(gallery, path, visited):\n        if len(visited) == len(paintings):\n            if all(p in visit_map.values() for p in paintings):\n                results.append(path[:])\n            return\n        for next_gallery, par_string in connections[gallery].items():\n            if next_gallery not in visited and is_valid(par_string):\n                visit_map[next_gallery] = gallery_paintings[next_gallery]\n                visited.add(next_gallery)\n                path.append(next_gallery)\n                dfs(next_gallery, path, visited)\n                path.pop()\n                visited.remove(next_gallery)\n                del visit_map[next_gallery]\n\n\n    gallery_paintings = {p: g for g, p in enumerate(paintings)}\n    visit_map = {}\n    results = []\n    for gallery in connections:\n        if gallery_paintings[gallery] in paintings:\n            visit_map[gallery] = gallery_paintings[gallery]\n            visited = {gallery}\n            dfs(gallery, [gallery], visited)\n    return results", "test": "def check(candidate):\n    paintings = ['Monalisa', 'Starry Night', 'The Scream']\n    connections = {\n        'Gallery1': {'Gallery2': '()'},\n        'Gallery3': {'Gallery4': ')('},\n        'Gallery2': {'Gallery3': '()'},\n        'Gallery4': {'Gallery1': '(()'}\n    }\n    assert set(tuple(path) for path in candidate(paintings, connections)) == set([('Gallery1', 'Gallery2', 'Gallery3', 'Gallery4')])\n\n    paintings = ['Self Portrait', 'The Garden']\n    connections = {\n        'Imperial': {'Royal': '()'},\n        'Royal': {'Majestic': '()'},\n        'Majestic': {'Imperial': '()))'}\n    }\n    assert set(tuple(path) for path in candidate(paintings, connections)) == set([('Imperial', 'Royal', 'Majestic')])", "entry_point": "cloud_city_escape", "extra_info": {"cover_story_words": ["art gallery", "cloud city"], "topics": ["Breadth-First Search", "Backtracking", "Valid Parentheses"], "cleaned_prompt": "Write a function that given a list of 'paintings' (each painting is in a specific gallery) and a graph 'connections' where keys are gallery names and values are dicts pointing to other galleries associated by valid or invalid parentheses strings, returns all unique paths that allow collecting all the paintings in valid sequence only.", "warnings": ["Only 2 test cases found. Minimum recommended is 5.", "Solution failed correctness check.", "4, Unclear Gallery-Painting Mapping: The problem statement lacks a clear specification of the mapping between galleries and paintings. Without this mapping, it's impossible to determine or even implement a function that identifies which paintings are housed in each gallery, which is essential to solve the route problem as described.", "5, Canonical Solution Incoherence: The provided canonical solution has logical inconsistencies and incorrect implementation details which do not conform to the described problem prompt. For instance, the dictionary `gallery_paintings` is created in an illogical manner using `{p: g for g, p in enumerate(paintings)}` which incorrectly uses paintings as keys and their indices as values, mismatching galleries with paintings. This makes the solution unworkable and highlights substantial issues in the clarity and feasibility of the provided solution approach."]}}
{"task_id": "hard/5", "prompt": "def steampunk_future_visions(stream, sequence_length, reverse_every):\n    \"\"\"\n    In the land of Steampunk, engineers use special crystal balls to foresee computational challenges. You're tasked with developing a system for such a ball that processes data in a unique way involving a Linked List, Data Stream, and the concept of a Minimum Spanning Tree (MST).\n\n    Specifically, you are given a data stream of integers. Your task involves three main operations:\n    1. Convert the stream of numbers into a doubly linked list until you've processed 'sequence_length' numbers.\n    2. Every 'reverse_every' numbers inserted into the list, the list should be reversed.\n    3. After all numbers are processed into the list and the appropriate reversals are done, compute the minimum spanning tree (MST) of a graph, where each unique number in the list represents a node. The edge weight between any two nodes (numbers) is the difference between those two numbers.\n\n    You should return the total weight of the MST.\n\n    - If `sequence_length` is less than 2, return 0.\n    - Assume there will always be at least `sequence_length` numbers in the stream.\n\n    Note that the crystal ball's capacity (sequence_length) might not fit the entire stream in one viewing, so handling the data sequentially as it comes is crucial.\n    \"\"\"\n", "canonical_solution": "    class Node:\n        def __init__(self, value):\n            self.value = value\n            self.prev = None\n            self.next = None\n\n    class DoublyLinkedList:\n        def __init__(self):\n            self.head = None\n            self.tail = None\n\n        def append(self, value):\n            new_node = Node(value)\n            if not self.head:\n                self.head = self.tail = new_node\n            else:\n                self.tail.next = new_node\n                new_node.prev = self.tail\n                self.tail = new_node\n\n        def reverse(self):\n            current = self.head\n            while current:\n                current.prev, current.next = current.next, current.prev\n                current = current.prev\n            self.head, self.tail = self.tail, self.head\n\n    def kruskal(nodes):\n        # Function to perform Kruskal's algorithm to find MST\n        parent = {}\n        rank = {}\n\n        def find(node):\n            if parent[node] != node:\n                parent[node] = find(parent[node])\n            return parent[node]\n\n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                if rank[root1] > rank[root2]:\n                    parent[root2] = root1\n                else:\n                    parent[root1] = root2\n                    if rank[root1] == rank[root2]:\n                        rank[root2] += 1\n\n        # Initialize nodes\n        for node in nodes:\n            parent[node] = node\n            rank[node] = 0\n\n        edges = []\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                edges.append((abs(nodes[i] - nodes[j]), nodes[i], nodes[j]))\n\n        edges.sort()\n        mst_weight = 0\n        for weight, node1, node2 in edges:\n            if find(node1) != find(node2):\n                union(node1, node2)\n                mst_weight += weight\n\n        return mst_weight\n\n    def process_stream(stream, sequence_length, reverse_every):\n        dll = DoublyLinkedList()\n        for index, number in enumerate(stream):\n            dll.append(number)\n            if (index + 1) % reverse_every == 0:\n                dll.reverse()\n            if index + 1 == sequence_length:\n                break\n\n        nodes = set()\n        current = dll.head\n        while current:\n            nodes.add(current.value)\n            current = current.next\n\n        return kruskal(sorted(nodes))\n\n    return process_stream(stream, sequence_length, reverse_every)", "test": "def check(candidate):\n    assert candidate([2, 4, 6, 8, 10], 5, 3) == 4\n    assert candidate([1, 7, 3, 9, 2, 4, 5], 7, 2) == 8\n    assert candidate([5, 5, 5, 5, 5, 5], 6, 1) == 0\n    assert candidate([10, 2, 15, 3, 20, 18], 3, 1) == 11\n    assert candidate([0, 4, 0, 5, 1], 6, 4) == 5", "entry_point": "steampunk_future_visions", "extra_info": {"cover_story_words": ["steampunk", "crystal ball"], "topics": ["Reverse Linked List", "Data Stream", "Minimum Spanning Tree"], "cleaned_prompt": "def steampunk_future_visions(stream, sequence_length, reverse_every):\n    Process a data stream into a doubly linked list until sequence_length is reached. Reverse the list every 'reverse_every' insertions. After all operations on the list, use the nodes in the list to create a graph, where edge weight is the difference between the nodes, and compute the minimum spanning tree (MST) weight for that graph.\n    If sequence_length < 2, return 0.", "warnings": ["Solution failed correctness check.", "5, Inconsistent input definition in test cases: The test case `assert candidate([0, 4, 0, 5, 1], 6, 4) == 5` specifies a `sequence_length` of 6 when only 5 numbers are provided in the stream. This conflicts with the assumption stated in the prompt that \"there will always be at least `sequence_length` numbers in the stream\".", "4, Unclear edge connection rules in MST calculation: The prompt does not clearly define how edges should be created between nodes in the minimum spanning tree. It ambiguously states that the edge weight is the difference between numbers, but does not clarify if every pair of nodes should be connected, which is critical for understanding the proper construction of the graph."]}}
{"task_id": "hard/3", "prompt": "def weather_prediction(data):\n    \"\"\"\n    In an enchanting land with a vast cloud city and dense forests, mystical creatures rely on your weather prediction skills. They collect information by sending data from different zones in linked list format where each node represents a meteorological station. Each node contains a value that represents the wind speed for that station.\n\n    This wind speed can determine the likelihood of rain in that zone. The rain probability P for a zone is calculated as follows:\n    P = (number of unique wind speeds >= average wind speed) / (total number of unique wind speeds in that zone)\n\n    Your task is to compute the average rain probability over all zones given the input linked list of rainfall data for multiple zones. Each zone's data ends with a 'None'. If a zone has no valid data (empty linked list segment), the probability for that zone is 1. Input format is described below:\n\n    Class ListNode:\n        def __init__(self, x):\n            self.val = x\n            self.next = None\n\n    Input: linked list\n    Output: float - Average probability of rain across all zones\n\n    Note:\n    - The linked list may represent multiple zones connected in series, each separated by a 'None' node.\n    - Wind speeds are integers.\n\n    Implement this using a bucket sort or a similar non-comparison based sorting algorithm for efficiency reasons due to potentially large meteorological data sets.\n    \"\"\"\n", "canonical_solution": "    class ListNode:\n        def __init__(self, x):\n            self.val = x\n            self.next = None\n\n    def compute_probability(zone):\n        if not zone:\n            return 1\n        counts = {}\n        for speed in zone:\n            counts[speed] = counts.get(speed, 0) + 1\n        total = sum(counts.values())\n        avg = float(sum(speed * count for speed, count in counts.items())) / total\n        eligible = sum(1 for speed in counts if speed >= avg)\n        return eligible / len(counts) if counts else 1\n\n    def weather_prediction(head):\n        if not head:\n            return float(1)\n\n        current = head\n        probs = []\n        current_zone = []\n        while current:\n            if current.val is None:\n                probs.append(compute_probability(current_zone))\n                current_zone = []\n            else:\n                current_zone.append(current.val)\n            current = current.next\n        if current_zone:\n            probs.append(compute_probability(current_zone))\n\n        return sum(probs) / len(probs) if probs else 1", "test": "def check(candidate):\n    # Helper to build linked lists\n    def build_list(values):\n        head = ListNode(0)\n        current = head\n        for value in values:\n            if value is None:\n                current.next = None\n            else:\n                current.next = ListNode(value)\n            current = current.next\n        return head.next\n\n    # Tests\n    assert abs(candidate(build_list([3, 4, None, 5, 6, 6, None, None])) - 0.75) < 1e-5\n    assert candidate(None) == 1\n    assert candidate(build_list([None, None, None])) == 1\n    assert abs(candidate(build_list([5, 7, 7, 8, None, 10])) - 0.75) < 1e-5\n    assert abs(candidate(build_list([15, 15, 18, 15, 25, 5, None, 12, None, 4])) - 0.75) < 1e-5", "entry_point": "weather_prediction", "extra_info": {"cover_story_words": ["cloud city", "enchanted forest"], "topics": ["Bucket Sort", "Probability and Statistics", "Linked List"], "cleaned_prompt": "Implement a function `weather_prediction(data)` that takes a linked list of wind speeds, interprets each segment separated by 'None' as a zone, calculates a probability of rain for each zone (using given formula), and returns the average of these probabilities.", "warnings": ["Solution failed correctness check.", "5, UndefinedNodeHandling: The linked list format expects the use of 'None' values as separators between zones, but in Python, such an implementation for linked lists involving 'None' as a value is problematic. The canonical solution fails to check if current.next exists when appending None for a new ListNode, causing potential issues in data structure integrity when interpreting zones.", "5, IncorrectSortingRequirement: The problem statement's recommendation to use a bucket sort or a similar non-comparison based sorting algorithm is potentially inefficient or incorrect for determining wind speed averages and counts in small zones since bucket sort suits uniform distributions, large datasets, and requires additional memory allocation.", "4, UndefinedAverageBehavior: The prompt does not clearly define or handle the case where zones might have wind speeds as negative values or how these should be treated in the computation of averages and probability. This could lead to inconsistencies in results where datasets include such values.", "4, InputSpecificationUnclear: The problem statement does not clearly specify whether the linked list is singly linked or doubly linked which can affect the implementation approach. It also does not explicitly define the structure beyond each node having 'val' and 'next' attributes; essential details for correct implementation are vague.", "5, IncorrectTestImplementation: In the provided tests, there is a logical flaw where a new ListNode is created with None as a value, which does not properly mimic a real-world use case of a linked list. This would cause a type inconsistency error as linked lists in practice do not accept None as a node value but rather use None to represent the end of the list.", "5, PerformanceIssues: The recommendation to use non-comparison based sorting algorithms bares no necessity or clear rationale based on wind speeds which are typically small datasets per zone. This design decision could lead to inefficient or overly complex implementations that do not optimize algorithmic complexity or resource usage."]}}
{"task_id": "hard/4", "prompt": "def playful_river(grumpy_cloud_matrix, messages):\n    \"\"\"\n    There is a mysterious grumpy cloud that can convert portions of a river into various symbols. The river's behavior can be represented as a matrix where certain storms (grumpy clouds) can increase or decrease the visibility of certain symbols. If a zero appears in the matrix, the entire row and column of that zero are effectively wiped out by the storm, becoming zeros themselves.\n\n    Alongside this, each row in the river matrix can be interpreted as a message using a modified Decode Ways approach. The message is a list of integers, where each integer can be converted into a character: '1' -> 'A', '2' -> 'B', ..., '26' -> 'Z'. Some of these messages might be corrupted by zeros introduced through the storm, adjusting how they can be decoded.\n\n    You are tasked with determining how many different ways each message can be decoded after the river has transformed it with the grumpy cloud effect.\n\n    Begin by transforming the matrix as per the storm effect. Then for each row in the matrix, interpret it as a message and determine how many ways it can be decoded.\n\n    Parameters:\n    grumpy_cloud_matrix (List[List[int]]): A 2D matrix depicting the state of the river with numeric values. Zeros in this matrix will affect its entire row and column.\n    messages (List[List[int]]): Original messages that can be decoded, to prove how the matrix transforms them.\n\n    Return:\n    List[int]: A list with the number of possible decodings for each transformed message. The length of this result list should match the length of the messages list.\n    \"\"\"\n", "canonical_solution": "def playful_river(grumpy_cloud_matrix, messages):\n    def set_zeros(matrix):\n        rows, cols = len(matrix), len(matrix[0])\n        rows_to_zero = set()\n        cols_to_zero = set()\n        for r in range(rows):\n            for c in range(cols):\n                if matrix[r][c] == 0:\n                    rows_to_zero.add(r)\n                    cols_to_zero.add(c)\n        for r in rows_to_zero:\n            for c in range(cols):\n                matrix[r][c] = 0\n        for c in cols_to_zero:\n            for r in range(rows):\n                matrix[r][c] = 0\n\n    def decode_ways(nums):\n        if not nums or nums[0] == 0:\n            return 0\n        dp = [0] * (len(nums) + 1)\n        dp[0], dp[1] = 1, 1\n        for i in range(2, len(nums) + 1):\n            if nums[i - 1] > 0:\n                dp[i] += dp[i - 1]\n            if 10 <= nums[i - 2]*10 + nums[i - 1] <= 26:\n                dp[i] += dp[i - 2]\n        return dp[-1]\n\n    set_zeros(grumpy_cloud_matrix)\n    decoded_counts = []\n    for message in messages:\n        transformed_message = [grumpy_cloud_matrix[i][j] for i, j in enumerate(message)]\n        count = decode_ways(transformed_message)\n        decoded_counts.append(count)\n    return decoded_counts", "test": "def check(candidate):\n    assert candidate([[0, 1, 1], [1, 1, 1], [1, 1, 1]], [[1, 1, 1], [2, 2, 2], [0, 0, 0]]) == [1, 0, 0]\n    assert candidate([[5, 0, 9], [8, 7, 6], [9, 1, 0]], [[2, 2, 2], [0, 0, 0], [1, 1, 1]]) == [0, 0, 1]\n    assert candidate([[5, 1, 9], [8, 7, 6], [9, 1, 10]], [[2, 1, 2], [0, 1, 2], [0, 1, 2]]) == [1, 0, 0]\n    assert candidate([[1, 1, 1], [1, 1, 1], [1, 1, 1]], [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == [1, 1, 1]\n    assert candidate([[10, 23, 1], [23, 10, 13], [14, 25, 16]], [[0, 1, 2], [1, 1, 1], [0, 1, 2]]) == [234, 8064, 234]\n", "entry_point": "playful_river", "extra_info": {"cover_story_words": ["playful river", "grumpy cloud"], "topics": ["Decode Ways", "Breadth-First Search", "Set Matrix Zeroes"], "cleaned_prompt": "Transform a matrix by setting entire rows and columns to zero if an element is zero. Then interpret each row in the matrix as a coded message where '1' to '26' map to 'A' to 'Z', respectively. Determine how many ways each coded message can be decoded after applying the transformation.", "warnings": ["Solution failed correctness check.", "5, Unclear mapping between messages and transformed matrix: The problem description and the canonical solution indicate that messages should be transformed into a list based on the grumpy_cloud_matrix indices. However, it's unclear how the elements in each message list relate to positions in the matrix. This makes the task ambiguous, as it is uncertain whether each value in the message lists represents indices within the matrix rows or columns or some transformation of these. The solution's logic cannot be validated properly without a clear understanding of how messages are intended to map to and interact with the modified matrix.", "4, Incorrect assumption about matrix and message relationship: Based on the canonical solution, there seems to be an implied assumption that the length of each message is equal to the number of rows or columns in the grumpy_cloud_matrix. This is problematic because if the lengths do not match, the solution will either be incorrect by failing to process some data or by attempting to access indices that do not exist, leading to errors.", "5, Potential for IndexError or wrong logic: The provided solution and problem description miss detailing the expected size of the matrix against the length of messages. If there is an inconsistency here (size mismatch), the code might lead to IndexError because of out-of-range access to matrix elements, and the logic to transform the message based on the indices derived from the message itself is very likely to fail. This introduces a significant logical flaw in implementation and understanding."]}}
