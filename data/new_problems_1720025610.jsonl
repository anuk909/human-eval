{"task_id": "hard/1", "prompt": "def castle_and_carnival_view(points, lists_of_sorted_lists):\n    \"\"\"\n    In a realm where the majesty of medieval castles is lightened by the cosmic showers of falling stars, you have two major tasks involving data about star energies and optimal visual viewing points. Implement a function with two specific tasks:\n    1. Merge all the k sorted lists of star energies into a single sorted list. Each list is already sorted, and your merged result should maintain proper order across all elements. Return this merged list.\n    2. Given an array of tuples representing points with properties of 'brightness' and 'clarity', return the top three distinct points which provide the most outstanding views. Points should be sorted primarily by 'brightness' and secondary by 'clarity' for resolving ties. Each tuple format is (brightness, clarity).\n\n    Examples:\n    points = [(10, 5), (15, 15), (20, 10), (25, 5), (10, 20)]\n    lists_of_sorted_lists = [[4,5,6], [1,2], [6,10]]\n    Output should be:\n    Merged List: [1,2,4,5,6,6,10]\n    Top 3 Points: [(25, 5), (20, 10), (15, 15)]\n\n    Note that the function should handle cases such as empty input lists or where fewer than three distinct points are provided, by returning appropriate empty list structures or the available points.\n    \"\"\"", "canonical_solution": "def castle_and_carnival_view(points, lists_of_sorted_lists):\n        from heapq import heappush, heappop\n        def merge_k_sorted_lists(lists):\n            min_heap = []\n            for sorted_list in lists:\n                for element in sorted_list:\n                    heappush(min_heap, element)\n            merged_list = []\n            while min_heap:\n                merged_list.append(heappop(min_heap))\n            return merged_list\n\n        def top_3_points(points):\n            unique_points = set(points)\n            sorted_points = sorted(unique_points, key=lambda x: (-x[0], -x[1]))\n            return sorted_points[:3]\n\n        merged_list = merge_k_sorted_lists(lists_of_sorted_lists)\n        top_points = top_3_points(points)\n        return merged_list, top_points", "test": "def check(candidate):\n    assert candidate([(10, 5), (15, 15), (20, 10), (10, 5), (25, 5)], [[4,5,6], [1,2], [6,10]]) == ([1,2,4,5,6,6,10], [(25, 5), (20, 10), (15, 15)])\n    assert candidate([(5, 25), (10, 5), (15, 15), (20, 10), (25, 25)], [[5,9], [2,3,8], [11]]) == ([2,3,5,8,9,11], [(25, 25), (20, 10), (15, 15)])\n    assert candidate([(1, 1), (2, 2), (3, 3)], [[1], [2], [3]]) == ([1,2,3], [(3, 3), (2, 2), (1, 1)])\n    assert candidate([(30, 10), (20, 15), (30, 10)], [[7], [10,11], []]) == ([7,10,11], [(30, 10), (20, 15)])\n    assert candidate([], []) == ([], [])", "entry_point": "castle_and_carnival_view", "extra_info": {"cover_story_words": ["medieval castle", "cosmic carnival"], "topics": ["Merge k Sorted Lists", "Data Sorting"], "cleaned_prompt": "Implement a function to merge multiple sorted lists into a single sorted list and to return the top 3 distinct points based on brightness and clarity from an array of tuples.", "warnings": []}}
{"task_id": "hard/4", "prompt": "def most_frequent_suffix(cloud_layers):\n    \"\"\"\n    In a scenario where multiple layers of cloud patterns exist, represented as strings, your task is to determine for each layer which suffix appears the most frequently.\n\n    Define 'most frequent suffix' as the suffix that appears the highest number of times in the string. A 'suffix' is defined as any substring that starts from any position in the string and extends to its end.\n\n    First, construct a Suffix Array for each layer's string representation. Then, calculate the frequency of each unique suffix using a dictionary. Determine and return the most frequent suffix for each cloud layer, selecting the lexicographically smallest one in case of frequency ties.\n\n    The function should return a list of strings, representing the most frequent suffix from every layer.\n\n    Examples:\n    - If the input cloud layers are ['abrakadabra', 'bolo'], the expected output should be ['a', 'o']. Here, the suffix 'a' repeats most frequently in 'abrakadabra', and 'o' in 'bolo'.\n    \"\"\"\n", "canonical_solution": "    import heapq\n\n    def build_suffix_array(s):\n        suffixes = sorted((s[i:], i) for i in range(len(s)))\n        suffix_array = [suffix[0] for suffix in suffixes]\n        return suffix_array\n\n    def most_frequent(suffix_array):\n        count_dict = {}\n        for suffix in suffix_array:\n            count_dict[suffix] = count_dict.get(suffix, 0) + 1\n        max_heap = [(-freq, suffix) for suffix, freq in count_dict.items()]\n        heapq.heapify(max_heap)\n        freq, suffix = heapq.heappop(max_heap)\n        while max_heap and -max_heap[0][0] == -freq:\n            next_freq, next_suffix = heapq.heappop(max_heap)\n            if next_suffix < suffix:\n                suffix = next_suffix\n        return suffix\n\n    results = []\n    for layer in cloud_layers:\n        suffix_array = build_suffix_array(layer)\n        dominant = most_frequent(suffix_array)\n        results.append(dominant)\n    return results\n", "test": "def check(candidate):\n    assert candidate(['abrakadabra', 'bolo']) == ['a', 'o']\n    assert candidate(['a', 'bbbb', 'ccccc', 'dddddd']) == ['a', 'b', 'c', 'd']\n    assert candidate(['xyzabc', 'zabxy']) == ['zabc', 'zxy']\n    assert candidate(['racecar', 'rotor', 'civic']) == ['racecar', 'rotor', 'ivic']\n    assert candidate(['hello', 'world']) == ['o', 'd']\n", "entry_point": "most_frequent_suffix", "extra_info": {"cover_story_words": ["cloud city", "pattern matching", "string manipulation"], "topics": ["Suffix Array", "String Algorithms", "Heap (Priority Queue)"], "cleaned_prompt": "def most_frequent_suffix(cloud_layers):\n    Determine the most frequent suffix for each cloud layer using a Suffix Array and a max-heap. The most frequent suffix is the one with the highest frequency. Return a list of the most frequent suffixes, selecting lexicographically smaller ones in case of ties.\n\n    Examples:\n    - For ['abrakadabra', 'bolo'], the return should be ['a', 'o'].", "warnings": ["Solution passed correctness check after revision.", "Problem description and examples are now aligned to correctly define suffixes and their counting within each layer.", "Clarified the handling of dominance and ties with detailed definitions and examples showcasing decision-making in such scenarios."]}}
{"task_id": "hard/3", "prompt": "def spaceship_wizard_magic(image, spells):\n    \"\"\"\n    In a futuristic world, spaceships are powered by magical spells cast by wizards. The power of each spell is determined by the number of visible stars in a specific region (rectangle) of the galaxy captured in a nighttime image. The wizard's powerful magic requires prime spells, and spells interact through the greatest common denominator of their powers in accordance with ancient wizardry laws.\n\n    Given a binary image (2D list) where 1 represents a star and 0 represents empty space, and a list of rectangle coordinates that denote specific regions in the image, compute and return:\n    - The prime power spell for each region.\n    - The greatest common denominator of all prime power spells computed.\n\n    The prime power spell of a region is defined as the sum of stars (1's) calculated for that region of the image and must itself be a prime number. If a region's sum is not prime, it should be substituted with the next largest prime number.\n\n    Use the Miller-Rabin primality test to identify prime numbers and the Euclidean algorithm to calculate the greatest common denominator (GCD).\n\n    Consider only unique regions, i.e., identical coordinate tuples should be considered once. The regions are defined by tuples (row_start, row_end, col_start, col_end), 0-indexed and inclusive.\n\n    Example input image, spells and output are illustrated in the problems below.\n\n    Note:\n    - The image is of size NxM, and regions can cover any part without exceeding the image bounds.\n    - Process the output in the format: {'spells': [list_of_prime_powers], 'gcd': gcd_of_prime_powers}\n    \"\"\"", "canonical_solution": "    from random import randrange\n    def is_prime(n, k=5):  # Miller-Rabin\n        if n <= 1: return False\n        if n <= 3: return True\n        if n % 2 == 0: return False\n        d = n - 1\n        while d % 2 == 0: d //= 2\n        for _ in range(k):\n            a = randrange(2, n - 1)\n            x = pow(a, d, n)\n            if x == 1 or x == n - 1: continue\n            while d != n - 1:\n                x = (x * x) % n\n                d *= 2\n                if x == 1: return False\n                if x == n - 1: break\n            else: return False\n        return True\n    def next_prime(n):\n        temp = n + 1\n        while not is_prime(temp): temp += 1\n        return temp\n    def gcd(x, y):\n        while y != 0: (x, y) = (y, x % y)\n        return x\n    def calculate_region_sum(image, sr, er, sc, ec):\n        return sum(sum(row[sc:ec+1]) for row in image[sr:er+1])\n    def spaceship_wizard_magic(image, spells):\n        unique_spells = list(set(spells))\n        prime_spells = []\n        for (sr, er, sc, ec) in unique_spells:\n            region_sum = calculate_region_sum(image, sr, er, sc, ec)\n            if not is_prime(region_sum):\n                region_sum = next_prime(region_sum)\n            prime_spells.append(region_sum)\n        all_gcd = prime_spells[0]\n        for spell_power in prime_spells[1:]:\n            all_gcd = gcd(all_gcd, spell_power)\n        return {'spells': prime_spells, 'gcd': all_gcd}", "test": "def check(candidate):\n    image = [[1, 0, 0], [0, 1, 1], [1, 0, 1]]\n    spells = [(0, 2, 0, 2), (1, 2, 1, 2)]\n    assert candidate(image, spells) == {'spells': [5, 3], 'gcd': 1}\n    image2 = [[1, 0], [1, 1]]\n    spells2 = [(0, 1, 0, 1)]\n    assert candidate(image2, spells2) == {'spells': [3], 'gcd': 3}\n    image3 = [[1]*10]*10\n    spells3 = [(0, 9, 0, 9), (0, 9, 0, 9)]  # unique handling\n    assert candidate(image3, spells3) == {'spells': [101], 'gcd': 101}\n    image4 = [[0]*5]*5\n    spells4 = [(0, 4, 0, 4)]\n    assert candidate(image4, spells4) == {'spells': [2], 'gcd': 2}\n    image5 = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    spells5 = [(0, 0, 0, 2), (1, 1, 1, 1), (2, 2, 0, 2)]\n    assert candidate(image5, spells5) == {'spells': [3, 2, 3], 'gcd': 1}", "entry_point": "spaceship_wizard_magic", "extra_info": {"cover_story_words": ["spaceship", "wizards"], "topics": ["Miller-Rabin Primality Test", "Euclidean Algorithm"]}}
{"task_id": "hard/2", "prompt": "def find_subset_partition_with_sampling(points, reservoir_size):\n    \"\"\"\n    Imagine a scenario set on the floating islands of Aereon, where each island has a specific weight represented as integers in a list `points`. Two seekers equipped with mind-reading helmets are tasked with equally balancing the island weights by partitioning them into subsets.\n\n    The complex twist is that due to a magical constraint, the seekers' helmets can only process up to `reservoir_size` number of island weights at any given moment.\n\n    The challenge is to determine if it's possible to divide the list of `points` into two subsets such that:\n    - Both subsets sum to the same value.\n    - Each subset consists of no more than `reservoir_size` elements.\n\n    The function should involve a reservoir sampling technique to possibly achieve this division, given the limitations.\n\n    The function should return True if such a division is possible, and False otherwise.\n\n    Examples:\n    - If `points = [1, 5, 11, 5]` and `reservoir_size = 2`, the subsets can be `[1, 5]` and `[5, 11]`, suggesting a True condition (note corrected subsets might not exist if manually calculated).\n    - If `points = [1, 2, 3, 5, 8, 13, 21]` and `reservoir_size = 4`, it would return False due to lack of valid partitions.\n\n    Constraints:\n    - The sum of `points` must be even.\n    - Small `reservoir_size` relative to the necessary half-sum of points might make partitioning impossible.\n    \"\"\"\n", "canonical_solution": "def find_subset_partition_with_sampling(points, reservoir_size):\n    from random import randrange\n\n    def can_split_with_subset(available_points, target_sum, subset_size):\n        subset = [0] * (target_sum + 1)\n        subset[0] = 1\n        for num in available_points:\n            for j in range(target_sum, num - 1, -1):\n                if subset[j - num] > 0:\n                    subset[j] = 1\n        return subset[target_sum] >= 1\n\n    total_sum = sum(points)\n    if total_sum % 2 != 0:\n        return False\n\n    target = total_sum // 2\n\n    samples = []\n    for _ in range(reservoir_size):\n        index = randrange(len(points))\n        samples.append(points[index])\n        points.pop(index)\n\n    return can_split_with_subset(samples, target, reservoir_size)\n\n", "test": "def check(candidate):\n    assert candidate([1, 5, 11, 5], 2) == True\n    assert candidate([1, 2, 3, 5, 8, 13, 21], 4) == False\n    assert candidate([3, 1, 1, 2, 2, 1], 3) == True\n    assert candidate([10, 10, 10, 10, 10, 10, 10, 10], 4) == False\n    assert candidate([1, 1, 1, 1, 1, 1, 6], 4) == True\n", "entry_point": "find_subset_partition_with_sampling", "extra_info": {"cover_story_words": ["floating island", "mind-reading helmet"], "topics": ["Partition Equal Subset Sum", "Reservoir Sampling"], "cleaned_prompt": "Write a function to determine if a list of weights representing floating islands can be partitioned into two subsets that:\n- Have an equal sum,\n- Contain at most a given number of elements (`reservoir_size`),\nusing reservoir sampling.\n\nFor weights [1, 5, 11, 5] and reservoir_size 2, it returns False as no valid subset partitions exist fulfilling both conditions.\nFor weights [1, 2, 3, 5, 8, 13, 21] and reservoir_size 4, it returns False since no valid partition exists where each subset has at most 4 elements and equal sums.", "warnings": ["The provided examples in the problem statement have been aligned with the problem constraints to avoid any mismatches between expected behavior and example outputs."]}}
{"task_id": "hard/5", "prompt": "def locate_gems(map_image, queries):\n    \"\"\"\n    Imagine a magical world filled with floating islands where wizards diligently practice their arcane arts. Each of these floating islands contains precious magic gems, essential for spell casting, embedded within the land. However, the exact locations of these gems are often shrouded in mystery, concealed within ancient map images portrayed as a 2D matrix.\n\n    Your task is to assist wizards by creating a function that discovers all valid areas containing gems based on specific queries. Each query defines criteria for gem groupings that must be explored: a maximum search area ('max_search_area') and a minimum number of gems ('min_gems_count'). The function should analyze the map, a 2D matrix of 0s and 1s (where 0 signifies an empty spot and 1 indicates a gem), and identify all regions where the size of the contiguous group of gems is strictly smaller than 'max_search_area' and contains at least 'min_gems_count' gems. Your function must return a list of lists, where each inner list contains the coordinates (row, column) of gems for every valid area found, corresponding to each query.\n\n    For detecting regions, implement a flood-fill algorithm considering 8-connectivity (gems are connected vertically, horizontally, or diagonally).\n\n    Example:\n    map_image = [[0, 1, 0, 0],[0, 1, 1, 0],[0, 0, 1, 0],[1, 0, 0, 0]]\n    queries = [(5, 3), (4, 2)]\n    output should be [[[0, 1], [1, 1], [1, 2], [2, 2]], [[0, 1], [1, 1]]]\n\n    \"\"\"", "canonical_solution": "def locate_gems(map_image, queries):\n    def is_within_bounds(x, y):\n        return 0 <= x < len(map_image) and 0 <= y < len(map_image[0])\n\n    def search_area(x, y, visited):\n        stack = [(x, y)]\n        area = []\n        while stack:\n            cx, cy = stack.pop()\n            if (cx, cy) in visited:\n                continue\n            visited.add((cx, cy))\n            area.append([cx, cy])\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    nx, ny = cx + dx, cy + dy\n                    if is_within_bounds(nx, ny) and map_image[nx][ny] == 1 and (nx, ny) not in visited:\n                        stack.append((nx, ny))\n        return area\n\n    results = []\n    for max_area, min_gems in queries:\n        valid_areas = []\n        visited = set()\n        for x in range(len(map_image)):\n            for y in range(len(map_image[0])):\n                if map_image[x][y] == 1 and (x, y) not in visited:\n                    area = search_area(x, y, visited)\n                    if min_gems <= len(area) < max_area:\n                        valid_areas.append(area)\n        results.append(valid_areas)\n    return results", "test": "def check(candidate):\n    map_image1 = [[0, 1, 0, 0],[0, 1, 1, 0],[0, 0, 1, 0],[1, 0, 0, 0]]\n    queries1 = [(5, 3), (4, 2)]\n    assert candidate(map_image1, queries1) == [[[0, 1], [1, 1], [1, 2], [2, 2]], [[0, 1], [1, 1]]]\n\n    map_image2 = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    queries2 = [(9, 5), (5, 4)]\n    assert candidate(map_image2, queries2) == [[], []]\n\n    map_image3 = [[0]]\n    queries3 = [(1, 1)]\n    assert candidate(map_image3, queries3) == [[]]\n\n    map_image4 = [[1, 1, 1, 0], [1, 0, 0, 1], [0, 0, 1, 1]]\n    queries4 = [(6, 2)]\n    assert candidate(map_image4, queries4) == [[[0, 0], [0, 1], [0, 2], [1, 0]]]", "entry_point": "locate_gems", "extra_info": {"cover_story_words": ["floating island", "wizards"], "topics": ["Database", "Geometry"], "cleaned_prompt": "def locate_gems(map_image, queries):\n    \"\"\"\n    The function should process a 2D map image consisting of '0's (empty) and '1's (gems), returning regions of contiguous gems that match each query's criteria for maximum area and minimum gem count. Implement flood-fill for region finding, considering 8-connectivity of gems.\n    \"\"\"", "warnings": ["Only 4 test cases found. Minimum recommended is 5.", "Solution failed correctness check."]}}
