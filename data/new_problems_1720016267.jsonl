{"task_id": "hard/3", "prompt": "def maximum_balloon_visibility(data_matrix):\n    \"\"\"\n    In a parallel universe, researchers are studying visibility patterns of hot air balloons from their labs which are structured in a tree-form matrix.\n\n    Design a function that takes as input a 2D matrix (list of lists) where each cell contains a tuple. The first element of the tuple represents the height of a lab and the second element represents the number of hot air balloons visible from that lab. The structure of the 2D matrix represents a quad-tree: every cell (lab) can have four children, corresponding to the cells immediately to the right (East), immediately below (South), bottom-right (Southeast), and bottom-left (Southwest) within its own sub-matrix if such cells exist.\n\n    The goal is to find out the maximum number of hot air balloons visible from any lab in the matrix. Use a 'divide and conquer' approach efficiently, applying recursion suitable for processing tree-structured data.\n\n    For example, if the input matrix is:\n    [\n        [(3, 2), (1, 5)],\n        [(7, 1), (2, 3)]\n    ]\n    The output should be 5, which is the maximum number of balloons seen (from the lab with height 1).\n\n    Constraints:\n    - The height of a lab does not affect the visibility of balloons.\n    - The matrix will always be of a size 2^n x 2^n.\n    - The elements of the matrix represent (height, balloons), where both are integers.\n    \"\"\"", "canonical_solution": "    def max_balloons(matrix):\n        if len(matrix) == 1 and len(matrix[0]) == 1:\n            return matrix[0][0][1]\n\n        mid = len(matrix) // 2\n        top_left = [row[:mid] for row in matrix[:mid]]\n        top_right = [row[mid:] for row in matrix[:mid]]\n        bottom_left = [row[:mid] for row in matrix[mid:]]\n        bottom_right = [row[mid:] for row in matrix[mid:]]\n\n        return max(max_balloons(top_left), max_balloons(top_right), max_balloons(bottom_left), max_balloons(bottom_right))\n\n    return max_balloons(data_matrix)", "entry_point": "maximum_balloon_visibility", "test": "def check(candidate):\n    assert candidate([[(3, 2), (1, 5)], [(7, 1), (2, 3)]]) == 5\n    assert candidate([[(3, 2)],[ (7, 1)] ]) == 2\n    assert candidate([[(10, 8)],[(20, 3)]]) == 8\n    assert candidate([[ (5, 1), (4, 4)], [ (7, 5), (8, 6)], [(2, 3), (3, 2)], [(1, 4), (9, 7)]]) == 6\n    assert candidate([[ (12, 12)], [(23, 11)]]) == 12", "extra_info": {"cover_story_words": ["parallel universe", "hot air balloon"], "topics": ["Divide and Conquer", "Tree"], "cleaned_prompt": "def maximum_balloon_visibility(data_matrix):\n    \"\"\"\n    Input: a 2D matrix (list of lists) where each cell contains a tuple. Each tuple's first element represents the height of a lab, and the second element represents the number of hot air balloons visible. The matrix represents a quad-tree. Find the maximum number of hot air balloons visible from any lab using a 'divide and conquer' approach.\n\n    Each lab's tuple is of form (height, balloons) where both are integers, and the matrix is always size 2^n x 2^n.\n    \"\"\"", "warnings": ["Solution failed correctness check.", "4, Inconsistency in matrix size handling: The problem statement specifies that the input matrix will always be of size 2^n x 2^n, but tests include matrices that are not of this size, for example, a matrix of size 1x2. This inconsistency can lead to confusion or errors when implementing the solution, as the provided solution assumes a square matrix of size corresponding to powers of two.", "4, Canonical solution implementation missing entry-point function: The canonical solution provides the logic inside a function named \"max_balloons\" which is locally defined within another function not provided in the text but assumed to be \"maximum_balloon_visibility\". The entire solution should be enclosed correctly in the function that matches the entry point specified in the prompt to ensure clarity and correctness."]}}
{"task_id": "hard/1", "prompt": "def minimum_suffix_clone_time(price_changes, queries):\n    \"\"\"\n    You are the engineer for a cosmic carnival where a newly designed cloning device has been installed. The device allows objects to be cloned instantly but lacking adjustments, it adds some cost on each subsequent clone.\n\n    The price changes for cloning are represented in the list 'price_changes', where each element represents the additional cost to the price for each clone made at that number of operations. For instance, price_changes[i] indicates the additional cost added when the (i+1)-th clone is made.\n\n    Your task is to calculate the minimum cost to produce clones over a range of operations for several queries. Each query is represented by a tuple containing two integers (l, r), representing the inclusive range from the l-th to the r-th operation within the price_changes list.\n\n    Your solution should implement the preprocessing of the 'price_changes' with a Segment Tree for range minimum queries, and answer each query in logarithmic time using that preprocessing result.\n\n    For example, given price_changes = [5, 3, 8, 6, 7] and queries = [(1, 3), (0, 4)],\n    the function would return [3, 3], representing the minimum additional costs for the ranges 1-3 and 0-4 respectively.\n\n    Notes:\n    - The first element corresponds to an additional cost for the first clone operation.\n    - The queries are provided in zero-based indexing.\n    - Assume that the cloning device is only used a 'manageable' number of times such that price_changes length does not exceed 10^5.\n    \"\"\"", "canonical_solution": "    class SegmentTree:\n        def __init__(self, data):\n            self.n = len(data)\n            self.tree = [0] * (2 * self.n)\n            self.build(data)\n\n        def build(self, data):\n            for i in range(self.n):\n                self.tree[self.n + i] = data[i]\n            for i in range(self.n - 1, 0, -1):\n                self.tree[i] = min(self.tree[i * 2], self.tree[i * 2 + 1])\n\n        def range_min(self, l, r):\n            l += self.n\n            r += self.n\n            r += 1\n            minimum = float('inf')\n            while l < r:\n                if l & 1:\n                    minimum = min(minimum, self.tree[l])\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    minimum = min(minimum, self.tree[r])\n                l >>= 1\n                r >>= 1\n            return minimum\n\n    def minimum_suffix_clone_time(price_changes, queries):\n        st = SegmentTree(price_changes)\n        return [st.range_min(l, r) for l, r in queries]", "entry_point": "minimum_suffix_clone_time", "test": "def check(candidate):\n    assert candidate([5, 3, 8, 6, 7], [(1, 3), (0, 4)]) == [3, 3]\n    assert candidate([2, 1, 9, 5, 3, 7], [(0, 3), (2, 5), (1, 1)]) == [1, 3, 1]\n    assert candidate([10, 20, 30, 40, 50], [(0, 4), (1, 2)]) == [10, 20]\n    assert candidate([3], [(0, 0)]) == [3]\n    assert candidate([7, 15, 1, 2, 3], [(0, 2), (2, 4)]) == [1, 1]", "extra_info": {"cover_story_words": ["cloning device", "cosmic carnival"], "topics": ["Suffix Array", "Segment Tree"], "cleaned_prompt": "Write a function that preprocesses a list of price changes and answers multiple queries for the minimum price change in given sub-ranges using a Segment Tree structure for efficient range minimum queries.", "warnings": ["Solution failed correctness check.", "4, Incorrect Algorithm Specification: The problem statement requires creating a 'Segment Tree' for range minimum queries but doesn't provide any validation to check if the candidate's solution properly uses a Segment Tree or simply manipulates array slices to find the minimum. This can result in candidates bypassing learning or applying the intended data structure concepts.", "5, Complexity and Practical Constraints Missing: Despite mentioning that the number of times the device is used is \"manageable,\" it lacks specific performance expectations or constraints on the execution time/space, particularly important given that the input size can be up to 100,000. This may lead to solutions that are inefficient or unsuspecting of the practical limitations in real-world scenarios.", "4, Input Specification Ambiguity: The problem defines the structure of 'price_changes' and 'queries' without explicitly stating the types of inputs or their limits (e.g., negative prices, maximum length of queries, etc.), potentially leading to incorrect assumptions and implementations by the candidate."]}}
{"task_id": "hard/5", "prompt": "def time_bending_clock(edges, queries):\n    \"\"\"\n    Imagine an alien civilization that uses a time-bending clock to manage interconnected times. Each temporal connection between two periods of time has an interval value which can increase or decrease as you move between them. These intervals and connections can be visualized as a directed graph where each vertex represents a period of time and each directed edge represents a connection with an interval value as its weight.\n\n    You need to answer queries about the shortest paths in this 'time-bending clock'. However, not only are you interested in the minimum distance, but also in strengthening the connectivity between these time periods using the concept of Strongly Connected Components (SCC) and exploring if the source and target are in the same SCC before finding the shortest path.\n\n    Tasks:\n    1. Determine which vertices (time periods) belong to the same Strongly Connected Component using Kosaraju's algorithm.\n    2. For each query, if the source and target vertices are in the same SCC, perform a Dijkstra's algorithm to find the shortest path. If they aren't in the same SCC or if there's no path, return -1.\n    \n    Each edge in the edges list is represented as (u, v, w), where u->v is a directed edge with weight w. \n\n    Queries is a list of tuples (src, trg), where you need to check if there's a path from src to trg and determine the shortest path if possible.\n\n    Notes:\n    - Assume the vertices are numbered from 0 to the maximum vertex found in the edges list.\n    - Graph might not be fully connected.\n    \"\"\"", "canonical_solution": "    def time_bending_clock(edges, queries):\n        from collections import defaultdict, deque\n        import heapq\n\n        def kosaraju(n, edges):\n            graph = defaultdict(list)\n            rgraph = defaultdict(list)\n            for u, v, w in edges:\n                graph[u].append((v, w))\n                rgraph[v].append((u, w))\n\n            order, visited = deque(), set()\n            def dfs(v):\n                visited.add(v)\n                for nei, _ in graph[v]:\n                    if nei not in visited:\n                        dfs(nei)\n                order.appendleft(v)\n\n            for v in range(n):\n                if v not in visited:\n                    dfs(v)\n\n            scc, visited = [], set()\n            def rev_dfs(v, component):\n                visited.add(v)\n                component.append(v)\n                for nei, _ in rgraph[v]:\n                    if nei not in visited:\n                        rev_dfs(nei, component)\n\n            for v in order:\n                if v not in visited:\n                    component = []\n                    rev_dfs(v, component)\n                    scc.append(component)\n\n            return scc\n\n        def dijkstra(src, trg, graph):\n            min_heap = [(0, src)]\n            dist = {src: 0}\n            while min_heap:\n                d, node = heapq.heappop(min_heap)\n                if node == trg:\n                    return d\n                for nei, weight in graph[node]:\n                    if nei not in dist or dist[nei] > d + weight:\n                        dist[nei] = d + weight\n                        heapq.heappush(min_heap, (dist[nei], nei))\n            return -1\n\n        n = max(max(u, v) for u, v, _ in edges) + 1\n        scc = kosaraju(n, edges)\n        idx_map = {node: idx for idx, component in enumerate(scc) for node in component}\n        graph = defaultdict(list)\n        for u, v, w in edges:\n            if idx_map[u] == idx_map[v]:\n                graph[u].append((v, w))\n\n        results = []\n        for src, trg in queries:\n            if idx_map[src] == idx_map[trg]:\n                res = dijkstra(src, trg, graph)\n                results.append(res)\n            else:\n                results.append(-1)\n        return results", "entry_point": "time_bending_clock", "test": "def check(candidate):\n    assert candidate([(0, 1, 1), (1, 2, 2), (2, 0, 3)], [(0, 2), (2, 1)]) == [3, -1], 'Test case 1 failed'\n    assert candidate([(0, 1, 5), (1, 2, 6), (2, 3, 7), (3, 1, 8)], [(0, 3), (3, 0)]) == [-1, -1], 'Test case 2 failed'\n    assert candidate([(0, 1, 2), (1, 0, 3), (2, 3, 4), (3, 2, 5)], [(0, 1), (2, 3)]) == [2, 4], 'Test case 3 failed'\n    assert candidate([(0, 1, 3), (1, 2, 4), (2, 3, 5), (3, 0, 1), (2, 1, 1)], [(0, 3), (1, 0)]) == [9, 2], 'Test case 4 failed'\n    assert candidate([(0, 1, 1), (1, 2, 1), (0, 3, 5), (3, 2, 1), (2, 0, 10)], [(0, 2), (3, 0), (1, 3)]) == [2, 16, 6], 'Test case 5 failed'", "extra_info": {"cover_story_words": ["time-bending clock", "aliens"], "topics": ["Kosaraju's Algorithm", "Binary Search"], "cleaned_prompt": "Write a function that processes a directed weighted graph to find the shortest paths for specified queries using Strongly Connected Components (SCC) separation and Dijkstra's shortest path algorithm. If source and target are not in the same SCC or no path exists, return -1.", "warnings": ["Solution failed correctness check.", "4, Problem Specification Inaccuracy: The problem description indicates the requirement of using Kosaraju's Algorithm explicitly, which is a specific method for finding Strongly Connected Components (SCC), but it does not specify how dealing with the graph's connectivity affects the shortest path calculations clearly. This may lead to ambiguities in implementing Dijkstra's algorithm regarding handling nodes that are not interconnected through SCCs.", "4, Incorrect Algorithm Constraint: The canonical solution provided uses Dijkstra's algorithm for finding the shortest path. However, Dijkstra's algorithm is typically used for graphs with non-negative weights. Although the prompt doesn't explicitly mention negative weights, it includes terms like \"increase or decrease,\" which might suggest interval adjustments that could be negative. This requires clarification, or an alternative approach like the Bellman-Ford algorithm should be suggested if negative weights are possible."]}}
{"task_id": "hard/4", "prompt": "def gemstone_mine_layout(mine_layout):\n    \"\"\"\n    You are an expert gemstone miner and you are planning the layout for a new mine. The mine layout is represented as an undirected graph where each node is a possible gemstone deposit and each edge has a weight representing the cost to tunnel between two deposits.\n\n    Your goal is to minimize the overall cost of connecting all deposits in such a way that there is a single connected component, whilst also ensuring that no part of the mine is overly difficult to reach in an emergency. You decide to use a two-phase approach:\n\n    Phase 1: Use a Minimum Spanning Tree (MST) algorithm to connect all nodes with the minimal total edge weight.\n    Phase 2: Apply Centroid Decomposition to the MST to find a central deposit (or deposits) such that removing this deposit (or these deposits) will split the mine graph into components where each component has at most half the nodes of the original MST.\n\n    The function should return the IDs of the centroid deposits found in the second phase after constructing the MST in the first phase.\n\n    Input:\n        mine_layout: List of tuples (u, v, w) representing the edges of the graph where u and v are node IDs (0-indexed) and w is the weight of the edge between u and v.\n\n    Output:\n        A list of the node IDs that are centroids after decomposing the MST.\n\n    Constraints:\n    - The graph is connected.\n    - The graph may contain up to 10,000 nodes and 20,000 edges.\n\n    Examples:\n        - If the input graph forms a path like [(0, 1, 5), (1, 2, 3), (2, 3, 4)], the MST is the same as the input graph and the centroid is [2].\n        - For a star shaped graph [(0, 1, 2), (0, 2, 2), (0, 3, 2)], the resulting MST is the same and the centroid is [0].\n    \"\"\"", "canonical_solution": "    import heapq\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        else:\n            return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else :\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    def mst_kruskal(nodes, edges):\n        result = []\n        i, e = 0, 0\n        edges = sorted(edges, key=lambda item: item[2])\n        parent, rank = [], []\n        for node in range(nodes):\n            parent.append(node)\n            rank.append(0)\n        while e < nodes - 1:\n            u, v, w = edges[i]\n            i = i + 1\n            x = find(parent, u)\n            y = find(parent, v)\n            if x != y:\n                e = e + 1\n                result.append((u, v, w))\n                union(parent, rank, x, y)\n        return result\n\n    def centroid_decomposition(tree, nodes):\n        sub_size = [1] * nodes\n        def dfs(node, parent):\n            size = 1\n            max_subtree = 0\n            for neighbor in tree[node]:\n                if neighbor != parent:\n                    subtree_size = dfs(neighbor, node)\n                    size += subtree_size\n                    max_subtree = max(max_subtree, subtree_size)\n            sub_size[node] = size\n            return size\n        root = 0\n        dfs(root, -1)  # Arbitrary root for DFS\n        min_subtree = nodes\n        centroid = root\n        for i in range(nodes):\n            max_child_tree = max((sub_size[child] for child in tree[i] if sub_size[child] < sub_size[i]), default=0)\n            largest_remainder = nodes - sub_size[i]\n            if max(max_child_tree, largest_remainder) < min_subtree:\n                min_subtree = max(max_child_tree, largest_remainder)\n                centroid = i\n        return [centroid]\n\n    node_count = max(max(u, v) for u, v, w in mine_layout) + 1\n    mst = mst_kruskal(node_count, mine_layout)\n    tree = {i: [] for i in range(node_count)}\n    for u, v, w in mst:\n        tree[u].append(v)\n        tree[v].append(u)\n    centroids = centroid_decomposition(tree, node_count)\n    return centroids", "entry_point": "gemstone_mine_layout", "test": "def check(candidate):\n    assert candidate([(0, 1, 5), (1, 2, 3), (2, 3, 4)]) == [2]\n    assert candidate([(0, 1, 2), (0, 2, 2), (0, 3, 2)]) == [0]\n    assert candidate([(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 5)]) == [3]\n    assert candidate([(i, i+1, 1) for i in range(100)]) == [50, 51]\n    assert candidate([(0, 2, 2), (0, 3, 2), (2, 3, 1), (2, 1, 1), (1, 3, 3)]) == [2]", "extra_info": {"cover_story_words": ["gemstone mine", "crystal ball"], "topics": ["Minimum Spanning Tree", "Centroid Decomposition"], "cleaned_prompt": "Write a function that takes a list of edges of a connected undirected graph where each edge has a weight, and returns the centroids after: 1) Constructing a Minimum Spanning Tree; 2) Applying Centroid Decomposition to the MST.", "warnings": ["Solution failed correctness check.", "5, Ambiguous Problem Definition: The problem statement does not specify whether the input graph could potentially contain cycles or self-loops, which could affect the construction of the Minimum Spanning Tree (MST).", "5, Incomplete Canonical Solution: The provided canonical solution appears to assume that the centroid decomposition will always find one centroid, whereas, in practice, two centroids might be found for even-numbered nodes as seen in one of the test cases. The solution should generalize to handle multiple centroids, but it does not.", "5, Incorrect Assumptions in Solution: The solution assumes a graph starting from node 0 to max ID, but the problem does not explicitly guarantee contiguous node IDs spanning from 0 to max ID. There could exist cases where nodes are non-contiguously numbered which the solution might not handle correctly.", "5, Logical Error in Implementation: The centroid decomposition logic in the canonical solution might not function correctly for trees where the best centroid split involves a nuanced analysis of children and subtree sizes. The approach to find the centroid simplistically assumes only one pass of comparison will suffice.", "5, Missing Edge Cases in Problem Statement: The problem statement and canonical solution don't discuss the expected behavior or output format clearly when there are multiple possible correct centroids, making it ambiguous how multiple solutions would be handled."]}}
{"task_id": "hard/2", "prompt": "def emergency_triage(patients, queries):\n    \"\"\"\n    In the mystical hospital dedicated to treating magical creatures, you are tasked to manage the emergency room's triage system. Each patient is represented by a tuple containing universally unique identifier (UUID as integer), heal score (HS as integer) indicating the gravity of their condition, and the magical species (MS as string).\n\n    Patients are initially given in a list of tuples -- patients. Every day, the Chief Medical Mage sends queries to check on certain statistics from the current queue of patients waiting for care.\n\n    Your goal is to implement a function that processes these queries using a combination of Monte Carlo Tree Search (MCTS) for decision-making and Mo's Algorithm for efficient data retrieval.\n\n    A query consists of a tuple: ('species', magical_species_indicator),('minimum_heal_score', value) or ('top_uuids', count) and you should return:\n    - For ('species', magical_species_indicator): a list of UUIDs of all the patients of the given species sorted by their heal scores in descending order.\n    - For ('minimum_heal_score', value): a list of UUIDs of all the patients with a heal score higher than the specified value, sorted by their heal scores in descending order.\n    - For ('top_uuids', count): a list of UUIDs of patients with the 'count' highest heal scores, sorted by their heal scores in descending order.\n\n    Assumptions:\n    - Reports must be output with the best efficiency possible due to the high volume of daily requests. Mo's Algorithm should be adapted to manage the high number of queries effectively.\n    - Decisions about which query to prioritize may be simulated using a basic form of MCTS to estimate the best order to process incoming queries to maximize the efficacy of response times.\n\n    Notes:\n    - The UUIDs are all unique positive integers, heal scores are positive integers, and the magical species are non-empty strings.\n    \"\"\"\n", "canonical_solution": "    def emergency_triage(patients, queries):\n        # Implementing Mo's Algorithm logic here\n\n        # MCTS for decision making on query order would be orchestrated here\n\n        # Providing solutions to the transformed queries based on above logic\n\n        return", "test": "def check(candidate):\n    patients = [(101, 50, 'dragon'), (102, 75, 'unicorn'), (103, 45, 'pixie'), (104, 80, 'gnome')]\n    q1 = [('species', 'dragon'), ('top_uuids', 2)]\n    q2 = [('minimum_heal_score', 70), ('top_uuids', 1)]\n    assert candidate(patients, q1) == {(101, 50)}, {104, 102})\n    assert candidate(patients, q2) == ({102, 104}, {104})\n    assert candidate([], []) == ()\n    assert candidate([(201, 95, 'goblin')], [('minimum_heal_score', 90)]) == ({201})", "entry_point": "emergency_triage", "extra_info": {"cover_story_words": ["hospital", "magical creatures"], "topics": ["Monte Carlo Tree Search", "Mo's Algorithm"], "cleaned_prompt": "Implement a function that takes a list of tuples (patients) and a list of tuples (queries) and processes these queries using Monte Carlo Tree Search for decision making and Mo's Algorithm for efficient data retrieval. Patients tuple contains a UUID, a heal score, and the magical species. Queries can ask for patients of certain species, with a minimum heal score, or the top patients by heal score. Returned results should follow the query specifics and should be sorted where applicable.", "warnings": ["Only 4 test cases found. Minimum recommended is 5.", "Solution failed correctness check.", "5, Incompatible Algorithm Usage: The problem statement suggests using Monte Carlo Tree Search (MCTS) for decision-making and Mo's Algorithm for efficient data retrieval. However, MCTS is typically used for decision-making in environments with a sequence of uncertain outcomes, which does not align with the deterministic nature of processing queries. Mo's Algorithm, on the other hand, is specific to offline query processing over static arrays predominantly for range query problems and might not be optimally suited for the described variety of queries which are not bound to range restrictions but involve sorting and complex filtering.", "4, Over-complex Solutions: The prompt requires implementation of advanced algorithms (MCTS and Mo's Algorithm) which are not straightforward to integrate given the data operations (sorting, filtering by score or type) described. This can lead to an unnecessarily complex solution that may over-complicate the relatively straightforward problem of sorting and querying patient records based on given criteria."]}}
