{"task_id": "hard/4", "prompt": "def decrypt_enchanted_book(pages, cipher):\n    \"\"\"\n    In the dystopian cyberpunk future, an ancient enchanted book containing secrets of the old world has been discovered.\n    The book's content is encrypted and each page in the book is filled with strings of binary numbers. However, you deciphered a cipher that can be used to decrypt the book.\n\n    You have to write a function that takes a list of pages, where each page is a list of binary strings, and a cipher, which also consists of binary strings. Your task is to determine if any of the cipher strings can form an exact line-by-line overlay match on any part of a page.\n\n    A cipher 'matches' a page if each line of the cipher can consecutively match a sequence of strings (lines) on the page when applied as a bitmask starting from any line within that page. A match with the bitmask involves string-based XOR operations, where if the result is all zeros, it means the cipher matches the page section.\n\n    The function should return the number of pages that have at least one valid match of the cipher.\n\n    Example:\n    If you have pages = [[\"010\", \"011\", \"100\"], [\"100\", \"110\", \"101\"]]\n    and cipher = [\"101\", \"001\"], the output should be 2 as the cipher matches part of both pages.\n\n    Note: All binary strings within pages and cipher are the same length and made up solely of '0' and '1'.\n    \"\"\"\n", "canonical_solution": "    def overlay_matches(page, cipher):\n        for start in range(len(page) - len(cipher) + 1):\n            if all(int(page[start + i], 2) ^ int(cipher[i], 2) == 0 for i in range(len(cipher))):\n                return True\n        return False\n\n    count = 0\n    for page in pages:\n        if any(overlay_matches(page, c) for c in cipher):\n            count += 1\n    return count", "test": "def check(candidate):\n    assert candidate([['010', '011', '100'], ['100', '110', '101']], ['101', '001']) == 2\n    assert candidate([['000', '111', '000'], ['111', '111', '111']], ['111']) == 2\n    assert candidate([['101', '010', '101'], ['010', '101', '010']], ['101', '010']) == 2\n    assert candidate([['000', '000', '000']], ['111']) == 0\n    assert candidate([], ['010']) == 0", "entry_point": "decrypt_enchanted_book", "invalid_reason": "Valid with warnings: ['Solution failed correctness check.', '4, Ambiguity in XOR Operation Explanation: The problem prompt mentions using an XOR operation between strings line-by-line and checking for matches, but it does not clearly explain how these strings are converted for a bitwise XOR operation, especially for someone not familiar with binary numeral system manipulations in programming, which could lead to confusion on how to implement the XOR operation on strings.']"}
{"task_id": "hard/3", "prompt": "def merge_sort_level_travel(trees, depth):\n    \"\"\"\n    In a distant world where wizard schools are combined with magical circuses, students are challenged to create visual spectacles using enchanted binary trees. These trees grow levels of light orbs which emit varying degrees of luminance.\n\n    Each binary tree is represented as a nested list structure. Each student must determine the luminance at a certain depth across multiple trees. However, to provide an awe-inspiring visual, they must merge the luminance values in a sorted manner.\n\n    Write a function which takes a list of binary trees (each tree represented as a nested list) and a depth 'd'. The function should return a merged and sorted list of luminance values from the specified depth.\n\n    If a tree does not have nodes at a given depth, it should be ignored for that depth. The depth is 0-based.\n\n    Example:\n    Tree 1: [[1], [2, 3], [4, 5, 6]] -> represents a tree where root has luminance 1, second level has luminances 2 and 3, and third level has luminance values 4, 5, and 6.\n    Tree 2: [[1], [2]]\n    merge_sort_level_travel([[[1], [2, 3], [4, 5, 6]], [[1], [2]]], 1) should return [2, 2, 3] because both trees contribute their second-level luminance which are then sorted.\n    merge_sort_level_travel([[[1], [2, 3], [4, 5, 6]], [[1], [2]]], 2) should return [4, 5, 6] because only the first tree has a third level.\n    \"\"\"\n", "canonical_solution": "    def merge_sort(arr):\n        if len(arr) > 1:\n            mid = len(arr) // 2\n            L = arr[:mid]\n            R = arr[mid:]\n\n            merge_sort(L)\n            merge_sort(R)\n\n            i = j = k = 0\n\n            while i < len(L) and j < len(R):\n                if L[i] < R[j]:\n                    arr[k] = L[i]\n                    i += 1\n                else:\n                    arr[k] = R[j]\n                    j += 1\n                k += 1\n\n            while i < len(L):\n                arr[k] = L[i]\n                i += 1\n                k += 1\n\n            while j < len(R):\n                arr[k] = R[j]\n                j += 1\n                k += 1\n\n    def merge_sort_level_travel(trees, depth):\n        luminances = []\n        for tree in trees:\n            if len(tree) > depth:\n                luminances.extend(tree[depth])\n        merge_sort(luminances)\n        return luminances", "test": "def check(candidate):\n    assert candidate([[[1], [2, 3], [4, 5, 6]], [[1], [2]]], 1) == [2, 2, 3]\n    assert candidate([[[1], [2, 3], [4, 5, 6]]], 1) == [2, 3]\n    assert candidate([[[1], [2, 3], [4, 5]], [[1], [2, 3, 3], [4, 5]], [[1], [2, 3, 4]]], 2) == [4, 5, 5]\n    assert candidate([], 1) == []\n    assert candidate([[[1]], [[2]], [[3]]], 0) == [1, 2, 3]", "entry_point": "merge_sort_level_travel", "invalid_reason": "Valid with warnings: ['Solution failed correctness check.', \"5, Undefined Behavior for Negative Depth: The function's behavior is unspecified if a negative depth is provided. This could lead to unexpected behavior or errors, as the prompt does not describe handling of such cases.\", '5, Memory Efficiency in Sorting: The canonical solution suggests implementation of a merge sort that modifies the list in place using multiple recursive calls and list manipulations which can be memory inefficient and slow for large inputs. This could be problematic in a high-performance context.', '4, Handling of Non-Nested Lists: The prompt assumes each tree is properly formatted as a nested list but does not specify behavior if the input does not match this format (e.g., flat lists, mixed types). This could lead to runtime errors.']"}
