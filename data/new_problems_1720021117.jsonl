{"task_id": "hard/5", "prompt": "def storm_escape_path(rooms, portals):\n    \"\"\"\n    In a mystical land, a wizard resides in a complex of magical rooms connected by portals that form a directed acyclic graph (DAG). Each room is imbued with a storm's power which fluctuates in intensity. Unfortunately, a supernatural storm has become uncontrollable, and the wizard needs to seek shelter in the safest room (the room with minimal storm intensity).\n\n    You are to help the wizard by determining the optimal path to the safest room with the minimum cumulative storm power intensity. This is akin to the minimum path sum problem on DAGs, using dynamic programming and topological sorting.\n\n    The wizard's complex is described by:\n    - rooms: a list of integers representing the storm power in each room.\n    - portals: a list of tuples (a, b), representing a directed portal from room 'a' to room 'b'.\n\n    The function should return the minimum cumulative storm power intensity the wizard must endure to reach the safest room starting from any room.\n\n    Assume there are no cycles in the portals structure (the network forms a DAG).\n\n    Example Input:\n    rooms = [6, 10, 3, 1, 7]\n    portals = [(0,1), (1,2), (2,3), (0,4), (4,3)]\n    Output: 7 (Path: 0->4->3 with storm powers summing up to 6+1=7)\n\n    Constraints:\n    - Each room can have one or multiple escape paths, but the paths do not form cycles.\n\n    Note:\n    - The function should handle multiple starting points, and aim to calculate the safest pathway to the minimal storm room from any starting room.\n    \"\"\"", "canonical_solution": "    def storm_escape_path(rooms, portals):\n        from heapq import heappush, heappop\n        import sys\n\n        n = len(rooms)\n        adj_list = [[] for _ in range(n)]\n        for start, end in portals:\n            adj_list[start].append(end)\n\n        def topological_sort():\n            in_degree = [0] * n\n            for start, ends in enumerate(adj_list):\n                for end in ends:\n                    in_degree[end] += 1\n            stack = [i for i in range(n) if in_degree[i] == 0]\n            sorted_order = []\n            while stack:\n                node = stack.pop()\n                sorted_order.append(node)\n                for connected_node in adj_list[node]:\n                    in_degree[connected_node] -= 1\n                    if in_degree[connected_node] == 0:\n                        stack.append(connected_node)\n            return sorted_order\n\n        sorted_rooms = topological_sort()\n        dp = [sys.maxsize] * n\n        for room in sorted_rooms:\n            if not adj_list[room]:\n                dp[room] = rooms[room]\n            for next_room in adj_list[room]:\n                dp[next_room] = min(dp[next_room], dp[room] + rooms[next_room])\n\n        return min(dp)\n", "entry_point": "storm_escape_path", "test": "def check(candidate):\n    assert candidate([6, 10, 3, 1, 7], [(0,1), (1,2), (2,3), (0,4), (4,3)]) == 7\n    assert candidate([5, 1, 3, 9, 2], [(0,1), (0,2), (1,3), (2,3), (2,4), (4,3)]) == 3\n    assert candidate([1], []) == 1\n    assert candidate([2, 8, 5, 1], [(0,1), (0,2), (1,3), (2,3)]) == 3\n    assert candidate([3, 1, 10, 4, 7], [(0,1), (0,2), (1,3), (2,3), (3,4)]) == 8", "extra_info": {"cover_story_words": ["wizards", "supernatural storm"], "topics": ["Dynamic Programming", "Minimum Path Sum", "Topological Sort"], "cleaned_prompt": "Write a function storm_escape_path(rooms, portals) that calculates the minimum cumulative storm power intensity to reach the room with the smallest storm power from any starting room in a directed acyclic graph (DAG) setting. Each room has a storm power (given as an integer), and portals represent directed connections between rooms. Use dynamic programming and topological sort to solve the problem efficiently.", "warnings": ["Solution failed correctness check.", "4, Incorrect output format: The problem description states that the output should be the minimal cumulative storm power intensity that the wizard must endure to reach the safest room, which implies providing the result of the calculations directly. However, the provided example also specifies a path (0->4->3) with its cumulative power (6+1=7), making it ambiguous whether the function should return only the numerical sum or also include the path taken. This may confuse participants regarding what the expected output should be."]}}
{"task_id": "hard/3", "prompt": "def recover_artifacts(nav_grid, sub_path):\n    \"\"\"\n    During a deep-sea archaeological exploration, your submarine follows a predetermined path through a grid of sectors. Each sector on the grid can contain zero or more archaeological artifacts. After the submarine completes its path, it can communicate the sectors it traversed to the surface team. Based on environmental factors and the submarine's path, the likelihood of recovering artifacts from each sector varies.\n\n    The grid is represented as a 2D array 'nav_grid', where each element is a list that could contain names of artifacts found in that sector (e.g., ['vase', 'coin']). The submarine's path is a series of directions given as a list of tuples (row, col) starting from the top left corner (0, 0).\n\n    However, there is a complication. Due to communication errors and navigation glitches, the submarine might not follow the path perfectly. It has a known probability of rejection 'rejection_probability' that defines how often the submarine will reject moving to the intended next sector and instead randomly choose one of the adjacent sectors (up, down, left, or right). If the intended move was out of bounds or back to a previously visited sector, the rejection option is considered again.\n\n    Your task is to calculate the average number of unique artifacts that would be collected from the path, taking into account the rejection probability and ensuring the submarine remains within bounds and doesn't revisit sectors. The submarine can only move up, down, left, or right.\n\n    Example:\n    nav_grid = [[['ancient lamp'], []], [['rusted sword'], ['golden coin']]]\n    sub_path = [(0, 0), (1, 0), (1, 1)]\n    rejection_probability = 0.1\n\n    Assuming perfect navigation (0% rejection), the submarine collects: ['ancient lamp', 'rusted sword', 'golden coin'].\n\n    Note:\n    - The grid will have at least size 1x1 and can be non-square.\n    - The sub_path will start at (0, 0) and it will include valid positions within the bounds of the grid.\n    \"\"\"", "canonical_solution": "    def recover_artifacts(nav_grid, sub_path, rejection_probability):\n        import random\n        from collections import defaultdict\n\n        def in_bounds(r, c):\n            return 0 <= r < len(nav_grid) and 0 <= c < len(nav_grid[0])\n\n        def get_adjacent(r, c):\n            adj = []\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = r + dr, c + dc\n                if in_bounds(nr, nc):\n                    adj.append((nr, nc))\n            return adj\n\n        artifacts_collected = set()\n        current_position = sub_path[0]\n        artifacts_collected.update(nav_grid[current_position[0]][current_position[1]])\n\n        for next_position in sub_path[1:]:\n            if random.random() > rejection_probability:\n                if current_position == next_position:\n                    continue\n                artifacts_collected.update(nav_grid[next_position[0]][next_position[1]])\n                current_position = next_position\n            else:\n                possible_moves = get_adjacent(*current_position)\n                random_choice = random.choice(possible_moves)\n                artifacts_collected.update(nav_grid[random_choice[0]][random_choice[1]])\n                current_position = random_choice\n\n        return len(artifacts_collected)", "entry_point": "recover_artifacts", "test": "def check(candidate):\n    nav_grid1 = [[['vase'], []], [['coin'], ['rusted sword']]]\n    sub_path1 = [(0, 0), (1, 0), (1, 1)]\n    assert candidate(nav_grid1, sub_path1, 0) == 3\n    assert candidate(nav_grid1, sub_path1, 0.1) >= 2\n    assert candidate(nav_grid1, sub_path1, 1) >= 1\n\n    nav_grid2 = [[['vase', 'map'], ['treasure']], [['golden coin'], ['mask']]]\n    sub_path2 = [(0, 0), (0, 1)]\n    assert candidate(nav_grid2, sub_path2, 0) == 3\n    assert candidate(nav_grid2, sub_path2, 0.5) >= 2\n    assert candidate(nav_grid2, sub_path2, 1) >= 1", "extra_info": {"cover_story_words": ["archaeological dig", "submarine"], "topics": ["Rejection Sampling", "Strongly Connected Component", "Counting"], "cleaned_prompt": "The problem involves a submarine navigating a grid of sectors, each sector can contain archaeological artifacts. The submarine follows a defined path with a chance of deviation due to a 'rejection_probability' that causes it to potentially move to an adjacent sector instead of the intended. The task is to compute the average number of unique artifacts collected considering this probability.", "warnings": ["Solution failed correctness check.", "4, Missing rejection probability parameter: The task prompt does not specify the `rejection_probability` as a parameter for the `recover_artifacts` function, while the canonical solution and the test case definition include it. This discrepancy can lead to confusion about the function's definition and usage."]}}
{"task_id": "hard/2", "prompt": "def snake_concert_planner(courses, prerequisites):\n    \"\"\"\n    You are an event manager for a unique concert in the desert that features a live rock band, rare snakes, and interactive music courses. Attendees can take various music-related courses, but some courses have prerequisites that need to be taken first.\n\n    Each course is uniquely represented as an integer, and for each course, there might be one or more prerequisite courses. Given a list of courses and a list of prerequisite pairs, determine if it is possible for an attendee to complete all courses. The additional twist is that each course has a version with a rock music perspective and a version with a snake handling perspective, implemented as a node in a doubly linked list.\n\n    Implement this linked list internally to simulate the course and its perspectives. When checking if it is possible to finish all courses, both perspectives for each course (if exists) should still have prerequisites maintained.\n\n    Note:\n    - A course might or might not have a perspective version.\n    - Use a two-pointer approach to navigate and manage the doubly linked list.\n\n    Example:\n    If courses = [1,2,3], and prerequisites = [(1,2), (2,3)], there is a valid order: either [1,2,3] or its perspective ridden linked versions.\n\n    \"\"\"\n", "canonical_solution": "    class Node:\n        def __init__(self, course, next=None, prev=None):\n            self.course = course\n            self.next = next\n            self.prev = prev\n\n    def snake_concert_planner(courses, prerequisites):\n        if not courses:\n            return True\n\n        course_dict = {course: Node(course) for course in courses}\n\n        # Building the doubly linked list\n        for course in courses:\n            if course + 1 in course_dict:\n                course_dict[course].next = course_dict[course + 1]\n                course_dict[course + 1].prev = course_dict[course]\n\n        # Detecting cycle using two pointers\n        indegree = {course: 0 for course in courses}\n        for pre, course in prerequisites:\n            indegree[course] += 1\n        stack = [course for course in indegree if indegree[course] == 0]\n        visited = 0\n        while stack:\n            course = stack.pop()\n            visited += 1\n            node = course_dict[course]\n            if node.next and indegree[node.next.course] > 0:\n                indegree[node.next.course] -= 1\n                if indegree[node.next.course] == 0:\n                    stack.append(node.next.course)\n        return visited == len(courses)", "entry_point": "snake_concert_planner", "test": "def check(candidate):\n    assert candidate([1, 2, 3], [(1, 2), (2, 3)]) == True\n    assert candidate([1, 2, 3], [(1, 2), (2, 3), (3, 1)]) == False\n    assert candidate([1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)]) == True\n    assert candidate([], []) == True\n    assert candidate([1, 2], [(1, 2), (2, 1)]) == False", "extra_info": {"cover_story_words": ["music", "snakes and rocks"], "topics": ["Course Schedule", "Doubly-Linked List", "Two Pointers"], "cleaned_prompt": "Given a list of music courses and a list of prerequisite pairs between them, determine if it is possible to complete all courses. Each course can have two perspectives like 'Rock' and 'Snake handling' and can be considered as a node in a doubly linked list, meaning each course has two possible versions linked. When checking for course completion possibility, both perspectives and their prerequisites should be considered. Use two-pointers to manage the doubly linked list transitions.", "warnings": ["Solution failed correctness check.", "5, Ambiguity in Handling Twisted Perspectives: The problem statement introduces an intriguing complexity about multiple perspectives (Rock and Snake Handling) for each course but does not clearly describe how these versions affect the prerequisites and how they should be modeled in the solution. Moreover, it's unclear whether these perspectives are supposed to be separate nodes in the doubly linked list or if each course node should internally represent both perspectives. This lack of clarity can lead to various interpretations and inconsistent implementations.", "5, Inappropriate Doubly Linked List Utilization: The problem involves prerequisites and course ordering which typically suggests a graph-based approach (like detecting cycles in a directed graph). However, the problem forces the use of a doubly linked list to represent course sequences, which is not naturally suited for prerequisites management involving complex dependencies because doubly linked lists are linear structures. This mismatch complicates the solution unnecessarily and doesn't align well with the fundamental requirements of the problem.", "5, Unclear Requirements for Two-pointer Technique: The prompt suggests using a \"two-pointer approach\" to manage the doubly linked list, but it remains unclear how this technique should be effectively applied in the context of course prerequisites which inherently have a hierarchical structure, not a linear one. The two-pointer technique is usually applied to problems involving searches or window-based manipulations on arrays or linear linked lists, not for complex graph traversal or hierarchy resolution in a scenario like checking course completion feasibility."]}}
{"task_id": "hard/4", "prompt": "def restaurant_ordering_system(orders):\n    \"\"\"\n    In a magical world, you have a peculiar restaurant that serves a wide array of magical creatures. This restaurant specializes in dishes that can start with either a type of appetizer, main course, or dessert, and the creature orders based on a tri-level choice protocol implemented in a Binary Tree.\n\n    Each creature's name and their three-level order preference (appetizer, main, dessert) are encoded in a series of strings (example: 'pixie_sushi_fairyD3_tiramisu'). The restaurant uses a queue system to manage and process orders in a manner that the order string is traversed based on levels of a Binary Tree (Appetizer -> Main Course -> Dessert).\n\n    Your task:\n    - Process incoming complete detailed orders using a queue.\n    - Decode each order by traversing the corresponding levels of a binary tree to retrieve their string breakdown ('type_dish_level_specifics').\n    - The breakdown of each order is interpreted using a Trie to allow retrieving the full specifics efficiently when required for each level.\n\n    This will help the restaurant better manage the mystical creature orders in a time-efficient manner.\n\n    Example:\n    - Input: ['pixie_sushi_fairyD3_tiramisu', 'elf_burger_elfB1_cake']\n    - Processed Output:  ['pixie: fairyD3 -> sushi -> tiramisu', 'elf: elfB1 -> burger -> cake']\n\n    Note:\n    - You may need to create supporting data structures like Binary Tree and Trie to decode and process the orders effectively.\n    \"\"\"", "canonical_solution": "        class OrderTrieNode:\n            def __init__(self):\n                self.children = {}\n                self.end_order = False\n                self.order_details = None\n\n        class OrderTrie:\n            def __init__(self):\n                self.root = OrderTrieNode()\n\n            def insert(self, order_parts):\n                current_node = self.root\n                for part in order_parts:\n                    if part not in current_node.children:\n                        current_node.children[part] = OrderTrieNode()\n                    current_node = current_node.children[part]\n                current_node.end_order = True\n                current_node.order_details = ' -> '.join(order_parts)\n\n            def search(self, order_parts):\n                current_node = self.root\n                for part in order_parts:\n                    if part not in current_node.children:\n                        return None\n                    current_node = current_node.children[part]\n                return current_node.order_details if current_node.end_order else None\n\n        from collections import deque\n        def restaurant_ordering_system(orders):\n            order_queue = deque(orders)\n            trie = OrderTrie()\n            result_list = []\n            for order in orders:\n                order_parts = order.split('_')\n                trie.insert(order_parts)\n                result_list.append(f'{order_parts[0]}: {trie.search(order_parts)}')\n            return result_list", "entry_point": "restaurant_ordering_system", "test": "def check(candidate):\n    orders1 = ['pixie_sushi_fairyD3_tiramisu', 'elf_burger_elfB1_cake']\n    result1 = ['pixie: sushi -> fairyD3 -> tiramisu', 'elf: burger -> elfB1 -> cake']\n    assert candidate(orders1) == result1\n\n    orders2 = ['gnome_pasta_gnomeG7_pudding', 'troll_steak_trollT2_pie']\n    result2 = ['gnome: pasta -> gnomeG7 -> pudding', 'troll: steak -> trollT2 -> pie']\n    assert candidate(orders2) == result2\n\n    orders3 = []  # Empty scenario\n    result3 = []\n    assert candidate(orders3) == result3\n\n    orders4 = ['fairy_risotto_fairyF2_cheesecake']\n    result4 = ['fairy: risotto -> fairyF2 -> cheesecake']\n    assert candidate(orders4) == result4", "extra_info": {"cover_story_words": ["restaurant", "magical creatures"], "topics": ["Queue", "Trie", "Binary Tree Level Order Traversal"], "cleaned_prompt": "Given a list of strings representing orders made by mystical creatures in a magical restaurant (formatted as 'creature_dish_level_dessert'), implement a restaurant ordering system that processes these orders by constructing a Binary Tree for sequence traversal (Appetizer -> Main -> Dessert) and a Trie for efficient order detail retrieval. The function should return a list of processed orders in the format 'creature: main_dish -> level -> dessert'.", "warnings": ["Only 4 test cases found. Minimum recommended is 5.", "Solution failed correctness check.", "5, Inconsistency between Prompt and Canonical Solution: The prompt and canonical solution describe two different methods of processing and outputting the orders. The prompt suggests a tri-level choice utilizing a Binary Tree for traversal, whereas the canonical solution only involves a Trie and doesn't implement or use a Binary Tree. The expected format and processing sequence in the example given ('type: main -> level -> dessert') does not align with the described queuing and processing method.", "5, Binary Tree Functionality Unused: The provided task description repeatedly mentions the use of a Binary Tree for level-based order processing, but the actual implementation (canonical solution) completely omits any form of Binary Tree construction, usage, or traversal. This represents a critical flaw as it deviates significantly from the task requirements.", "4, Misleading Information on Output Order: The task prompt and the expected output format in the canonical solution seem to misalign regarding the order of details in the string. The example outputs in the prompt suggest a format of 'creature: level -> appetizer -> dessert', which directly contrasts the testing examples that display 'creature: appetizer -> level -> dessert'. This inconsistency could lead to confusion and incorrect implementations."]}}
{"task_id": "hard/1", "prompt": "def dragon_network(N, roads):\n    \"\"\"\n    Long ago, there existed an ancient civilization consisting of N distinct islands. The inhabitants of these islands were dragon tamers. Each dragon can be used to traverse between two islands, creating a network of dragon-flown paths.\n    The dragon paths are given as a list 'roads'. Each road is represented as a tuple (x, y, weight), where x and y are the indices of the islands connected by the road and weight is the cost of using that dragon path due to the dragon's energy consumption.\n\n    Your task is to design an efficient network of dragons such that all islands are connected with the minimal possible energy cost using the dragons. In other words, find the Minimum Spanning Tree (MST) of this network.\n\n    However, there is a complexity. The dragons are mysterious creatures and the roads between islands can only be traversed in a specific order, defined by the energy cost. You must use Radix Sort to sort the dragon paths based on their energy weights before determining the MST using the Union-Find algorithm.\n\n    Input:\n    - N: an integer representing the number of islands (1 <= N <= 10^4).\n    - roads: a list of tuples where each tuple contains three integers (x, y, weight), representing the island indices (0 <= x, y < N) and the dragon's energy cost (0 <= weight <= 10^5).\n\n    Output:\n    Return the minimum cost of energy needed to connect all the islands.\n\n    Example:\n    - If N = 4 and roads = [(0, 1, 5), (1, 2, 4), (2, 3, 7), (0, 2, 6), (1, 3, 2)], then output should be 11 (minimum spanning tree will include edges with weights 2, 4, 5).\n\n    Note:\n    - If no MST can be formed (i.e., the islands can't be fully connected), return -1.\n    \"\"\"\n    pass", "canonical_solution": "    def dragon_network(N, roads):\n        def radix_sort(arr):\n            max_value = max(arr, key=lambda x: x[2])[2]\n            exp = 1\n            while max_value / exp > 1:\n                count_sort(arr, exp)\n                exp *= 10\n\n        def count_sort(arr, exp):\n            n = len(arr)\n            output = [0] * n\n            count = [0] * 10\n            for i in range(n):\n                index = arr[i][2] // exp\n                count[index % 10] += 1\n            for i in range(1, 10):\n                count[i] += count[i - 1]\n            i = n - 1\n            while i >= 0:\n                index = arr[i][2] // exp\n                output[count[index % 10] - 1] = arr[i]\n                count[index % 10] -= 1\n                i -= 1\n            for i in range(n):\n                arr[i] = output[i]\n\n        def find(parent, i):\n            if parent[i] == i:\n                return i\n            else:\n                return find(parent, parent[i])\n\n        def union(parent, rank, x, y):\n            xroot = find(parent, x)\n            yroot = find(parent, y)\n            if rank[xroot] < rank[yroot]:\n                parent[xroot] = yroot\n            elif rank[xroot] > rank[yroot]:\n                parent[yroot] = xroot\n            else :\n                parent[yroot] = xroot\n                rank[xroot] += 1\n\n        radix_sort(roads)\n        parent = list(range(N))\n        rank = [0] * N\n        result = 0\n        e = 0\n        i = 0\n        while e < N - 1 and i < len(roads):\n            (u, v, w) = roads[i]\n            i = i + 1\n            x = find(parent, u)\n            y = find(parent, v)\n            if x != y:\n                e = e + 1\n                result += w\n                union(parent, rank, x, y)\n\n        if e != N - 1:\n            return -1\n        return result", "entry_point": "dragon_network", "test": "def check(candidate):\n    assert candidate(4, [(0, 1, 5), (1, 2, 4), (2, 3, 7), (0, 2, 6), (1, 3, 2)]) == 11\n    assert candidate(1, []) == 0\n    assert candidate(2, [(0, 1, 1), (0, 1, 2)]) == 1\n    assert candidate(3, [(0, 1, 100000), (1, 2, 50000)]) == -1\n    assert candidate(5, [(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 4, 40), (4, 0, 5)]) == 95\n    assert candidate(4, [(0, 1, 7), (1, 2, 8), (0, 2, 6)]) == -1", "extra_info": {"cover_story_words": ["ancient civilization", "dragons"], "topics": ["Minimum Spanning Tree", "Radix Sort", "Union Find"], "cleaned_prompt": "Given an integer N representing number of islands and a list of tuples roads representing possible dragon paths between islands with their energy consumption cost, find the minimum cost of energy needed to connect all the islands using these paths. Sort the paths using Radix Sort on their energy cost and then apply the Union-Find algorithm to determine the Minimum Spanning Tree (MST) cost to connect all islands.", "warnings": ["Solution failed correctness check.", "5, Unnecessary complexity: The requirement to use Radix Sort for sorting weights before constructing the MST adds an unnecessary complexity to the problem. Given that typical MST algorithms like Kruskal's naturally involve sorting and efficiently handle this with comparison-based sorts, insisting on Radix Sort does not provide any algorithmic or educational benefit, and might confuse participants about the best practices in choosing sorting algorithms based on data characteristics.", "4, Incorrect edge case handling: The example test case \"assert candidate(5, [(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 4, 40), (4, 0, 5)]) == 95\" assumes a cycle including all nodes represents a valid MST, which it does (total weight = 105, not 95). However, this type of error in specifying correct outputs could lead to misconceptions about the properties of MSTs (an MST with 5 nodes should have 4 edges, not 5 as implied by the test case summing weights to 95)."]}}
